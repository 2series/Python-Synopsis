{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to Python Synopsis!\n\n\nPython Study Guide\n\n\nIn this repository I want to share resources, that helped me understand python programing language deeply. \nIt was not easy to find appropriate \nbooks, articles, answers from Stackoverflow, online courses, videos from py conferences\n and etc.   \n\n\nSo, after all I decided to share \ntop resources\n for everyone about each topic, that you need to know about python, if you want to be senior python \nSoftware Engineer\n.   \n\n\nOf course, it needs plenty of time to organize best resources based on the topics and it's hard for me to do it every day,  but I want to do min 1 chapter each week and now I think, that there will be more than \n30-40\n chapters.\n\n\n\n\nBeginner\n\n\nThe Python Programming Language, Implementation and Adventages\n\n\nPython Installation\n\n\nStart Coding With Python\n\n\nData Types In Python 3\n\n\nVariables and Assignment\n\n\nConditions\n\n\nFor Loop\n\n\n...\n\n\nFunctions\n\n\nScope\n\n\nScopes, Namespaces and LEGB Rule\n\n\n...\n\n\n\n\n\n\nIntermediate\n\n\n... \n\n\n\n\n\n\nAdvanced\n\n\n...\n\n\nContext Managers\n\n\nPython Metaclasses\n\n\nPython Magic Methods\n\n\n...",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-python-synopsis",
            "text": "",
            "title": "Welcome to Python Synopsis!"
        },
        {
            "location": "/#python-study-guide",
            "text": "In this repository I want to share resources, that helped me understand python programing language deeply. \nIt was not easy to find appropriate  books, articles, answers from Stackoverflow, online courses, videos from py conferences  and etc.     So, after all I decided to share  top resources  for everyone about each topic, that you need to know about python, if you want to be senior python  Software Engineer .     Of course, it needs plenty of time to organize best resources based on the topics and it's hard for me to do it every day,  but I want to do min 1 chapter each week and now I think, that there will be more than  30-40  chapters.   Beginner  The Python Programming Language, Implementation and Adventages  Python Installation  Start Coding With Python  Data Types In Python 3  Variables and Assignment  Conditions  For Loop  ...  Functions  Scope  Scopes, Namespaces and LEGB Rule  ...    Intermediate  ...     Advanced  ...  Context Managers  Python Metaclasses  Python Magic Methods  ...",
            "title": "Python Study Guide"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/",
            "text": "The Python Programming Language\n\n\n\n\nThe programming language you will learn is Python. Python is an example of a highlevel\nlanguage; other high-level languages you might have heard of are \nC, C++, Perl,\n\nand \nJava\n.\nThere are also low-level languages, sometimes referred to as \n\u201cmachine languages\u201d\n or\n\n\u201cassembly languages.\u201d\n Loosely speaking, computers can only run programs written in\nlow-level languages. So programs written in a high-level language have to be processed\nbefore they can run. This extra processing takes some time, which is a small disadvantage\nof high-level languages.\n\n\nThe advantages are enormous. First, it is much easier to program in a high-level lan\nguage. Programs written in a high-level language take less time to write, they are shorter\nand easier to read, and they are more likely to be correct. Second, high-level languages\nare portable, meaning that they can run on different kinds of computers with few or no\nmodifications. Low-level programs can run on only one kind of computer and have to\nbe rewritten to run on another.\n\n\nDue to these advantages, almost all programs are written in high-level languages. Lowlevel\nlanguages are used only for a few specialized applications.\n\n\nTwo kinds of programs process high-level languages into low-level languages:\ninterpreters and compilers. An interpreter reads a high-level program and executes it,\nmeaning that it does what the program says. It processes the program a little at a time,\nalternately reading lines and performing computations. Figure 1-1 shows the structure\nof an interpreter.\n\n\n \n\n\nA compiler reads the program and translates it completely before the program starts\nrunning. In this context, the high-level program is called the source code, and the\ntranslated program is called the object code or the executable. Once a program is com\npiled, you can execute it repeatedly without further translation. Figure 1-2 shows the\nstructure of a compiler.\n\n\n\n\nPython is considered an interpreted language because Python programs are executed\nby an interpreter. There are two ways to use the interpreter: \ninteractive\n mode and \nscript mode\n. In interactive mode, you type Python programs and the interpreter displays the\nresult:\n>>> 1 + 1\n2\nThe chevron, >>>, is the prompt the interpreter uses to indicate that it is ready. If you\ntype 1 + 1, the interpreter replies 2.\n\n\nAlternatively, you can store code in a file and use the interpreter to execute the contents\nof the file, which is called a script. By convention, Python scripts have names that end\nwith .py.\nTo execute the script, you have to tell the interpreter the name of the file. If you have a\nscript named dinsdale.py and you are working in a UNIX command window, you type\npython dinsdale.py. In other development environments, the details of executing\nscripts are different. You can find instructions for your environment at the Python web\nsite http://python.org.\nWorking in interactive mode is convenient for testing small pieces of code because you\ncan type and execute them immediately. But for anything more than a few lines, you\nshould save your code as a script so you can modify and execute it in the future.\n\n\n\n\nSource:\n \n\n\n  \nThink Python\n by Allen B. Downey  - 2012\n\n\n\n\nPython\u2019s View\n\n\nThe brief description in the prior section is fairly standard for scripting languages, and\nit\u2019s usually all that most Python programmers need to know. You type code into text\nfiles, and you run those files through the interpreter. Under the hood, though, a bit\nmore happens when you tell Python to \u201cgo.\u201d Although knowledge of Python internals\nis not strictly required for Python programming, a basic understanding of the runtime\nstructure of Python can help you grasp the bigger picture of program execution.\nWhen you instruct Python to run your script, there are a few steps that Python carries\nout before your code actually starts crunching away. Specifically, it\u2019s first compiled to\nsomething called \u201cbyte code\u201d and then routed to something called a \u201cvirtual machine.\u201d\n\n\nByte code compilation\n\n\nInternally, and almost completely hidden from you, when you execute a program\nPython first compiles your source code (the statements in your file) into a format known\nas byte code. Compilation is simply a translation step, and byte code is a lower-level,\nplatform-independent representation of your source code. Roughly, Python translates\neach of your source statements into a group of byte code instructions by decomposing\nthem into individual steps. This byte code translation is performed to speed\nexecution\u2014byte code can be run much more quickly than the original source code\nstatements in your text file.\nYou\u2019ll notice that the prior paragraph said that this is almost completely hidden from\nyou. If the Python process has write access on your machine, it will store the byte code\nof your programs in files that end with a .pyc extension (\u201c.pyc\u201d means compiled \u201c.py\u201d\nsource). You will see these files show up on your computer after you\u2019ve run a few\nprograms alongside the corresponding source code files (that is, in the same\ndirectories).\nPython saves byte code like this as a startup speed optimization. The next time you run\nyour program, Python will load the .pyc files and skip the compilation step, as long as\nyou haven\u2019t changed your source code since the byte code was last saved. Python automatically\nchecks the timestamps of source and byte code files to know when it must\nrecompile\u2014if you resave your source code, byte code is automatically re-created the\nnext time your program is run.\nIf Python cannot write the byte code files to your machine, your program still works\u2014\nthe byte code is generated in memory and simply discarded on program exit.* However,\nbecause .pyc files speed startup time, you\u2019ll want to make sure they are written for larger\nprograms. Byte code files are also one way to ship Python programs\u2014Python is happy\nto run a program if all it can find are .pyc files, even if the original .py source files are\nabsent.\n\n\nThe Python Virtual Machine (PVM)\n\n\nOnce your program has been compiled to byte code (or the byte code has been loaded\nfrom existing .pyc files), it is shipped off for execution to something generally known\nas the Python Virtual Machine (PVM, for the more acronym-inclined among you). The\nPVM sounds more impressive than it is; really, it\u2019s not a separate program, and it need\nnot be installed by itself. In fact, the PVM is just a big loop that iterates through your\nbyte code instructions, one by one, to carry out their operations. The PVM is the runtime\nengine of Python; it\u2019s always present as part of the Python system, and it\u2019s the\ncomponent that truly runs your scripts. Technically, it\u2019s just the last step of what is\ncalled the \u201cPython interpreter.\u201d\n\n\n\n\nFigure  illustrates the runtime structure described here. Keep in mind that all of this\ncomplexity is deliberately hidden from Python programmers. Byte code compilation is\nautomatic, and the PVM is just part of the Python system that you have installed on\nyour machine. Again, programmers simply code and run files of statements.\n\n\nPerformance implications\n\n\nReaders with a background in fully compiled languages such as C and C++ might notice\na few differences in the Python model. For one thing, there is usually no build or \u201cmake\u201d\nstep in Python work: code runs immediately after it is written. For another, Python byte\ncode is not binary machine code (e.g., instructions for an Intel chip). Byte code is a\nPython-specific representation.\n\n\nThis is why some Python code may not run as fast as C or C++ code, as described in\nChapter 1\u2014the PVM loop, not the CPU chip, still must interpret the byte code, and\nbyte code instructions require more work than CPU instructions. On the other hand,\nunlike in classic interpreters, there is still an internal compile step\u2014Python does not\nneed to reanalyze and reparse each source statement repeatedly. The net effect is that\npure Python code runs at speeds somewhere between those of a traditional compiled\nlanguage and a traditional interpreted language. See Chapter 1 for more on Python\nperformance tradeoffs.\n\n\n\n\nSource:\n \n\n\n  \nLearning Python, Fourth Edition\n by Mark Lutz  - 2009\n\n\n\n\nPython Implementation Alternatives\n\n\nReally, as this book is being written, there are three primary implementations of the\nPython language\u2014CPython, Jython, and IronPython\u2014along with a handful of secondary\nimplementations such as Stackless Python. In brief, CPython is the standard implementation;\nall the others have very specific purposes and roles. All implement the\nsame Python language but execute programs in different ways.\n\n\nCPython\n\n\nThe original, and standard, implementation of Python is usually called CPython, when\nyou want to contrast it with the other two. Its name comes from the fact that it is coded\nin portable ANSI C language code. This is the Python that you fetch from http://www\n.python.org, get with the ActivePython distribution, and have automatically on most\nLinux and Mac OS X machines. If you\u2019ve found a preinstalled version of Python on\nyour machine, it\u2019s probably CPython, unless your company is using Python in very\nspecialized ways.\nUnless you want to script Java or .NET applications with Python, you probably want\nto use the standard CPython system. Because it is the reference implementation of the\nlanguage, it tends to run the fastest, be the most complete, and be more robust than\nthe alternative systems. Figure 1-3 reflects CPython\u2019s runtime architecture.\n\n\nJython\n\n\nThe Jython system (originally known as JPython) is an alternative implementation of\nthe Python language, targeted for integration with the Java programming language.\nJython consists of Java classes that compile Python source code to Java byte code and\nthen route the resulting byte code to the Java Virtual Machine (JVM). Programmers\nstill code Python statements in .py text files as usual; the Jython system essentially just\nreplaces the rightmost two bubbles in Figure 1-3 with Java-based equivalents.\nJython\u2019s goal is to allow Python code to script Java applications, much as CPython\nallows Python to script C and C++ components. Its integration with Java is remarkably\nseamless. Because Python code is translated to Java byte code, it looks and feels like a\ntrue Java program at runtime. Jython scripts can serve as web applets and servlets, build\nJava-based GUIs, and so on. Moreover, Jython includes integration support that allows\nPython code to import and use Java classes as though they were coded in Python.\nBecause Jython is slower and less robust than CPython, though, it is usually seen as a\ntool of interest primarily to Java developers looking for a scripting language to be a\nfrontend to Java code.\n\n\nIronPython\n\n\nA third implementation of Python, and newer than both CPython and Jython,\nIronPython is designed to allow Python programs to integrate with applications coded\nto work with Microsoft\u2019s .NET Framework for Windows, as well as the Mono open\nsource equivalent for Linux. .NET and its C# programming language runtime system\nare designed to be a language-neutral object communication layer, in the spirit of Microsoft\u2019s\nearlier COM model. IronPython allows Python programs to act as both client\nand server components, accessible from other .NET languages.\nBy implementation, IronPython is very much like Jython (and, in fact, was developed\nby the same creator)\u2014it replaces the last two bubbles in Figure 1-3 with equivalents\nfor execution in the .NET environment. Also, like Jython, IronPython has a special\nfocus\u2014it is primarily of interest to developers integrating Python with .NET components.\nBecause it is being developed by Microsoft, though, IronPython might also be\nable to leverage some important optimization tools for better performance.\nIronPython\u2019s scope is still evolving as I write this; for more details, consult the Python\nonline resources or search the Web.\n\n\n\n\nSource:\n \n\n\n \nLearning Python, Fourth Edition\n by Mark Lutz  - 2009\n\n\n\n\nPython Programming Language Advantages\n\n\nPython is a dynamic, strongly typed, object oriented, multipurpose programming language, designed to be quick (to learn, to use, and to understand), and to enforce a clean and uniform syntax.\n\n\n\n\nPython is dynamically typed: it means that you don't declare a type (e.g. 'integer') for a variable name, and then assign something of that type (and only that type). Instead, you have variable names, and you bind them to entities whose type stays with the entity itself. a = 5 makes the variable name a to refer to the integer 5. Later, a = \"hello\" makes the variable name a to refer to a string containing \"hello\". Static typed languages would have you declare int a and then a = 5, but assigning a = \"hello\" would have been a compile time error. On one hand, this makes everything more unpredictable (you don't know what a refers to). On the other hand, it makes very easy to achieve some results a static typed languages makes very difficult.\n\n\nPython is strongly typed. It means that if a = \"5\" (the string whose value is '5') will remain a string, and never coerced to a number if the context requires so. Every type conversion in python must be done explicitly. This is different from, for example, Perl or Javascript, where you have weak typing, and can write things like \"hello\" + 5 to get \"hello5\".\n\n\nPython is object oriented, with class-based inheritance. Everything is an object (including classes, functions, modules, etc), in the sense that they can be passed around as arguments, have methods and attributes, and so on. \n\n\nPython is multipurpose: it is not specialised to a specific target of users (like R for statistics, or PHP for web programming). It is extended through modules and libraries, that hook very easily into the C programming language.\n\n\nPython enforces correct indentation of the code by making the indentation part of the syntax. There are no control braces in Python. Blocks of code are identified by the level of indentation. Although a big turn off for many programmers not used to this, it is precious as it gives a very uniform style and results in code that is visually pleasant to read.\n\n\nThe code is compiled into byte code and then executed in a virtual machine. This means that precompiled code is portable between platforms.\n\n\n\n\nPython can be used for any programming task, from GUI programming to web programming with everything else in between. It's quite efficient, as much of its activity is done at the C level. Python is just a layer on top of C. There are libraries for everything you can think of: game programming and openGL, GUI interfaces, web frameworks, semantic web, scientific computing...\n\n\n\n\nSource:\n \n\n\n https://stackoverflow.com/questions/1909512/what-is-python-used-for\n\n\n\n\nAdventages again\n\n\n\n\nEasy Syntax\n\nPython's syntax is easy to learn, so both non-programmers and programmers can start programming right away.\n\n\nReadability\n\nPython's syntax is very clear, so it is easy to understand program code. (Python is often referred to as \"executable pseudo-code\" because its syntax mostly follows the conventions used by programmers to outline their ideas without the formal verbosity of code in most programming languages; in other words syntax of Python is almost identical to the simplified \"pseudo-code\" used by many programmers to prototype and describe their solution to other programmers. Thus Python can be used to prototype and test code which is later to be implemented in other programming languages).[citation needed]\n\n\nHigh-Level Language\n\nPython looks more like a readable, human language than like a low-level language. This gives you the ability to program at a faster rate than a low-level language will allow you.\n\n\nObject oriented programming\n\nObject-oriented programming allows you to create data structures that can be re-used, which reduces the amount of repetitive work that you'll need to do. Programming languages usually define objects with namespaces, like class or def, and objects can edit themselves by using keyword, like this or self. Most modern programming languages are object-oriented (such as Java, C++, and C#) or have support for OOP features (such as Perl version 5 and later). Additionally object-oriented techniques can be used in the design of almost any non-trivial software and implemented in almost any programming or scripting language. (For example a number of Linux kernel features are \"objects\" which implement their own encapsulation of behavior and data structive via pointers, specifically pointers to functions, in the C programming language).[citation needed] Python's support for object-oriented programming is one of its greatest benefits to new programmers because they will be encountering the same concepts and terminology in their work environment. If you ever decide to switch languages, or use any other for that fact, you'll have a significant chance that you'll be working with object-oriented programming.[1]\n\n\nIt's Free\n\nPython is both free and open-source. The Python Software Foundation distributes pre-made binaries that are freely available for use on all major operating systems called CPython. You can get CPython's source-code, too. Plus, you can modify the source code and distribute as allowed by CPython's license. [2] (Luckily, CPython has a permissive free software license attitude.)\n\n\nCross-platform\n\nPython runs on all major operating systems like Microsoft Windows, Linux, and Mac OS X.\n\n\nWidely Supported\n\nPython has an active support community with many web sites, mailing lists, and USENET \"netnews\" groups that attract a large number of knowledgeable and helpful contributes.\n\n\nIt's Safe\n\nPython doesn't have pointers like other C-based languages, making it much more reliable. Along with that, errors never pass silently unless they're explicitly silenced. This allows you to see and read why the program crashed and where to correct your error.\n\n\nBatteries Included\n\nPython is famous for being the \"batteries are included\" language.[3] There are over 300 standard library modules which contain modules and classes for a wide variety of programming tasks.[citation needed] For example the standard library contains modules for safely creating temporary files (named or anonymous), mapping files into memory (including use of shared and anonymous memory mappings), spawning and controlling sub-processes, compressing and decompressing files (compatible with gzip or PK-zip) and archives files (such as Unix/Linux \"tar\"), accessing indexed \"DBM\" (database) files, interfacing to various graphical user interfaces (such as the TK toolkit and the popular WxWindows multi-platform windowing system), parsing and maintaining CSV (comma-separated values) and \".cfg\" or \".ini\" configuration files (similar in syntax to the venerable WIN.INI files from MS-DOS and MS-Windows), for sending e-mail, fetching and parsing web pages, etc. It's possible, for example, to create a custom web server in Python using less than a dozen lines of code, and one of the standard libraries, of course.\n\n\nExtensible\n\nIn addition to the standard libraries there are extensive collections of freely available add-on modules, libraries, frameworks, and tool-kits. These generally conform to similar standards and conventions; for example almost all of the database adapters (to talk to almost any client-server RDBMS engine such as MySQL, Postgres, Oracle, etc) conform to the Python DBAPI and thus can mostly be accessed using the same code. So it's usually easy to modify a Python program to support any database engine.\n\n\n\n\n\n\nSource:\n \n\n\n https://en.wikiversity.org/wiki/Python_Concepts/Why_learn_Python\n\n\n\n\nWho Uses Python Today ?\n\n\nHere are links to just a few of the organizations that use python:\n\n- \n https://wiki.python.org/moin/OrganizationsUsingPython\n\n\nPython Success Stories :\n\n- \n https://www.python.org/about/success",
            "title": "The Python Programming Language, Implementation and Adventages"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#the-python-programming-language",
            "text": "The programming language you will learn is Python. Python is an example of a highlevel\nlanguage; other high-level languages you might have heard of are  C, C++, Perl, \nand  Java .\nThere are also low-level languages, sometimes referred to as  \u201cmachine languages\u201d  or \u201cassembly languages.\u201d  Loosely speaking, computers can only run programs written in\nlow-level languages. So programs written in a high-level language have to be processed\nbefore they can run. This extra processing takes some time, which is a small disadvantage\nof high-level languages.  The advantages are enormous. First, it is much easier to program in a high-level lan\nguage. Programs written in a high-level language take less time to write, they are shorter\nand easier to read, and they are more likely to be correct. Second, high-level languages\nare portable, meaning that they can run on different kinds of computers with few or no\nmodifications. Low-level programs can run on only one kind of computer and have to\nbe rewritten to run on another.  Due to these advantages, almost all programs are written in high-level languages. Lowlevel\nlanguages are used only for a few specialized applications.  Two kinds of programs process high-level languages into low-level languages:\ninterpreters and compilers. An interpreter reads a high-level program and executes it,\nmeaning that it does what the program says. It processes the program a little at a time,\nalternately reading lines and performing computations. Figure 1-1 shows the structure\nof an interpreter.     A compiler reads the program and translates it completely before the program starts\nrunning. In this context, the high-level program is called the source code, and the\ntranslated program is called the object code or the executable. Once a program is com\npiled, you can execute it repeatedly without further translation. Figure 1-2 shows the\nstructure of a compiler.   Python is considered an interpreted language because Python programs are executed\nby an interpreter. There are two ways to use the interpreter:  interactive  mode and  script mode . In interactive mode, you type Python programs and the interpreter displays the\nresult:\n>>> 1 + 1\n2\nThe chevron, >>>, is the prompt the interpreter uses to indicate that it is ready. If you\ntype 1 + 1, the interpreter replies 2.  Alternatively, you can store code in a file and use the interpreter to execute the contents\nof the file, which is called a script. By convention, Python scripts have names that end\nwith .py.\nTo execute the script, you have to tell the interpreter the name of the file. If you have a\nscript named dinsdale.py and you are working in a UNIX command window, you type\npython dinsdale.py. In other development environments, the details of executing\nscripts are different. You can find instructions for your environment at the Python web\nsite http://python.org.\nWorking in interactive mode is convenient for testing small pieces of code because you\ncan type and execute them immediately. But for anything more than a few lines, you\nshould save your code as a script so you can modify and execute it in the future.   Source:       Think Python  by Allen B. Downey  - 2012",
            "title": "The Python Programming Language"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#pythons-view",
            "text": "The brief description in the prior section is fairly standard for scripting languages, and\nit\u2019s usually all that most Python programmers need to know. You type code into text\nfiles, and you run those files through the interpreter. Under the hood, though, a bit\nmore happens when you tell Python to \u201cgo.\u201d Although knowledge of Python internals\nis not strictly required for Python programming, a basic understanding of the runtime\nstructure of Python can help you grasp the bigger picture of program execution.\nWhen you instruct Python to run your script, there are a few steps that Python carries\nout before your code actually starts crunching away. Specifically, it\u2019s first compiled to\nsomething called \u201cbyte code\u201d and then routed to something called a \u201cvirtual machine.\u201d",
            "title": "Python\u2019s View"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#byte-code-compilation",
            "text": "Internally, and almost completely hidden from you, when you execute a program\nPython first compiles your source code (the statements in your file) into a format known\nas byte code. Compilation is simply a translation step, and byte code is a lower-level,\nplatform-independent representation of your source code. Roughly, Python translates\neach of your source statements into a group of byte code instructions by decomposing\nthem into individual steps. This byte code translation is performed to speed\nexecution\u2014byte code can be run much more quickly than the original source code\nstatements in your text file.\nYou\u2019ll notice that the prior paragraph said that this is almost completely hidden from\nyou. If the Python process has write access on your machine, it will store the byte code\nof your programs in files that end with a .pyc extension (\u201c.pyc\u201d means compiled \u201c.py\u201d\nsource). You will see these files show up on your computer after you\u2019ve run a few\nprograms alongside the corresponding source code files (that is, in the same\ndirectories).\nPython saves byte code like this as a startup speed optimization. The next time you run\nyour program, Python will load the .pyc files and skip the compilation step, as long as\nyou haven\u2019t changed your source code since the byte code was last saved. Python automatically\nchecks the timestamps of source and byte code files to know when it must\nrecompile\u2014if you resave your source code, byte code is automatically re-created the\nnext time your program is run.\nIf Python cannot write the byte code files to your machine, your program still works\u2014\nthe byte code is generated in memory and simply discarded on program exit.* However,\nbecause .pyc files speed startup time, you\u2019ll want to make sure they are written for larger\nprograms. Byte code files are also one way to ship Python programs\u2014Python is happy\nto run a program if all it can find are .pyc files, even if the original .py source files are\nabsent.",
            "title": "Byte code compilation"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#the-python-virtual-machine-pvm",
            "text": "Once your program has been compiled to byte code (or the byte code has been loaded\nfrom existing .pyc files), it is shipped off for execution to something generally known\nas the Python Virtual Machine (PVM, for the more acronym-inclined among you). The\nPVM sounds more impressive than it is; really, it\u2019s not a separate program, and it need\nnot be installed by itself. In fact, the PVM is just a big loop that iterates through your\nbyte code instructions, one by one, to carry out their operations. The PVM is the runtime\nengine of Python; it\u2019s always present as part of the Python system, and it\u2019s the\ncomponent that truly runs your scripts. Technically, it\u2019s just the last step of what is\ncalled the \u201cPython interpreter.\u201d   Figure  illustrates the runtime structure described here. Keep in mind that all of this\ncomplexity is deliberately hidden from Python programmers. Byte code compilation is\nautomatic, and the PVM is just part of the Python system that you have installed on\nyour machine. Again, programmers simply code and run files of statements.",
            "title": "The Python Virtual Machine (PVM)"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#performance-implications",
            "text": "Readers with a background in fully compiled languages such as C and C++ might notice\na few differences in the Python model. For one thing, there is usually no build or \u201cmake\u201d\nstep in Python work: code runs immediately after it is written. For another, Python byte\ncode is not binary machine code (e.g., instructions for an Intel chip). Byte code is a\nPython-specific representation.  This is why some Python code may not run as fast as C or C++ code, as described in\nChapter 1\u2014the PVM loop, not the CPU chip, still must interpret the byte code, and\nbyte code instructions require more work than CPU instructions. On the other hand,\nunlike in classic interpreters, there is still an internal compile step\u2014Python does not\nneed to reanalyze and reparse each source statement repeatedly. The net effect is that\npure Python code runs at speeds somewhere between those of a traditional compiled\nlanguage and a traditional interpreted language. See Chapter 1 for more on Python\nperformance tradeoffs.   Source:       Learning Python, Fourth Edition  by Mark Lutz  - 2009",
            "title": "Performance implications"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#python-implementation-alternatives",
            "text": "Really, as this book is being written, there are three primary implementations of the\nPython language\u2014CPython, Jython, and IronPython\u2014along with a handful of secondary\nimplementations such as Stackless Python. In brief, CPython is the standard implementation;\nall the others have very specific purposes and roles. All implement the\nsame Python language but execute programs in different ways.",
            "title": "Python Implementation Alternatives"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#cpython",
            "text": "The original, and standard, implementation of Python is usually called CPython, when\nyou want to contrast it with the other two. Its name comes from the fact that it is coded\nin portable ANSI C language code. This is the Python that you fetch from http://www\n.python.org, get with the ActivePython distribution, and have automatically on most\nLinux and Mac OS X machines. If you\u2019ve found a preinstalled version of Python on\nyour machine, it\u2019s probably CPython, unless your company is using Python in very\nspecialized ways.\nUnless you want to script Java or .NET applications with Python, you probably want\nto use the standard CPython system. Because it is the reference implementation of the\nlanguage, it tends to run the fastest, be the most complete, and be more robust than\nthe alternative systems. Figure 1-3 reflects CPython\u2019s runtime architecture.",
            "title": "CPython"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#jython",
            "text": "The Jython system (originally known as JPython) is an alternative implementation of\nthe Python language, targeted for integration with the Java programming language.\nJython consists of Java classes that compile Python source code to Java byte code and\nthen route the resulting byte code to the Java Virtual Machine (JVM). Programmers\nstill code Python statements in .py text files as usual; the Jython system essentially just\nreplaces the rightmost two bubbles in Figure 1-3 with Java-based equivalents.\nJython\u2019s goal is to allow Python code to script Java applications, much as CPython\nallows Python to script C and C++ components. Its integration with Java is remarkably\nseamless. Because Python code is translated to Java byte code, it looks and feels like a\ntrue Java program at runtime. Jython scripts can serve as web applets and servlets, build\nJava-based GUIs, and so on. Moreover, Jython includes integration support that allows\nPython code to import and use Java classes as though they were coded in Python.\nBecause Jython is slower and less robust than CPython, though, it is usually seen as a\ntool of interest primarily to Java developers looking for a scripting language to be a\nfrontend to Java code.",
            "title": "Jython"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#ironpython",
            "text": "A third implementation of Python, and newer than both CPython and Jython,\nIronPython is designed to allow Python programs to integrate with applications coded\nto work with Microsoft\u2019s .NET Framework for Windows, as well as the Mono open\nsource equivalent for Linux. .NET and its C# programming language runtime system\nare designed to be a language-neutral object communication layer, in the spirit of Microsoft\u2019s\nearlier COM model. IronPython allows Python programs to act as both client\nand server components, accessible from other .NET languages.\nBy implementation, IronPython is very much like Jython (and, in fact, was developed\nby the same creator)\u2014it replaces the last two bubbles in Figure 1-3 with equivalents\nfor execution in the .NET environment. Also, like Jython, IronPython has a special\nfocus\u2014it is primarily of interest to developers integrating Python with .NET components.\nBecause it is being developed by Microsoft, though, IronPython might also be\nable to leverage some important optimization tools for better performance.\nIronPython\u2019s scope is still evolving as I write this; for more details, consult the Python\nonline resources or search the Web.   Source:      Learning Python, Fourth Edition  by Mark Lutz  - 2009",
            "title": "IronPython"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#python-programming-language-advantages",
            "text": "Python is a dynamic, strongly typed, object oriented, multipurpose programming language, designed to be quick (to learn, to use, and to understand), and to enforce a clean and uniform syntax.   Python is dynamically typed: it means that you don't declare a type (e.g. 'integer') for a variable name, and then assign something of that type (and only that type). Instead, you have variable names, and you bind them to entities whose type stays with the entity itself. a = 5 makes the variable name a to refer to the integer 5. Later, a = \"hello\" makes the variable name a to refer to a string containing \"hello\". Static typed languages would have you declare int a and then a = 5, but assigning a = \"hello\" would have been a compile time error. On one hand, this makes everything more unpredictable (you don't know what a refers to). On the other hand, it makes very easy to achieve some results a static typed languages makes very difficult.  Python is strongly typed. It means that if a = \"5\" (the string whose value is '5') will remain a string, and never coerced to a number if the context requires so. Every type conversion in python must be done explicitly. This is different from, for example, Perl or Javascript, where you have weak typing, and can write things like \"hello\" + 5 to get \"hello5\".  Python is object oriented, with class-based inheritance. Everything is an object (including classes, functions, modules, etc), in the sense that they can be passed around as arguments, have methods and attributes, and so on.   Python is multipurpose: it is not specialised to a specific target of users (like R for statistics, or PHP for web programming). It is extended through modules and libraries, that hook very easily into the C programming language.  Python enforces correct indentation of the code by making the indentation part of the syntax. There are no control braces in Python. Blocks of code are identified by the level of indentation. Although a big turn off for many programmers not used to this, it is precious as it gives a very uniform style and results in code that is visually pleasant to read.  The code is compiled into byte code and then executed in a virtual machine. This means that precompiled code is portable between platforms.   Python can be used for any programming task, from GUI programming to web programming with everything else in between. It's quite efficient, as much of its activity is done at the C level. Python is just a layer on top of C. There are libraries for everything you can think of: game programming and openGL, GUI interfaces, web frameworks, semantic web, scientific computing...   Source:     https://stackoverflow.com/questions/1909512/what-is-python-used-for",
            "title": "Python Programming Language Advantages"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#adventages-again",
            "text": "Easy Syntax \nPython's syntax is easy to learn, so both non-programmers and programmers can start programming right away.  Readability \nPython's syntax is very clear, so it is easy to understand program code. (Python is often referred to as \"executable pseudo-code\" because its syntax mostly follows the conventions used by programmers to outline their ideas without the formal verbosity of code in most programming languages; in other words syntax of Python is almost identical to the simplified \"pseudo-code\" used by many programmers to prototype and describe their solution to other programmers. Thus Python can be used to prototype and test code which is later to be implemented in other programming languages).[citation needed]  High-Level Language \nPython looks more like a readable, human language than like a low-level language. This gives you the ability to program at a faster rate than a low-level language will allow you.  Object oriented programming \nObject-oriented programming allows you to create data structures that can be re-used, which reduces the amount of repetitive work that you'll need to do. Programming languages usually define objects with namespaces, like class or def, and objects can edit themselves by using keyword, like this or self. Most modern programming languages are object-oriented (such as Java, C++, and C#) or have support for OOP features (such as Perl version 5 and later). Additionally object-oriented techniques can be used in the design of almost any non-trivial software and implemented in almost any programming or scripting language. (For example a number of Linux kernel features are \"objects\" which implement their own encapsulation of behavior and data structive via pointers, specifically pointers to functions, in the C programming language).[citation needed] Python's support for object-oriented programming is one of its greatest benefits to new programmers because they will be encountering the same concepts and terminology in their work environment. If you ever decide to switch languages, or use any other for that fact, you'll have a significant chance that you'll be working with object-oriented programming.[1]  It's Free \nPython is both free and open-source. The Python Software Foundation distributes pre-made binaries that are freely available for use on all major operating systems called CPython. You can get CPython's source-code, too. Plus, you can modify the source code and distribute as allowed by CPython's license. [2] (Luckily, CPython has a permissive free software license attitude.)  Cross-platform \nPython runs on all major operating systems like Microsoft Windows, Linux, and Mac OS X.  Widely Supported \nPython has an active support community with many web sites, mailing lists, and USENET \"netnews\" groups that attract a large number of knowledgeable and helpful contributes.  It's Safe \nPython doesn't have pointers like other C-based languages, making it much more reliable. Along with that, errors never pass silently unless they're explicitly silenced. This allows you to see and read why the program crashed and where to correct your error.  Batteries Included \nPython is famous for being the \"batteries are included\" language.[3] There are over 300 standard library modules which contain modules and classes for a wide variety of programming tasks.[citation needed] For example the standard library contains modules for safely creating temporary files (named or anonymous), mapping files into memory (including use of shared and anonymous memory mappings), spawning and controlling sub-processes, compressing and decompressing files (compatible with gzip or PK-zip) and archives files (such as Unix/Linux \"tar\"), accessing indexed \"DBM\" (database) files, interfacing to various graphical user interfaces (such as the TK toolkit and the popular WxWindows multi-platform windowing system), parsing and maintaining CSV (comma-separated values) and \".cfg\" or \".ini\" configuration files (similar in syntax to the venerable WIN.INI files from MS-DOS and MS-Windows), for sending e-mail, fetching and parsing web pages, etc. It's possible, for example, to create a custom web server in Python using less than a dozen lines of code, and one of the standard libraries, of course.  Extensible \nIn addition to the standard libraries there are extensive collections of freely available add-on modules, libraries, frameworks, and tool-kits. These generally conform to similar standards and conventions; for example almost all of the database adapters (to talk to almost any client-server RDBMS engine such as MySQL, Postgres, Oracle, etc) conform to the Python DBAPI and thus can mostly be accessed using the same code. So it's usually easy to modify a Python program to support any database engine.    Source:     https://en.wikiversity.org/wiki/Python_Concepts/Why_learn_Python",
            "title": "Adventages again"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#who-uses-python-today",
            "text": "Here are links to just a few of the organizations that use python: \n-   https://wiki.python.org/moin/OrganizationsUsingPython  Python Success Stories : \n-   https://www.python.org/about/success",
            "title": "Who Uses Python Today ?"
        },
        {
            "location": "/beginner/Python_Installation/",
            "text": "Python Download and Installation Instructions\n\n\nInstall Python on Windows\n\n\n\n\nInstall Python on Ubuntu\n\n\n\n\nInstall Python on Mac",
            "title": "Python Installation"
        },
        {
            "location": "/beginner/Python_Installation/#python-download-and-installation-instructions",
            "text": "",
            "title": "Python Download and Installation Instructions"
        },
        {
            "location": "/beginner/Python_Installation/#install-python-on-windows",
            "text": "",
            "title": "Install Python on Windows"
        },
        {
            "location": "/beginner/Python_Installation/#install-python-on-ubuntu",
            "text": "",
            "title": "Install Python on Ubuntu"
        },
        {
            "location": "/beginner/Python_Installation/#install-python-on-mac",
            "text": "",
            "title": "Install Python on Mac"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/",
            "text": "What Is a Program?\n\n\nA program is a sequence of instructions that specifies how to perform a computation.\nThe computation might be something mathematical, such as solving a system of equat\nions or finding the roots of a polynomial, but it can also be a symbolic computation,\nsuch as searching and replacing text in a document or (strangely enough) compiling a\nprogram.\nThe details look different in different languages, but a few basic instructions appear in\njust about every language:\n\n\ninput: \n\n\n\n\nGet data from the keyboard, a file, or some other device.\n\n\n\n\noutput:\n\n\n\n\nDisplay data on the screen or send data to a file or other device.\n\n\n\n\nmath:\n\n\n\n\nPerform basic mathematical operations like addition and\n   multiplication.\n\n\n\n\nconditional execution:\n\n\n\n\nCheck for certain conditions and execute the appropriate code.\n\n\n\n\nrepetition:\n\n\n\n\nPerform some action repeatedly, usually with some variation.\n\n\n\n\nBelieve it or not, that\u2019s pretty much all there is to it. Every program you\u2019ve ever used, no\nmatter how complicated, is made up of instructions that look pretty much like these. So\nyou can think of programming as the process of breaking a large, complex task into\nsmaller and smaller subtasks until the subtasks are simple enough to be performed with\none of these basic instructions.\nThat may be a little vague, but we will come back to this topic when we talk about\nalgorithms.\n\n\n\n\nSource:\n \n\n\n  \nThink Python\n by Allen B. Downey  - 2012\n\n\n\n\nRun Python Scripts\n\n\nIf you can't execute or run a Python script, then programming is pointless. When you run a Python script, the interpreter converts a Python program into something that that the computer can understand. Executing a Python program can be done in two ways: calling the Python interpreter with a shebang line, and using the interactive Python shell.\n\n\nRun a Python Script as a File\n\n\nGenerally programmers write stand alone scripts, that are independent to live environments. Then they save it with a \".py\" extension, which indicates to the operating system and programmer that the file is actually a Python program. After the interpreter is invoked, it reads and interprets the file. The way Python scripts are run on Windows versus Unix based operating systems is very different. We'll show you the difference, and how to run a Python script on Windows and Unix platforms.\n\n\nRun a Python script under Windows with the Command Prompt\n\n\nWindows users must pass the path of the program as an argument to the Python interpreter. Such as follows:\n\n\nC:\n\\P\nython27\n\\p\nython.exe C:\n\\U\nsers\n\\U\nsername\n\\D\nesktop\n\\m\ny_python_script.py\n\n\n\n\n\nNote that you must use the full path of the Python interpreter. If you want to simply type python.exe C:\\Users\\Username\\Desktop\\my_python_script.py you must add python.exe to your PATH environmental variable.\nNote that Windows comes with two Python executables - python.exe and pythonw.exe. If you want a terminal to pop-up when you run your script, use python.exe However if you don't want any terminal pop-up, use pythonw.exe. pythonw.exe is typically used for GUI programs, where you only want to display your program, not the terminal.\n\n\nRun a Python Script Under Mac, Linux, BSD, Unix, etc\n\n\nOn platforms like Mac, BSD or Linux (Unix) you can put a \"shebang\" line as first line of the program which indicates the location of the Python interpreter on the hard drive. It's in the following format:\n\n\n#!/path/to/interpreter\n\n\n\n\n\n\nA common shebang line used for the Python interpreter is as follows:\n\n\n#!/usr/bin/env python\n\n\n\n\n\n\nYou must then make the script executable, using the following command:\n\n\nchmod +x my_python_script.py\n\n\n\n\n\nUnlike Windows, the Python interpreter is typically already in the $PATH environmental variable, so adding it is un-necessary.\n\n\nYou can then run a program by invoking the Python interpreter manually as follows:\n\n\npython firstprogram.py\n\n\n\n\n\nPython Execution with the Shell (Live Interpreter)\n\n\nAssuming that you already have Python installed and running well (if you're getting an error, see this post), open the terminal or console and type 'python' and hit the 'Enter' key. You will then be directed immediately to the Python live interpreter. Your screen will display a message something like:\n\n\nuser@hostname:~ python\nPython \n3\n.3.0 \n(\ndefault, Nov \n23\n \n2012\n, \n10\n:26:01\n)\n \n\n[\nGCC \n4\n.2.1 Compatible Apple Clang \n4\n.1 \n((\ntags/Apple/clang-421.11.66\n))]\n on darwin\nType \n\"help\"\n, \n\"copyright\"\n, \n\"credits\"\n or \n\"license\"\n \nfor\n more information.\n>>>\n\n\n\n\n\nThe Python programmer should keep in mind one thing: that while working with the live interpreter, everything is read and interpreted in real-time. For example loops iterate immediately, unless they are part of function. So it requires some mental planning. Using the Python shell is typically used to execute code interactively. If you want to run a Python script from the interpreter, you must either import it or call the Python executable.\n\n\n\n\nSource:\n \n\n\n  http://pythoncentral.io/execute-python-script-file-shell/\n\n\n\n\nA Good First Program\n\n\nType the following text into a single file named \nex1.py\n. Python works best with files ending in \n.py\n.\n\n\nprint\n \n\"Hello World!\"\n\n\nprint\n \n\"Hello Again\"\n\n\nprint\n \n\"I like typing this.\"\n\n\nprint\n \n\"This is fun.\"\n\n\nprint\n \n'Yay! Printing.'\n\n\nprint\n \n\"I'd much rather you 'not'.\"\n\n\nprint\n \n'I \"said\" do not touch this.'\n\n\n\n\n\n\nYour Atom text editor should look something like this on all platforms:\n\n\n\n\nDon't worry if your editor doesn't look exactly the same, it should be close though. You may have a slightly different window header, maybe slightly different colors, and the left side of your Atom window won't say \"zedshaw\" but will instead show the directory you used for saving your files. All of those differences are fine.\n\n\nWhen you create this file, keep in mind these points:\n\n\n\n\nI did not type the line numbers on the left. Those are printed in the book so I can talk about specific lines by saying, \"See line 5...\" You do not type line numbers into Python scripts.\n\n\nI have the print at the beginning of the line and it looks exactly the same as what I have in ex1.py. Exactly means exactly, not kind of sort of the same. Every single character has to match for it to work. Color doesn't matter, only the characters you type.\n\n\n\n\nIn Terminal run the file by typing:\n\n\npython ex1.py\n\n\n\n\n\nIf you did it right then you should see the same output as I in the What You Should See section of this exercise. If not, you have done something wrong. No, the computer is not wrong.\n\n\nWhat You Should See\n\n\nOn Mac OS X in the Terminal you should see this:\n\n\nOn Windows in PowerShell you should see this:\n\n\n\nYou may see different names, before the python ex1.py command, but the important part is that you type the command and see the output is the same as mine.\n\n\n\n\n\nIf you have an error it will look like this:\n\n\n$ python ex/ex1.py\n  File \n\"ex/ex1.py\"\n, line \n3\n\n    print \n\"I like typing this.\n\n\n                             ^\n\n\nSyntaxError: EOL while scanning string literal\n\n\n\n\n\n\nIt's important that you can read these error messages because you will be making many of these mistakes. Even I make many of these mistakes. Let's look at this line by line.\n\n\n\n\nWe ran our command in the Terminal to run the ex1.py script.\n\n\nPython tells us that the file ex1.py has an error on line 3.\n\n\nIt prints this line of code for us to see it.\n\n\nThen it puts a ^ (caret) character to point at where the problem is. Notice the missing \" (double-quote) character?\n\n\nFinally, it prints out a \"SyntaxError\" and tells us something about what might be the error. Usually these are very cryptic, but if you copy that text into a search engine, you will find someone else who's had that error and you can probably figure out how to fix it.\n\n\n\n\n\n\nSource:\n \n\n\n  \nLEARN PYTHON THE HARD WAY\n by Zed A. Shaw  - 2013\n\n\n\n\nDebugging and Errors\n\n\nWhat Is Debugging?\n\n\nProgramming is error-prone. For whimsical reasons, programming errors are called\n\nbugs\n and the process of tracking them down is called \ndebugging\n.\nThree kinds of errors can occur in a program: syntax errors, runtime errors, and se\nmantic errors. It is useful to distinguish between them in order to track them down more\nquickly.\n\n\nError Types :\n\n\nSyntax Errors\n\n\nPython can only execute a program if the syntax is correct; otherwise, the interpreter\ndisplays an error message. Syntax refers to the structure of a program and the rules\nabout that structure.For example, parentheses have to come in matching pairs, so\n(1 + 2) is legal, but 8) is a \nsyntax error\n.\nIn English readers can tolerate most syntax errors, which is why we can read the poetry\nof e. e. cummings without spewing error messages. Python is not so forgiving. If there\nis a single syntax error anywhere in your program, Python will display an error message\nand quit, and you will not be able to run your program. During the first few weeks of\nyour programming career, you will probably spend a lot of time tracking down syntax\nerrors. As you gain experience, you will make fewer errors and find them faster.\n\n\nRuntime Errors\n\n\nThe second type of error is a runtime error, so called because the error does not appear\nuntil after the program has started running. These errors are also called exceptions\nbecause they usually indicate that something exceptional (and bad) has happened.\nRuntime errors are rare in the simple programs you will see in the first few chapters, so\nit might be a while before you encounter one.\n\n\nSemantic Errors\n\n\nThe third type of error is the semantic error. If there is a semantic error in your program,\nit will run successfully in the sense that the computer will not generate any error mess\nages, but it will not do the right thing. It will do something else. Specifically, it will do\nwhat you told it to do.\nThe problem is that the program you wrote is not the program you wanted to write. The\nmeaning of the program (its semantics) is wrong. Identifying semantic errors can be\ntricky because it requires you to work backward by looking at the output of the program\nand trying to figure out what it is doing.\n\n\n\n\nSource:\n \n\n\n  \nThink Python\n by Allen B. Downey  - 2012\n\n\n\n\nReserved Words\n\n\nThe following list shows the Python keywords. These are reserved words and you cannot use them as constants or variables or any other identifier names. All the Python keywords contain lowercase letters only.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand\n\n\nexec\n\n\nnot\n\n\n\n\n\n\nas\n\n\nfinally\n\n\nor\n\n\n\n\n\n\nassert\n\n\nfor\n\n\npass\n\n\n\n\n\n\nbreak\n\n\nfrom\n\n\nprint\n\n\n\n\n\n\nclass\n\n\nglobal\n\n\nraise\n\n\n\n\n\n\ncontinue\n\n\nif\n\n\nreturn\n\n\n\n\n\n\ndef\n\n\nimport\n\n\ntry\n\n\n\n\n\n\ndel\n\n\nin\n\n\nwhile\n\n\n\n\n\n\nelif\n\n\nis\n\n\nwith\n\n\n\n\n\n\nelse\n\n\nlambda\n\n\nyield\n\n\n\n\n\n\nexcept\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource:\n \n\n\n https://www.tutorialspoint.com",
            "title": "Start Coding With Python"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#what-is-a-program",
            "text": "A program is a sequence of instructions that specifies how to perform a computation.\nThe computation might be something mathematical, such as solving a system of equat\nions or finding the roots of a polynomial, but it can also be a symbolic computation,\nsuch as searching and replacing text in a document or (strangely enough) compiling a\nprogram.\nThe details look different in different languages, but a few basic instructions appear in\njust about every language:  input:    Get data from the keyboard, a file, or some other device.   output:   Display data on the screen or send data to a file or other device.   math:   Perform basic mathematical operations like addition and\n   multiplication.   conditional execution:   Check for certain conditions and execute the appropriate code.   repetition:   Perform some action repeatedly, usually with some variation.   Believe it or not, that\u2019s pretty much all there is to it. Every program you\u2019ve ever used, no\nmatter how complicated, is made up of instructions that look pretty much like these. So\nyou can think of programming as the process of breaking a large, complex task into\nsmaller and smaller subtasks until the subtasks are simple enough to be performed with\none of these basic instructions.\nThat may be a little vague, but we will come back to this topic when we talk about\nalgorithms.   Source:       Think Python  by Allen B. Downey  - 2012",
            "title": "What Is a Program?"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#run-python-scripts",
            "text": "If you can't execute or run a Python script, then programming is pointless. When you run a Python script, the interpreter converts a Python program into something that that the computer can understand. Executing a Python program can be done in two ways: calling the Python interpreter with a shebang line, and using the interactive Python shell.",
            "title": "Run Python Scripts"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#run-a-python-script-as-a-file",
            "text": "Generally programmers write stand alone scripts, that are independent to live environments. Then they save it with a \".py\" extension, which indicates to the operating system and programmer that the file is actually a Python program. After the interpreter is invoked, it reads and interprets the file. The way Python scripts are run on Windows versus Unix based operating systems is very different. We'll show you the difference, and how to run a Python script on Windows and Unix platforms.",
            "title": "Run a Python Script as a File"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#run-a-python-script-under-windows-with-the-command-prompt",
            "text": "Windows users must pass the path of the program as an argument to the Python interpreter. Such as follows:  C: \\P ython27 \\p ython.exe C: \\U sers \\U sername \\D esktop \\m y_python_script.py  Note that you must use the full path of the Python interpreter. If you want to simply type python.exe C:\\Users\\Username\\Desktop\\my_python_script.py you must add python.exe to your PATH environmental variable.\nNote that Windows comes with two Python executables - python.exe and pythonw.exe. If you want a terminal to pop-up when you run your script, use python.exe However if you don't want any terminal pop-up, use pythonw.exe. pythonw.exe is typically used for GUI programs, where you only want to display your program, not the terminal.",
            "title": "Run a Python script under Windows with the Command Prompt"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#run-a-python-script-under-mac-linux-bsd-unix-etc",
            "text": "On platforms like Mac, BSD or Linux (Unix) you can put a \"shebang\" line as first line of the program which indicates the location of the Python interpreter on the hard drive. It's in the following format:  #!/path/to/interpreter   A common shebang line used for the Python interpreter is as follows:  #!/usr/bin/env python   You must then make the script executable, using the following command:  chmod +x my_python_script.py  Unlike Windows, the Python interpreter is typically already in the $PATH environmental variable, so adding it is un-necessary.  You can then run a program by invoking the Python interpreter manually as follows:  python firstprogram.py",
            "title": "Run a Python Script Under Mac, Linux, BSD, Unix, etc"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#python-execution-with-the-shell-live-interpreter",
            "text": "Assuming that you already have Python installed and running well (if you're getting an error, see this post), open the terminal or console and type 'python' and hit the 'Enter' key. You will then be directed immediately to the Python live interpreter. Your screen will display a message something like:  user@hostname:~ python\nPython  3 .3.0  ( default, Nov  23   2012 ,  10 :26:01 )   [ GCC  4 .2.1 Compatible Apple Clang  4 .1  (( tags/Apple/clang-421.11.66 ))]  on darwin\nType  \"help\" ,  \"copyright\" ,  \"credits\"  or  \"license\"   for  more information.\n>>>  The Python programmer should keep in mind one thing: that while working with the live interpreter, everything is read and interpreted in real-time. For example loops iterate immediately, unless they are part of function. So it requires some mental planning. Using the Python shell is typically used to execute code interactively. If you want to run a Python script from the interpreter, you must either import it or call the Python executable.   Source:      http://pythoncentral.io/execute-python-script-file-shell/",
            "title": "Python Execution with the Shell (Live Interpreter)"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#a-good-first-program",
            "text": "Type the following text into a single file named  ex1.py . Python works best with files ending in  .py .  print   \"Hello World!\"  print   \"Hello Again\"  print   \"I like typing this.\"  print   \"This is fun.\"  print   'Yay! Printing.'  print   \"I'd much rather you 'not'.\"  print   'I \"said\" do not touch this.'   Your Atom text editor should look something like this on all platforms:   Don't worry if your editor doesn't look exactly the same, it should be close though. You may have a slightly different window header, maybe slightly different colors, and the left side of your Atom window won't say \"zedshaw\" but will instead show the directory you used for saving your files. All of those differences are fine.  When you create this file, keep in mind these points:   I did not type the line numbers on the left. Those are printed in the book so I can talk about specific lines by saying, \"See line 5...\" You do not type line numbers into Python scripts.  I have the print at the beginning of the line and it looks exactly the same as what I have in ex1.py. Exactly means exactly, not kind of sort of the same. Every single character has to match for it to work. Color doesn't matter, only the characters you type.   In Terminal run the file by typing:  python ex1.py  If you did it right then you should see the same output as I in the What You Should See section of this exercise. If not, you have done something wrong. No, the computer is not wrong.",
            "title": "A Good First Program"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#what-you-should-see",
            "text": "On Mac OS X in the Terminal you should see this: \nOn Windows in PowerShell you should see this:  You may see different names, before the python ex1.py command, but the important part is that you type the command and see the output is the same as mine.   If you have an error it will look like this:  $ python ex/ex1.py\n  File  \"ex/ex1.py\" , line  3 \n    print  \"I like typing this.                               ^  SyntaxError: EOL while scanning string literal   It's important that you can read these error messages because you will be making many of these mistakes. Even I make many of these mistakes. Let's look at this line by line.   We ran our command in the Terminal to run the ex1.py script.  Python tells us that the file ex1.py has an error on line 3.  It prints this line of code for us to see it.  Then it puts a ^ (caret) character to point at where the problem is. Notice the missing \" (double-quote) character?  Finally, it prints out a \"SyntaxError\" and tells us something about what might be the error. Usually these are very cryptic, but if you copy that text into a search engine, you will find someone else who's had that error and you can probably figure out how to fix it.    Source:       LEARN PYTHON THE HARD WAY  by Zed A. Shaw  - 2013",
            "title": "What You Should See"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#debugging-and-errors",
            "text": "",
            "title": "Debugging and Errors"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#what-is-debugging",
            "text": "Programming is error-prone. For whimsical reasons, programming errors are called bugs  and the process of tracking them down is called  debugging .\nThree kinds of errors can occur in a program: syntax errors, runtime errors, and se\nmantic errors. It is useful to distinguish between them in order to track them down more\nquickly.",
            "title": "What Is Debugging?"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#error-types",
            "text": "",
            "title": "Error Types :"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#syntax-errors",
            "text": "Python can only execute a program if the syntax is correct; otherwise, the interpreter\ndisplays an error message. Syntax refers to the structure of a program and the rules\nabout that structure.For example, parentheses have to come in matching pairs, so\n(1 + 2) is legal, but 8) is a  syntax error .\nIn English readers can tolerate most syntax errors, which is why we can read the poetry\nof e. e. cummings without spewing error messages. Python is not so forgiving. If there\nis a single syntax error anywhere in your program, Python will display an error message\nand quit, and you will not be able to run your program. During the first few weeks of\nyour programming career, you will probably spend a lot of time tracking down syntax\nerrors. As you gain experience, you will make fewer errors and find them faster.",
            "title": "Syntax Errors"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#runtime-errors",
            "text": "The second type of error is a runtime error, so called because the error does not appear\nuntil after the program has started running. These errors are also called exceptions\nbecause they usually indicate that something exceptional (and bad) has happened.\nRuntime errors are rare in the simple programs you will see in the first few chapters, so\nit might be a while before you encounter one.",
            "title": "Runtime Errors"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#semantic-errors",
            "text": "The third type of error is the semantic error. If there is a semantic error in your program,\nit will run successfully in the sense that the computer will not generate any error mess\nages, but it will not do the right thing. It will do something else. Specifically, it will do\nwhat you told it to do.\nThe problem is that the program you wrote is not the program you wanted to write. The\nmeaning of the program (its semantics) is wrong. Identifying semantic errors can be\ntricky because it requires you to work backward by looking at the output of the program\nand trying to figure out what it is doing.   Source:       Think Python  by Allen B. Downey  - 2012",
            "title": "Semantic Errors"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#reserved-words",
            "text": "The following list shows the Python keywords. These are reserved words and you cannot use them as constants or variables or any other identifier names. All the Python keywords contain lowercase letters only.            and  exec  not    as  finally  or    assert  for  pass    break  from  print    class  global  raise    continue  if  return    def  import  try    del  in  while    elif  is  with    else  lambda  yield    except        Source:     https://www.tutorialspoint.com",
            "title": "Reserved Words"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/",
            "text": "Data Types in Python 3\n\n\nUnderstanding Data Types in Python 3\n\n\nIntroduction\n\n\nIn Python, like in all programming languages, data types are used to classify one particular type of data. This is important because the specific data type you use will determine what values you can assign to it and what you can do to it (including what operations you can perform on it).\n\n\nIn this tutorial, we will go over the important data types native to Python. This is not an exhaustive investigation of data types, but will help you become familiar with what options you have available to you in Python.\n\n\nBackground\n\n\nOne way to think about data types is to consider the different types of data that we use in the real world. An example of data in the real world are numbers: we may use whole numbers (0, 1, 2, \u2026), integers (\u2026, -1, 0, 1, \u2026), and irrational numbers (\u03c0), for example.\n\n\nUsually, in math, we can combine numbers from different types, and get some kind of an answer. We may want to add 5 to \u03c0, for example:\n\n\n5 + \u03c0\n\n\nWe can either keep the equation as the answer to account for the irrational number, or round \u03c0 to a number with a brief number of decimal places, and then add the numbers together:\n\n\n5 + \u03c0 = 5 + 3.14 = 8.14\n\n\nBut, if we start to try to evaluate numbers with another data type, such as words, things start to make less sense. How would we solve for the following equation?\n\n\nsky + 8\n\n\nFor computers, each data type can be thought of as being quite different, like words and numbers, so we will have to be careful about how we use them to assign values and how we manipulate them through operations.\n\n\nNumbers\n\n\nAny \nnumber\n you enter in Python will be interpreted as a number; you are not required to declare what kind of data type you are entering. Python will consider any number written without decimals as an \ninteger\n (as in \n138\n) and any number written with decimals as a \nfloat\n (as in \n138.0\n).\n\n\nIntegers\n\n\nLike in \nmath\n, \nintegers\n in computer programming are whole numbers that can be positive, negative, or 0 (\u2026, \n-1\n, \n0\n, \n1\n, \u2026). An integer can also be known as an \nint\n. As with other programming languages, you should not use commas in numbers of four digits or more, so when you write 1,000 in your program, write it as \n1000\n.\n\n\nWe can print out an integer in a simple way like this:\n\n\nprint\n(\n-\n25\n)\n\n\n\n#Output : -25\n\n\n\n\n\n\nOr, we can declare a \nvariable\n, which in this case is essentially a symbol of the number we are using or manipulating, like so:\n\n\nmy_int\n \n=\n \n-\n25\n\n\nprint\n(\nmy_int\n)\n\n\n\n#Output : -25\n\n\n\n\n\n\nWe can do math with integers in Python, too:\n\n\nint_ans\n \n=\n \n116\n \n-\n \n68\n\n\nprint\n(\nint_ans\n)\n\n\n\n#Output : 48\n\n\n\n\n\n\nIntegers can be used in many ways within Python programs, and as you continue to learn more about the language you will have a lot of opportunities to work with integers and understand more about this data type.\n\n\nFloating-Point Numbers\n\n\nA \nfloating-point number\n or a \nfloat\n is a real number, meaning that it can be either a rational or an irrational number. Because of this, floating-point numbers can be numbers that can contain a fractional part, such as \n9.0\n or \n-116.42\n. Simply speaking, for the purposes of thinking of a \nfloat\n in a Python program, it is a number that contains a decimal point.\n\n\nLike we did with the integer, we can print out a floating-point number in a simple way like this:\n\n\nprint\n(\n17.3\n)\n\n\n\n#Output : 17.3\n\n\n\n\n\n\nWe can also declare a variable that stands in for a float, like so:\n\n\nmy_flt\n \n=\n \n17.3\n\n\nprint\n(\nmy_flt\n)\n\n\n\n#Output : 17.3\n\n\n\n\n\n\nAnd, just like with integers, we can do math with floats in Python, too:\n\n\nflt_ans\n \n=\n \n564.0\n \n+\n \n365.24\n\n\nprint\n(\nflt_ans\n)\n\n\n\n#Output : 929.24\n\n\n\n\n\n\nWith integers and floating-point numbers, it is important to keep in mind that 3 \u2260 3.0, as \n3\n refers to an integer while \n3.0\n refers to a float.\n\n\nBooleans\n\n\nThe \nBoolean\n data type can be one of two values, either \nTrue\n or \nFalse\n. Booleans are used to represent the truth values that are associated with the logic branch of mathematics, which informs algorithms in computer science.\n\n\nWhenever you see the data type Boolean, it will start with a capitalized B because it is named for the mathematician George Boole. The values \nTrue\n and \nFalse\n will also always be with a capital T and F respectively, as they are special values in Python.\n\n\nMany operations in math give us answers that evaluate to either True or False:\n\n\n*\n   \n**\ngreater\n \nthan\n**\n\n    \n*\n   \n500\n \n>\n \n100\n \n`True`\n\n    \n*\n   \n1\n \n>\n \n5\n \n`False`\n\n\n*\n   \n**\nless\n \nthan\n**\n\n    \n*\n   \n200\n \n<\n \n400\n \n`True`\n\n    \n*\n   \n4\n \n<\n \n2\n \n`False`\n\n\n*\n   \n**\nequal\n**\n\n    \n*\n   \n5\n \n=\n \n5\n \n`True`\n\n    \n*\n   \n500\n \n=\n \n400\n \n`False`\n\n\n\n\n\n\nLike with numbers, we can store a Boolean value in a variable:\n\n\nmy_bool\n \n=\n \n5\n \n>\n \n8\n\n\n\n\n\n\nWe can then print the Boolean value with a call to the \nprint()\n function:\n\n\nprint\n(\nmy_bool\n)\n\n\n\n\n\n\nSince 5 is not greater than 8, we will receive the following #Output : :\n\n\n#Output : False\n\n\n\n\n\n\nAs you write more programs in Python, you will become more familiar with how Booleans work and how different functions and operations evaluating to either True or False can change the course of the program.\n\n\nStrings\n\n\nA \nstring\n is a sequence of one or more characters (letters, numbers, symbols) that can be either a constant or a variable. Strings exist within either single quotes \n'\n or double quotes \n\"\n in Python, so to create a string, enclose a sequence of characters in quotes:\n\n\n'This is a string in single quotes.'\n\n\"This is a string in double quotes.\"\n\n\n\n\n\nYou can choose to use either single quotes or double quotes, but whichever you decide on you should be consistent within a program.\n\n\nThe simple program \u201c\nHello, World!\n\u201d demonstrates how a string can be used in computer programming, as the characters that make up the phrase \nHello, World!\n are a string.\n\n\nprint\n(\n\"Hello, World!\"\n)\n\n\n\n\n\n\nAs with other data types, we can store strings in variables:\n\n\nhw\n \n=\n \n\"Hello, World!\"\n\n\n\n\n\n\nAnd print out the string by calling the variable:\n\n\nprint\n(\nhw\n)\n\n\n\n#Ouput : Hello, World!\n\n\n\n\n\n\nLike numbers, there are many operations that we can perform on strings within our programs in order to manipulate them to achieve the results we are seeking. Strings are important for communicating information to the user, and for the user to communicate information back to the program.\n\n\nLists\n\n\nA \nlist\n is a mutable, or changeable, ordered sequence of elements. Each element or value that is inside of a list is called an \nitem\n. Just as strings are defined as characters between quotes, lists are defined by having values between square brackets \n[ ]\n.\n\n\nA list of integers looks like this:\n\n\n[\n-\n3\n,\n \n-\n2\n,\n \n-\n1\n,\n \n0\n,\n \n1\n,\n \n2\n,\n \n3\n]\n\n\n\n\n\n\nA list of floats looks like this:\n\n\n[\n3.14\n,\n \n9.23\n,\n \n111.11\n,\n \n312.12\n,\n \n1.05\n]\n\n\n\n\n\n\nA list of strings:\n\n\n[\n'shark'\n,\n \n'cuttlefish'\n,\n \n'squid'\n,\n \n'mantis shrimp'\n]\n\n\n\n\n\n\nIf we define our string list as \nsea_creatures\n:\n\n\nsea_creatures\n \n=\n \n[\n'shark'\n,\n \n'cuttlefish'\n,\n \n'squid'\n,\n \n'mantis shrimp'\n]\n\n\n\n\n\n\nWe can print them out by calling the variable:\n\n\nprint\n(\nsea_creatures\n)\n\n\n\n\n\n\nAnd we see that the #Output :  looks exactly like the list that we created:\n\n\n#Output : ['shark', 'cuttlefish', 'squid', 'mantis shrimp']\n\n\n\n\n\n\nLists are a very flexible data type because they are mutable in that they can have values added, removed, and changed. There is a data type that is similar to lists but that can\u2019t be changed, and that is called a tuple.\n\n\nTuples\n\n\nA \ntuple\n is used for grouping data. It is an immutable, or unchangeable, ordered sequence of elements.\n\n\nTuples are very similar to lists, but they use parentheses \n( )\n instead of square brackets and because they are immutable their values cannot be modified.\n\n\nA tuple looks like this:\n\n\n(\n'blue coral'\n,\n \n'staghorn coral'\n,\n \n'pillar coral'\n)\n\n\n\n\n\n\nWe can store a tuple in a variable and print it out:\n\n\ncoral\n \n=\n \n(\n'blue coral'\n,\n \n'staghorn coral'\n,\n \n'pillar coral'\n)\n\n\nprint\n(\ncoral\n)\n\n\n\nOuput\n(\n'blue coral'\n,\n \n'staghorn coral'\n,\n \n'pillar coral'\n)\n\n\n\n\n\n\nLike in the other data types, Python prints out the tuple just as we had typed it, with parentheses containing a sequence of values.\n\n\nDictionaries\n\n\nThe \ndictionary\n is Python\u2019s built-in \nmapping\n type. This means that dictionaries map \nkeys\n to \nvalues\n and these key-value pairs are a useful way to store data in Python. A dictionary is constructed with curly braces on either side \n{ }\n.\n\n\nTypically used to hold data that are related, such as the information contained in an ID, a dictionary looks like this:\n\n\n{\n'name'\n:\n \n'Sammy'\n,\n \n'animal'\n:\n \n'shark'\n,\n \n'color'\n:\n \n'blue'\n,\n \n'location'\n:\n \n'ocean'\n}\n\n\n\n\n\n\nYou will notice that in addition to the curly braces, there are also colons throughout the dictionary. The words to the left of the colons are the keys. Keys can be made up of any immutable data type. The keys in the dictionary above are: \n'name', 'animal', 'color', 'location'\n.\n\n\nThe words to the right of the colons are the values. Values can be comprised of any data type. The values in the dictionary above are: \n'Sammy', 'shark', 'blue', 'ocean'\n.\n\n\nLike the other data types, let\u2019s store the dictionary inside a variable, and print it out:\n\n\nsammy\n \n=\n \n{\n'name'\n:\n \n'Sammy'\n,\n \n'animal'\n:\n \n'shark'\n,\n \n'color'\n:\n \n'blue'\n,\n  \n'location'\n:\n \n'ocean'\n}\n\n\n#Ouput : {'color': 'blue', 'animal': 'shark', 'name': 'Sammy', 'location': 'ocean'}\n\n\n\n\n\n\nIf we want to isolate Sammy\u2019s color, we can do so by calling \nsammy['color']\n. Let\u2019s print that out:\n\n\nprint\n(\nsammy\n[\n'color'\n])\n\n\n\n#Output : blue\n\n\n\n\n\n\nAs dictionaries offer key-value pairs for storing data, they can be important elements in your Python program.\n\n\nConclusion\n\n\nAt this point, you should have a better understanding of some of the major data types that are available for you to use in Python. Each of these data types will become important as you develop programming projects in the Python language.\n\n\nYou can learn about each of the data types above in more detail by reading the following specific tutorials:\n\n\n\n\nNumbers\n\n\nBooleans\n\n\nStrings\n\n\nLists\n\n\nTuples\n\n\nDictionaries\n\n\n\n\nOnce you have a solid grasp of data types available to you in Python, you can learn how to \nconvert data types\n.\n\n\n\n\nSource:\n \n\n\n https://www.digitalocean.com/community/tutorials/understanding-data-types-in-python-3\n\n\n\n\n\n\nNative Datatypes By Dive Into Python 3\n\n\n\n\n\n\nSource:\n \n\n\n \nDive into Python 3\n by Mark Pilgrim    \n\n\n\n\nStandard Data Types By Tutorialspoint\n\n\nThe data stored in memory can be of many types. For example, a person's age is stored as a numeric value and his or her address is stored as alphanumeric characters. Python has various standard data types that are used to define the operations possible on them and the storage method for each of them.\n\n\nPython has five standard data types :   \n\n\n\n\n\n\nNumbers\n\n\n\n\n\n\nString\n\n\n\n\n\n\nList\n\n\n\n\n\n\nTuple\n\n\n\n\n\n\nDictionary\n\n\n\n\n\n\nPython Numbers\n\n\nNumber data types store numeric values. Number objects are created when you assign a value to them. For example \u2212\n\n\nvar1\n \n=\n \n1\n\n\nvar2\n \n=\n \n10\n\n\n\n\n\n\nYou can also delete the reference to a number object by using the del statement. The syntax of the del statement is \u2212\n\n\ndel\n \nvar1\n[,\nvar2\n[,\nvar3\n[\n....\n,\nvarN\n]]]]\n\n\n\n\n\n\nYou can delete a single object or multiple objects by using the del statement.\n\n\nFor example \u2212\n\n\ndel\n \nvar\n\n\ndel\n \nvar_a\n,\n \nvar_b\n\n\n\n\n\n\nPython supports three different numerical types \u2212\n- int (signed integers)\n\n\n\n\n\n\nfloat (floating point real values)\n\n\n\n\n\n\ncomplex (complex numbers)\n\n\n\n\n\n\nAll integers in Python3 are represented as long integers. Hence, there is no separate number type as long.\n\n\n\n\n\n\n\n\nint\n\n\nfloat\n\n\ncomplex\n\n\n\n\n\n\n\n\n\n\n10\n\n\n0.0\n\n\n3.14j\n\n\n\n\n\n\n100\n\n\n15.20\n\n\n45.j\n\n\n\n\n\n\n-786\n\n\n-21.9\n\n\n9.322e-36j\n\n\n\n\n\n\n\n\nA complex number consists of an ordered pair of real floating-point numbers denoted by x + yj, where x and y are real numbers and j is the imaginary unit.\n\n\nPython Strings\n\n\nStrings in Python are identified as a contiguous set of characters represented in the quotation marks. Python allows either pair of single or double quotes. Subsets of strings can be taken using the slice operator ([ ] and [:] ) with indexes starting at 0 in the beginning of the string and working their way from -1 to the end.\n\n\nThe plus (+) sign is the string concatenation operator and the asterisk (*) is the repetition operator. For example \u2212\n\n\n#!/usr/bin/python3\n\n\n\nstr\n \n=\n \n'Hello World!'\n\n\n\nprint\n \n(\nstr\n)\n          \n# Prints complete string\n\n\nprint\n \n(\nstr\n[\n0\n])\n       \n# Prints first character of the string\n\n\nprint\n \n(\nstr\n[\n2\n:\n5\n])\n     \n# Prints characters starting from 3rd to 5th\n\n\nprint\n \n(\nstr\n[\n2\n:])\n      \n# Prints string starting from 3rd character\n\n\nprint\n \n(\nstr\n \n*\n \n2\n)\n      \n# Prints string two times\n\n\nprint\n \n(\nstr\n \n+\n \n\"TEST\"\n)\n \n# Prints concatenated string\n\n\n\n\n\n\nThis will produce the following result \u2212\n\n\nHello\n \nWorld\n!\n\n\nH\n\n\nllo\n\n\nllo\n \nWorld\n!\n\n\nHello\n \nWorld\n!\nHello\n \nWorld\n!\n\n\nHello\n \nWorld\n!\nTEST\n\n\n\n\n\n\nPython Lists\n\n\nLists are the most versatile of Python's compound data types. A list contains items separated by commas and enclosed within square brackets ([]). To some extent, lists are similar to arrays in C. One of the differences between them is that all the items belonging to a list can be of different data type.\n\n\nThe values stored in a list can be accessed using the slice operator ([ ] and [:]) with indexes starting at 0 in the beginning of the list and working their way to end -1. The plus (+) sign is the list concatenation operator, and the asterisk (*) is the repetition operator. For example \u2212\n\n\n#!/usr/bin/python3\n\n\n\nlist\n \n=\n \n[\n \n'abcd'\n,\n \n786\n \n,\n \n2.23\n,\n \n'john'\n,\n \n70.2\n \n]\n\n\ntinylist\n \n=\n \n[\n123\n,\n \n'john'\n]\n\n\n\nprint\n \n(\nlist\n)\n          \n# Prints complete list\n\n\nprint\n \n(\nlist\n[\n0\n])\n       \n# Prints first element of the list\n\n\nprint\n \n(\nlist\n[\n1\n:\n3\n])\n     \n# Prints elements starting from 2nd till 3rd \n\n\nprint\n \n(\nlist\n[\n2\n:])\n      \n# Prints elements starting from 3rd element\n\n\nprint\n \n(\ntinylist\n \n*\n \n2\n)\n  \n# Prints list two times\n\n\nprint\n \n(\nlist\n \n+\n \ntinylist\n)\n \n# Prints concatenated lists\n\n\n\n\n\n\nThis produces the following result \u2212\n\n\n[\n'abcd'\n,\n \n786\n,\n \n2.23\n,\n \n'john'\n,\n \n70.200000000000003\n]\n\n\nabcd\n\n\n[\n786\n,\n \n2.23\n]\n\n\n[\n2.23\n,\n \n'john'\n,\n \n70.200000000000003\n]\n\n\n[\n123\n,\n \n'john'\n,\n \n123\n,\n \n'john'\n]\n\n\n[\n'abcd'\n,\n \n786\n,\n \n2.23\n,\n \n'john'\n,\n \n70.200000000000003\n,\n \n123\n,\n \n'john'\n]\n\n\n\n\n\n\nPython Tuples\n\n\nA tuple is another sequence data type that is similar to the list. A tuple consists of a number of values separated by commas. Unlike lists, however, tuples are enclosed within parenthesis.\n\n\nThe main difference between lists and tuples are \u2212 Lists are enclosed in brackets ( [ ] ) and their elements and size can be changed, while tuples are enclosed in parentheses ( ( ) ) and cannot be updated. Tuples can be thought of as read-only lists. For example \u2212\n\n\n#!/usr/bin/python3\n\n\n\ntuple\n \n=\n \n(\n \n'abcd'\n,\n \n786\n \n,\n \n2.23\n,\n \n'john'\n,\n \n70.2\n  \n)\n\n\ntinytuple\n \n=\n \n(\n123\n,\n \n'john'\n)\n\n\n\nprint\n \n(\ntuple\n)\n           \n# Prints complete tuple\n\n\nprint\n \n(\ntuple\n[\n0\n])\n        \n# Prints first element of the tuple\n\n\nprint\n \n(\ntuple\n[\n1\n:\n3\n])\n      \n# Prints elements starting from 2nd till 3rd \n\n\nprint\n \n(\ntuple\n[\n2\n:])\n       \n# Prints elements starting from 3rd element\n\n\nprint\n \n(\ntinytuple\n \n*\n \n2\n)\n   \n# Prints tuple two times\n\n\nprint\n \n(\ntuple\n \n+\n \ntinytuple\n)\n \n# Prints concatenated tuple\n\n\n\n\n\n\nThis produces the following result \u2212\n\n\n(\n'abcd'\n,\n \n786\n,\n \n2.23\n,\n \n'john'\n,\n \n70.200000000000003\n)\n\n\nabcd\n\n\n(\n786\n,\n \n2.23\n)\n\n\n(\n2.23\n,\n \n'john'\n,\n \n70.200000000000003\n)\n\n\n(\n123\n,\n \n'john'\n,\n \n123\n,\n \n'john'\n)\n\n\n(\n'abcd'\n,\n \n786\n,\n \n2.23\n,\n \n'john'\n,\n \n70.200000000000003\n,\n \n123\n,\n \n'john'\n)\n\n\n\n\n\n\nThe following code is invalid with tuple, because we attempted to update a tuple, which is not allowed. Similar case is possible with lists \u2212\n\n\n#!/usr/bin/python3\n\n\n\ntuple\n \n=\n \n(\n \n'abcd'\n,\n \n786\n \n,\n \n2.23\n,\n \n'john'\n,\n \n70.2\n  \n)\n\n\nlist\n \n=\n \n[\n \n'abcd'\n,\n \n786\n \n,\n \n2.23\n,\n \n'john'\n,\n \n70.2\n  \n]\n\n\ntuple\n[\n2\n]\n \n=\n \n1000\n    \n# Invalid syntax with tuple\n\n\nlist\n[\n2\n]\n \n=\n \n1000\n     \n# Valid syntax with list\n\n\n\n\n\n\nPython Dictionary\n\n\nPython's dictionaries are kind of hash-table type. They work like associative arrays or hashes found in Perl and consist of key-value pairs. A dictionary key can be almost any Python type, but are usually numbers or strings. Values, on the other hand, can be any arbitrary Python object.\n\n\nDictionaries are enclosed by curly braces ({ }) and values can be assigned and accessed using square braces ([]). For example \u2212\n\n\n#!/usr/bin/python3\n\n\n\ndict\n \n=\n \n{}\n\n\ndict\n[\n'one'\n]\n \n=\n \n\"This is one\"\n\n\ndict\n[\n2\n]\n     \n=\n \n\"This is two\"\n\n\n\ntinydict\n \n=\n \n{\n'name'\n:\n \n'john'\n,\n'code'\n:\n6734\n,\n \n'dept'\n:\n \n'sales'\n}\n\n\n\n\nprint\n \n(\ndict\n[\n'one'\n])\n       \n# Prints value for 'one' key\n\n\nprint\n \n(\ndict\n[\n2\n])\n           \n# Prints value for 2 key\n\n\nprint\n \n(\ntinydict\n)\n          \n# Prints complete dictionary\n\n\nprint\n \n(\ntinydict\n.\nkeys\n())\n   \n# Prints all the keys\n\n\nprint\n \n(\ntinydict\n.\nvalues\n())\n \n# Prints all the values\n\n\n\n\n\n\nThis produces the following result \u2212\n\n\nThis\n \nis\n \none\n\n\nThis\n \nis\n \ntwo\n\n\n{\n'name'\n:\n \n'john'\n,\n \n'dept'\n:\n \n'sales'\n,\n \n'code'\n:\n \n6734\n}\n\n\ndict_keys\n([\n'name'\n,\n \n'dept'\n,\n \n'code'\n])\n\n\ndict_values\n([\n'john'\n,\n \n'sales'\n,\n \n6734\n])\n\n\n\n\n\n\nDictionaries have no concept of order among the elements. It is incorrect to say that the elements are \"out of order\"; they are simply unordered.\n\n\n\n\nSource:\n \n\n\n https://www.tutorialspoint.com/python3/python_variable_types.htm",
            "title": "Data Types in Python 3"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#data-types-in-python-3",
            "text": "",
            "title": "Data Types in Python 3"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#understanding-data-types-in-python-3",
            "text": "",
            "title": "Understanding Data Types in Python 3"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#introduction",
            "text": "In Python, like in all programming languages, data types are used to classify one particular type of data. This is important because the specific data type you use will determine what values you can assign to it and what you can do to it (including what operations you can perform on it).  In this tutorial, we will go over the important data types native to Python. This is not an exhaustive investigation of data types, but will help you become familiar with what options you have available to you in Python.",
            "title": "Introduction"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#background",
            "text": "One way to think about data types is to consider the different types of data that we use in the real world. An example of data in the real world are numbers: we may use whole numbers (0, 1, 2, \u2026), integers (\u2026, -1, 0, 1, \u2026), and irrational numbers (\u03c0), for example.  Usually, in math, we can combine numbers from different types, and get some kind of an answer. We may want to add 5 to \u03c0, for example:  5 + \u03c0  We can either keep the equation as the answer to account for the irrational number, or round \u03c0 to a number with a brief number of decimal places, and then add the numbers together:  5 + \u03c0 = 5 + 3.14 = 8.14  But, if we start to try to evaluate numbers with another data type, such as words, things start to make less sense. How would we solve for the following equation?  sky + 8  For computers, each data type can be thought of as being quite different, like words and numbers, so we will have to be careful about how we use them to assign values and how we manipulate them through operations.",
            "title": "Background"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#numbers",
            "text": "Any  number  you enter in Python will be interpreted as a number; you are not required to declare what kind of data type you are entering. Python will consider any number written without decimals as an  integer  (as in  138 ) and any number written with decimals as a  float  (as in  138.0 ).",
            "title": "Numbers"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#integers",
            "text": "Like in  math ,  integers  in computer programming are whole numbers that can be positive, negative, or 0 (\u2026,  -1 ,  0 ,  1 , \u2026). An integer can also be known as an  int . As with other programming languages, you should not use commas in numbers of four digits or more, so when you write 1,000 in your program, write it as  1000 .  We can print out an integer in a simple way like this:  print ( - 25 )  #Output : -25   Or, we can declare a  variable , which in this case is essentially a symbol of the number we are using or manipulating, like so:  my_int   =   - 25  print ( my_int )  #Output : -25   We can do math with integers in Python, too:  int_ans   =   116   -   68  print ( int_ans )  #Output : 48   Integers can be used in many ways within Python programs, and as you continue to learn more about the language you will have a lot of opportunities to work with integers and understand more about this data type.",
            "title": "Integers"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#floating-point-numbers",
            "text": "A  floating-point number  or a  float  is a real number, meaning that it can be either a rational or an irrational number. Because of this, floating-point numbers can be numbers that can contain a fractional part, such as  9.0  or  -116.42 . Simply speaking, for the purposes of thinking of a  float  in a Python program, it is a number that contains a decimal point.  Like we did with the integer, we can print out a floating-point number in a simple way like this:  print ( 17.3 )  #Output : 17.3   We can also declare a variable that stands in for a float, like so:  my_flt   =   17.3  print ( my_flt )  #Output : 17.3   And, just like with integers, we can do math with floats in Python, too:  flt_ans   =   564.0   +   365.24  print ( flt_ans )  #Output : 929.24   With integers and floating-point numbers, it is important to keep in mind that 3 \u2260 3.0, as  3  refers to an integer while  3.0  refers to a float.",
            "title": "Floating-Point Numbers"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#booleans",
            "text": "The  Boolean  data type can be one of two values, either  True  or  False . Booleans are used to represent the truth values that are associated with the logic branch of mathematics, which informs algorithms in computer science.  Whenever you see the data type Boolean, it will start with a capitalized B because it is named for the mathematician George Boole. The values  True  and  False  will also always be with a capital T and F respectively, as they are special values in Python.  Many operations in math give us answers that evaluate to either True or False:  *     ** greater   than ** \n     *     500   >   100   `True` \n     *     1   >   5   `False`  *     ** less   than ** \n     *     200   <   400   `True` \n     *     4   <   2   `False`  *     ** equal ** \n     *     5   =   5   `True` \n     *     500   =   400   `False`   Like with numbers, we can store a Boolean value in a variable:  my_bool   =   5   >   8   We can then print the Boolean value with a call to the  print()  function:  print ( my_bool )   Since 5 is not greater than 8, we will receive the following #Output : :  #Output : False   As you write more programs in Python, you will become more familiar with how Booleans work and how different functions and operations evaluating to either True or False can change the course of the program.",
            "title": "Booleans"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#strings",
            "text": "A  string  is a sequence of one or more characters (letters, numbers, symbols) that can be either a constant or a variable. Strings exist within either single quotes  '  or double quotes  \"  in Python, so to create a string, enclose a sequence of characters in quotes:  'This is a string in single quotes.'\n\n\"This is a string in double quotes.\"  You can choose to use either single quotes or double quotes, but whichever you decide on you should be consistent within a program.  The simple program \u201c Hello, World! \u201d demonstrates how a string can be used in computer programming, as the characters that make up the phrase  Hello, World!  are a string.  print ( \"Hello, World!\" )   As with other data types, we can store strings in variables:  hw   =   \"Hello, World!\"   And print out the string by calling the variable:  print ( hw )  #Ouput : Hello, World!   Like numbers, there are many operations that we can perform on strings within our programs in order to manipulate them to achieve the results we are seeking. Strings are important for communicating information to the user, and for the user to communicate information back to the program.",
            "title": "Strings"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#lists",
            "text": "A  list  is a mutable, or changeable, ordered sequence of elements. Each element or value that is inside of a list is called an  item . Just as strings are defined as characters between quotes, lists are defined by having values between square brackets  [ ] .  A list of integers looks like this:  [ - 3 ,   - 2 ,   - 1 ,   0 ,   1 ,   2 ,   3 ]   A list of floats looks like this:  [ 3.14 ,   9.23 ,   111.11 ,   312.12 ,   1.05 ]   A list of strings:  [ 'shark' ,   'cuttlefish' ,   'squid' ,   'mantis shrimp' ]   If we define our string list as  sea_creatures :  sea_creatures   =   [ 'shark' ,   'cuttlefish' ,   'squid' ,   'mantis shrimp' ]   We can print them out by calling the variable:  print ( sea_creatures )   And we see that the #Output :  looks exactly like the list that we created:  #Output : ['shark', 'cuttlefish', 'squid', 'mantis shrimp']   Lists are a very flexible data type because they are mutable in that they can have values added, removed, and changed. There is a data type that is similar to lists but that can\u2019t be changed, and that is called a tuple.",
            "title": "Lists"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#tuples",
            "text": "A  tuple  is used for grouping data. It is an immutable, or unchangeable, ordered sequence of elements.  Tuples are very similar to lists, but they use parentheses  ( )  instead of square brackets and because they are immutable their values cannot be modified.  A tuple looks like this:  ( 'blue coral' ,   'staghorn coral' ,   'pillar coral' )   We can store a tuple in a variable and print it out:  coral   =   ( 'blue coral' ,   'staghorn coral' ,   'pillar coral' )  print ( coral )  Ouput ( 'blue coral' ,   'staghorn coral' ,   'pillar coral' )   Like in the other data types, Python prints out the tuple just as we had typed it, with parentheses containing a sequence of values.",
            "title": "Tuples"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#dictionaries",
            "text": "The  dictionary  is Python\u2019s built-in  mapping  type. This means that dictionaries map  keys  to  values  and these key-value pairs are a useful way to store data in Python. A dictionary is constructed with curly braces on either side  { } .  Typically used to hold data that are related, such as the information contained in an ID, a dictionary looks like this:  { 'name' :   'Sammy' ,   'animal' :   'shark' ,   'color' :   'blue' ,   'location' :   'ocean' }   You will notice that in addition to the curly braces, there are also colons throughout the dictionary. The words to the left of the colons are the keys. Keys can be made up of any immutable data type. The keys in the dictionary above are:  'name', 'animal', 'color', 'location' .  The words to the right of the colons are the values. Values can be comprised of any data type. The values in the dictionary above are:  'Sammy', 'shark', 'blue', 'ocean' .  Like the other data types, let\u2019s store the dictionary inside a variable, and print it out:  sammy   =   { 'name' :   'Sammy' ,   'animal' :   'shark' ,   'color' :   'blue' ,    'location' :   'ocean' }  #Ouput : {'color': 'blue', 'animal': 'shark', 'name': 'Sammy', 'location': 'ocean'}   If we want to isolate Sammy\u2019s color, we can do so by calling  sammy['color'] . Let\u2019s print that out:  print ( sammy [ 'color' ])  #Output : blue   As dictionaries offer key-value pairs for storing data, they can be important elements in your Python program.",
            "title": "Dictionaries"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#conclusion",
            "text": "At this point, you should have a better understanding of some of the major data types that are available for you to use in Python. Each of these data types will become important as you develop programming projects in the Python language.  You can learn about each of the data types above in more detail by reading the following specific tutorials:   Numbers  Booleans  Strings  Lists  Tuples  Dictionaries   Once you have a solid grasp of data types available to you in Python, you can learn how to  convert data types .   Source:     https://www.digitalocean.com/community/tutorials/understanding-data-types-in-python-3",
            "title": "Conclusion"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#native-datatypes-by-dive-into-python-3",
            "text": "Source:      Dive into Python 3  by Mark Pilgrim",
            "title": "Native Datatypes By Dive Into Python 3"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#standard-data-types-by-tutorialspoint",
            "text": "The data stored in memory can be of many types. For example, a person's age is stored as a numeric value and his or her address is stored as alphanumeric characters. Python has various standard data types that are used to define the operations possible on them and the storage method for each of them.  Python has five standard data types :       Numbers    String    List    Tuple    Dictionary",
            "title": "Standard Data Types By Tutorialspoint"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#python-numbers",
            "text": "Number data types store numeric values. Number objects are created when you assign a value to them. For example \u2212  var1   =   1  var2   =   10   You can also delete the reference to a number object by using the del statement. The syntax of the del statement is \u2212  del   var1 [, var2 [, var3 [ .... , varN ]]]]   You can delete a single object or multiple objects by using the del statement.  For example \u2212  del   var  del   var_a ,   var_b   Python supports three different numerical types \u2212\n- int (signed integers)    float (floating point real values)    complex (complex numbers)    All integers in Python3 are represented as long integers. Hence, there is no separate number type as long.     int  float  complex      10  0.0  3.14j    100  15.20  45.j    -786  -21.9  9.322e-36j     A complex number consists of an ordered pair of real floating-point numbers denoted by x + yj, where x and y are real numbers and j is the imaginary unit.",
            "title": "Python Numbers"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#python-strings",
            "text": "Strings in Python are identified as a contiguous set of characters represented in the quotation marks. Python allows either pair of single or double quotes. Subsets of strings can be taken using the slice operator ([ ] and [:] ) with indexes starting at 0 in the beginning of the string and working their way from -1 to the end.  The plus (+) sign is the string concatenation operator and the asterisk (*) is the repetition operator. For example \u2212  #!/usr/bin/python3  str   =   'Hello World!'  print   ( str )            # Prints complete string  print   ( str [ 0 ])         # Prints first character of the string  print   ( str [ 2 : 5 ])       # Prints characters starting from 3rd to 5th  print   ( str [ 2 :])        # Prints string starting from 3rd character  print   ( str   *   2 )        # Prints string two times  print   ( str   +   \"TEST\" )   # Prints concatenated string   This will produce the following result \u2212  Hello   World !  H  llo  llo   World !  Hello   World ! Hello   World !  Hello   World ! TEST",
            "title": "Python Strings"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#python-lists",
            "text": "Lists are the most versatile of Python's compound data types. A list contains items separated by commas and enclosed within square brackets ([]). To some extent, lists are similar to arrays in C. One of the differences between them is that all the items belonging to a list can be of different data type.  The values stored in a list can be accessed using the slice operator ([ ] and [:]) with indexes starting at 0 in the beginning of the list and working their way to end -1. The plus (+) sign is the list concatenation operator, and the asterisk (*) is the repetition operator. For example \u2212  #!/usr/bin/python3  list   =   [   'abcd' ,   786   ,   2.23 ,   'john' ,   70.2   ]  tinylist   =   [ 123 ,   'john' ]  print   ( list )            # Prints complete list  print   ( list [ 0 ])         # Prints first element of the list  print   ( list [ 1 : 3 ])       # Prints elements starting from 2nd till 3rd   print   ( list [ 2 :])        # Prints elements starting from 3rd element  print   ( tinylist   *   2 )    # Prints list two times  print   ( list   +   tinylist )   # Prints concatenated lists   This produces the following result \u2212  [ 'abcd' ,   786 ,   2.23 ,   'john' ,   70.200000000000003 ]  abcd  [ 786 ,   2.23 ]  [ 2.23 ,   'john' ,   70.200000000000003 ]  [ 123 ,   'john' ,   123 ,   'john' ]  [ 'abcd' ,   786 ,   2.23 ,   'john' ,   70.200000000000003 ,   123 ,   'john' ]",
            "title": "Python Lists"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#python-tuples",
            "text": "A tuple is another sequence data type that is similar to the list. A tuple consists of a number of values separated by commas. Unlike lists, however, tuples are enclosed within parenthesis.  The main difference between lists and tuples are \u2212 Lists are enclosed in brackets ( [ ] ) and their elements and size can be changed, while tuples are enclosed in parentheses ( ( ) ) and cannot be updated. Tuples can be thought of as read-only lists. For example \u2212  #!/usr/bin/python3  tuple   =   (   'abcd' ,   786   ,   2.23 ,   'john' ,   70.2    )  tinytuple   =   ( 123 ,   'john' )  print   ( tuple )             # Prints complete tuple  print   ( tuple [ 0 ])          # Prints first element of the tuple  print   ( tuple [ 1 : 3 ])        # Prints elements starting from 2nd till 3rd   print   ( tuple [ 2 :])         # Prints elements starting from 3rd element  print   ( tinytuple   *   2 )     # Prints tuple two times  print   ( tuple   +   tinytuple )   # Prints concatenated tuple   This produces the following result \u2212  ( 'abcd' ,   786 ,   2.23 ,   'john' ,   70.200000000000003 )  abcd  ( 786 ,   2.23 )  ( 2.23 ,   'john' ,   70.200000000000003 )  ( 123 ,   'john' ,   123 ,   'john' )  ( 'abcd' ,   786 ,   2.23 ,   'john' ,   70.200000000000003 ,   123 ,   'john' )   The following code is invalid with tuple, because we attempted to update a tuple, which is not allowed. Similar case is possible with lists \u2212  #!/usr/bin/python3  tuple   =   (   'abcd' ,   786   ,   2.23 ,   'john' ,   70.2    )  list   =   [   'abcd' ,   786   ,   2.23 ,   'john' ,   70.2    ]  tuple [ 2 ]   =   1000      # Invalid syntax with tuple  list [ 2 ]   =   1000       # Valid syntax with list",
            "title": "Python Tuples"
        },
        {
            "location": "/beginner/Data_Types_In_Python_3/#python-dictionary",
            "text": "Python's dictionaries are kind of hash-table type. They work like associative arrays or hashes found in Perl and consist of key-value pairs. A dictionary key can be almost any Python type, but are usually numbers or strings. Values, on the other hand, can be any arbitrary Python object.  Dictionaries are enclosed by curly braces ({ }) and values can be assigned and accessed using square braces ([]). For example \u2212  #!/usr/bin/python3  dict   =   {}  dict [ 'one' ]   =   \"This is one\"  dict [ 2 ]       =   \"This is two\"  tinydict   =   { 'name' :   'john' , 'code' : 6734 ,   'dept' :   'sales' }  print   ( dict [ 'one' ])         # Prints value for 'one' key  print   ( dict [ 2 ])             # Prints value for 2 key  print   ( tinydict )            # Prints complete dictionary  print   ( tinydict . keys ())     # Prints all the keys  print   ( tinydict . values ())   # Prints all the values   This produces the following result \u2212  This   is   one  This   is   two  { 'name' :   'john' ,   'dept' :   'sales' ,   'code' :   6734 }  dict_keys ([ 'name' ,   'dept' ,   'code' ])  dict_values ([ 'john' ,   'sales' ,   6734 ])   Dictionaries have no concept of order among the elements. It is incorrect to say that the elements are \"out of order\"; they are simply unordered.   Source:     https://www.tutorialspoint.com/python3/python_variable_types.htm",
            "title": "Python Dictionary"
        },
        {
            "location": "/beginner/Variables_And_Assignment/",
            "text": "Variables and Assignment\n\n\nVariables are named locations which are used to store references to the object stored in memory. The names we choose for variables and functions are commonly known as Identifiers. In python Identifiers must obey the following rules.\n\n\n\n\nAll identifiers must start with letter or underscore ( _ ) , you\n    can\u2019t use digits. For e.g my_var  is valid identifier while 1digit \n    is not.\n\n\nIdentifiers can contain letters, digits and underscores ( _  ). \n\n\nThey  can be of any length.\n\n\n\n\nIdentifier can\u2019t be a keyword (keywords are reserved words that\n    Python uses for special purpose).Following are Keywords in python 3.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand\n\n\nexec\n\n\nnot\n\n\n\n\n\n\nas\n\n\nfinally\n\n\nor\n\n\n\n\n\n\nassert\n\n\nfor\n\n\npass\n\n\n\n\n\n\nbreak\n\n\nfrom\n\n\nprint\n\n\n\n\n\n\nclass\n\n\nglobal\n\n\nraise\n\n\n\n\n\n\ncontinue\n\n\nif\n\n\nreturn\n\n\n\n\n\n\ndef\n\n\nimport\n\n\ntry\n\n\n\n\n\n\ndel\n\n\nin\n\n\nwhile\n\n\n\n\n\n\nelif\n\n\nis\n\n\nwith\n\n\n\n\n\n\nelse\n\n\nlambda\n\n\nyield\n\n\n\n\n\n\nexcept\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAssigning Values to Variables\n\n\nValues are basic things that programs works with. For e.g 1 , 11 , 3.14 , \"hello\"  are all values. In programming terminology they are also commonly known as literals. Literals can be of different type for e.g 1 , 11  are of type int , 3.14  is float and \"hello\"  is string . Remember in python everything is object even basic data types like int, float, string, we will elaborate more on this in later chapters.\n\n\nIn python you don\u2019t need to declare types of variable ahead of time. Interpreter automatically detects the type of the variable by the data it contains. To assign value to a variable equal sign ( = ) is used. =  is also known as assignment operator.\n\n\nFollowing are some examples of variable declaration:\n\n\nx\n \n=\n \n100\n                       \n# x is integer\n\n\npi\n \n=\n \n3.14\n                     \n# pi is float\n\n\nempname\n \n=\n \n\"python is great\"\n   \n# empname is string\n\n\n\na\n \n=\n \nb\n \n=\n \nc\n \n=\n \n100\n \n# this statement assign 100 to c, b and a.\n\n\n\n\n\n\n\n\nNote:\n\nIn the above code x  stores reference to the 100  ( which is an int object ) , x  don\u2019t store 100 itself.\n\n\n\n\nIn Python comments are preceded by a pound sign ( # ). Comments are not programming statements that python interpreter executes while running the program. Comments are used by programmers to remind themselves how the program works. They are also used to write program documentation.\n\n\n#display hello world\n\n\nprint\n(\n\"hello world\"\n)\n\n\n\n\n\n\nSimultaneous Assignments\n\n\nPython allow simultaneous assignment syntax like this:\n\n\nvar1\n,\n \nvar2\n,\n \n...\n,\n \nvarn\n \n=\n \nexp1\n,\n \nexp2\n,\n \n...\n,\n \nexpn\n\n\n\n\n\n\nthis statements tells the python to evaluate all the expression on the right and assign them to the corresponding variables on the left. Simultaneous Assignments is helpful to swap values of two variables. For e.g\n\n\n>>>\n \nx\n \n=\n \n1\n\n\n>>>\n \ny\n \n=\n \n2\n\n\n\n>>>\n \ny\n,\n \nx\n \n=\n \nx\n,\n \ny\n \n# assign y value to x and x value to y\n\n\n\n\n\n\nPython Data Types\n\n\nPython has 5 standard data types namely.\n\na) \nNumbers\n\nb) \nString\n\nc) \nList\n\nd) \nTuple\n\ne) \nDictionary\n\nf)  Boolean \u2013 In Python True and False  are boolean literals.  But the following values are also considered as false.\n\n\n[] \u2013 empty list , () \u2013 empty tuple , {} \u2013 empty dictionary\n \n\n\nReceiving input from Console\n\n\ninput()  function is used to receive input from the console.\n\n\nSyntax:  input([prompt]) -> string\n\n\ninput()  function accepts an optional string argument called prompt  and returns a string.\n\n\n>>>\n \nname\n \n=\n \ninput\n(\n\"Enter your name: \"\n)\n\n\n>>>\n \nEnter\n \nyour\n \nname\n:\n \ntim\n\n\n>>>\n \nname\n\n\n'tim'\n\n\n\n\n\n\nNote that input()  returns string even if you enter a number, to convert it to an integer you can use int() or eval() .\n\n\n>>\n \nage\n \n=\n \nint\n(\ninput\n(\n\"Enter your age: \"\n))\n\n\nEnter\n \nyour\n \nage\n:\n \n22\n\n\n>>>\n \nage\n\n\n22\n\n\n>>>\n \ntype\n(\nage\n)\n\n\n<\nclass\n \n'\nint\n'>\n\n\n\n\n\n\n\n\nSource:\n \n\n\n http://thepythonguru.com\n\n\n\n\nUnderstanding Python variables and Memory Management\n\n\nHave you ever noticed any difference between variables in Python and C? For example, when you do an assignment like the following in C, it actually creates a block of memory space so that it can hold the value for that variable\n\n\nint\n \na\n \n=\n \n1\n;\n\n\n\n\n\n\nYou can think of it as putting the value assigned in a box with the variable name as shown below.\n\n\n\nAnd for all the variables you create a new box is created with the variable name to hold the value. If you change the value of the variable the box will be updated with the new value. That means doing\n\n\na\n \n=\n \n2\n;\n\n\n\n\n\n\nwill result in\n\n\n\n\nAssigning one variable to another makes a copy of the value and put that value in the new box.\n\n\nint\n \nb\n \n=\n \na\n;\n\n\n\n\n\n\n \n\n\nBut in Python variables work more like tags unlike the boxes you have seen before. When you do an assignment in Python, it tags the value with the variable name.\n\n\na\n \n=\n \n1\n\n\n\n\n\n\n\n\nand if you change the value of the varaible, it just changes the tag to the new value in memory. You dont need to do the housekeeping job of freeing the memory here. Python's Automatic Garbage Collection does it for you. When a value is without names/tags it is automatically removed from memory.\n\n\na\n \n=\n \n2\n\n\n\n\n\n\n\n\nAssigning one variable to another makes a new tag bound to the same value as show below.\n\n\nb\n \n=\n \na\n\n\n\n\n\n\n\nOther languages have 'variables'. Python has 'names'.\n\n\nA bit about Python's memory management\n\n\nAs you have seen before, a value will have only one copy in memory and all the variables having this value will refer to this memory location. For example when you have variables a, b, c having a value 10, it doesn't mean that there will be 3 copy of 10s in memory. There will be only one 10 and all the variables a, b, c will point to this value. Once a variable is updated, say you are doing a += 1 a new value 11 will be allocated in memory and a will be pointing to this.\n\n\nLet's check this behaviour with Python Interpreter. Start the Python Shell and try the following for yourselves.\n\n\n>>>\n \na\n \n=\n \n10\n\n\n>>>\n \nb\n \n=\n \n10\n\n\n>>>\n \nc\n \n=\n \n10\n\n\n>>>\n \nid\n(\na\n),\n \nid\n(\nb\n),\n \nid\n(\nc\n)\n\n\n(\n140621897573616\n,\n \n140621897573616\n,\n \n140621897573616\n)\n\n\n>>>\n \na\n \n+=\n \n1\n\n\n>>>\n \nid\n(\na\n)\n\n\n140621897573592\n\n\n\n\n\n\nid() will return an objects memory address (object's identity). As you have noticed, when you assign the same integer value to the variables, we see the same ids. But this assumption does not hold true all the time. See the following for example\n\n\n>>>\n \nx\n \n=\n \n500\n\n\n>>>\n \ny\n \n=\n \n500\n\n\n>>>\n \nid\n(\nx\n)\n\n\n4338740848\n\n\n>>>\n \nid\n(\ny\n)\n\n\n4338741040\n\n\n\n\n\n\nWhat happened here? Even after assigning the same integer values to different variable names, we are getting two different ids here. These are actually the effects of CPython optimization we are observing here. CPython implementation keeps an array of integer objects for all integers between -5 and 256. So when we create an integer in that range, they simply back reference to the existing object. You may refer the following \nlinks\n for more information.\n\n\nLet's take a look at strings now.\n\n\n>>>\n \ns1\n \n=\n \n'hello'\n\n\n>>>\n \ns2\n \n=\n \n'hello'\n\n\n>>>\n \nid\n(\ns1\n),\n \nid\n(\ns2\n)\n\n\n(\n4454725888\n,\n \n4454725888\n)\n\n\n>>>\n \ns1\n \n==\n \ns2\n\n\nTrue\n\n\n>>>\n \ns1\n \nis\n \ns2\n\n\nTrue\n\n\n>>>\n \ns3\n \n=\n \n'hello, world!'\n\n\n>>>\n \ns4\n \n=\n \n'hello, world!'\n\n\n>>>\n \nid\n(\ns3\n),\n \nid\n(\ns4\n)\n\n\n(\n4454721608\n,\n \n4454721664\n)\n\n\n>>>\n \ns3\n \n==\n \ns4\n\n\nTrue\n\n\n>>>\n \ns3\n \nis\n \ns4\n\n\nFalse\n\n\n\n\n\n\nLooks interesting, isn't it? When the string was a simple and shorter one the variable names where referring to the same object in memory. But when they became bigger, this was not the case. This is called interning, and Python does interning (to some extent) of shorter string literals (as in s1 and s2) which are created at compile time. But in general, Python string literals creates a new string object each time (as in s3 and s4). Interning is runtime dependant and is always a trade-off between memory use and the cost of checking if you are creating the same string. There's a built-in intern() function to forcefully apply interning. Read more about interning from the following links.\n\n\nStack Overflow: Does Python intern Strings?\n\n\nStack Overflow: Python String Interning\n\n\nInternals of Python String Interning\n\n\n\n\nSource:\n \n\n\n http://foobarnbaz.com/2012/07/08/understanding-python-variables/\n\n\n\n\nAssignment statements in Python are more interesting than you might think\n\n\nIn this article, we will take a deep look at three kinds of assignment statements in Python and discuss what\u2019s going on under the hood.\n\n\n>>>\n \nmy_string\n \n=\n \n\"Hello World\"\n                \n# right hand side is a simple expression\n\n\n>>>\n \nanother_string\n \n=\n \nmy_string\n               \n# right hand side is another variable\n\n\n>>>\n \nanother_string\n \n=\n \nanother_string\n \n+\n \n\"!\"\n    \n# right hand side is an operation\n\n\n\n\n\n\nWhat we find may surprise you.\n\n\nWhat happens when the right hand side is a simple expression?\n\n\n>>>\n \nmy_string\n \n=\n \n\"Hello World\"\n\n\n\n\n\n\nIn simple terms, this creates a string \u201cHello World\u201d in memory and assigns the name my_string to it. If you are using CPython[1], then we can even check the memory address explicitly by using the built in function id .\n\n\n>>>\n \nmy_string\n \n=\n \n\u201c\nHello\n \nWorld\n\u201d\n \n\n>>>\n \nid\n(\nmy_string\n)\n\n\n140400709562064\n\n\n\n\n\n\nThat big number 140400709562064 denotes where the data lives in the memory. It will be very useful for us in this entire discussion.\nWhat happens if we create another string with the same value?\n\n\n>>>\n \nanother_string\n \n=\n \n\u201c\nHello\n \nWorld\n\u201d\n\n\n\n\n\n\nDoes it reuse the previous \u201cHello World\u201d stored in memory or does it create an independent copy? Let\u2019s check this by querying the id function again.\n\n\n>>>\n \nid\n(\nanother_string\n)\n\n\n140400709562208\n\n\n\n\n\n\nThis outputs a different id, so this must be an independent copy. We conclude that:\n\n\n\n\nNote:\n\nAssignment statements where the right hand side is a simple expression creates independent copies every time.\n\n\n\n\nWhile for everyday programming, this is the rule we should remember, there are actually some weird exceptions to this rule. Here\u2019s an example.\n\n\n>>>\n \nmy_string\n \n=\n \n\u201c\nhello\n\u201d\n\n\n>>>\n \nid\n(\nmy_string\n)\n\n\n140400709562016\n\n\n>>>\n \nanother_string\n \n=\n \n\u201c\nhello\n\u201d\n\n\n>>>\n \nid\n(\nanother_string\n)\n\n\n140400709562016\n\n\n\n\n\n\nIn this case, two consecutive assignment statements did not create independent copies. Why?\nIt gets interesting now.\nFor optimizing memory, Python treats a special set of objects differently. The string \u201chello\u201d belongs to this privileged set and has a different behavior. The exact set depends on the implementation like CPython, PyPy, Jython or IronPython. For CPython, the special rule applies to:\n\n\n\n\nStrings without whitespaces and less than 20 characters and\n\n\nIntegers from -5 to +255.\n\n\n\n\nThese objects are always reused or interned. The rationale behind doing this is as follows:\n\n\n\n\nSince programmers use these objects frequently, interning existing\n    objects saves memory.\n\n\nSince immutable objects like tuples and strings cannot be modified,\n    there is no risk in interning the same object.\n\n\n\n\nHowever, Python does not do this for all immutable objects because there is a runtime cost involved for this feature. For interning an object, it must first search for the object in memory, and searching takes time. This is why the special treatment only applies for small integers and strings, because finding them is not that costly.\n\n\nWhat happens when the right hand side is an existing Python variable?\n\nLet\u2019s move on to the second type of assignment statement where the right hand side is an existing Python variable.\n\n\n>>>\n \nanother_string\n \n=\n \nmy_string\n\n\n\n\n\n\nIn this case, nothing is created in memory. After the assignment, both variables refer to the already existing object. It\u2019s basically like giving the object an additional nickname or alias. Let\u2019s confirm this by using the id function.\n\n\n>>>\n \nmy_string\n \n=\n \n\u201c\nHello\n \nWorld\n\u201d\n\n\n>>>\n \nid\n(\nmy_string\n)\n\n\n140400709562160\n\n\n>>>\n \nanother_string\n \n=\n \nmy_string\n\n\n>>>\n \nid\n(\nanother_string\n)\n\n\n140400709562160\n\n\n\n\n\n\nThe natural question at this stage is : what if, instead of just giving the existing object an alias, we wanted to create an independent copy?\nFor mutable objects, this is possible. You can either use the copy module of Python (which works on all objects) or you may use copy methods specific to the class. For a list, you have several possibilities for creating copies, all of which have different runtime.\n\n\n>>>\n \nmy_list\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n>>>\n \ncopy_of_my_list\n \n=\n \nmy_list\n.\ncopy\n()\n       \n# fastest, works only on latest Python versions\n\n\n>>>\n \ncopy_of_my_list\n \n=\n \nmy_list\n[:]\n           \n# same runtime as List.copy()\n\n\n>>>\n \ncopy_of_my_list\n \n=\n \nlist\n(\nmy_list\n)\n        \n# slightly slower\n\n\n>>>\n \nimport\n \ncopy\n\n\n>>>\n \ncopy_of_my_list\n \n=\n \ncopy\n.\ncopy\n(\nmy_list\n)\n   \n# slowest\n\n\n\n\n\n\nHow can you copy an immutable object? Well\u2026you can\u2019t! At least not in a straightforward way. If you try to use the copy module or the slicing notation, you will get back the same object and not an independent copy. Here\u2019s proof.\n\n\n# Standard ways of copying lists do not apply for tuples\n\n\n\n>>>\n \nmy_tuple\n \n=\n \n(\n1\n,\n \n2\n,\n \n3\n)\n\n\n>>>\n \nid\n(\nmy_tuple\n)\n\n\n140371873244816\n\n\n>>>\n \nanother_tuple\n \n=\n \nmy_tuple\n[:]\n\n\n>>>\n \nid\n(\nanother_tuple\n)\n\n\n140371873244816\n\n\n\n# The copy module also doesn\u2019t help\n\n\n\n>>>\n \nimport\n \ncopy\n \n\n>>>\n \nanother_tuple\n \n=\n \ncopy\n.\ncopy\n(\nmy_tuple\n)\n\n\n>>>\n \nid\n(\nanother_tuple\n)\n\n\n140371873244816\n\n\n\n\n\n\nMore importantly, there is no reason for explicitly copying an immutable object anyway. We will see why in a moment when we discuss the third kind of assignment statement.\n\nWhat happpens when the right hand side is an operation?\n\n\nIn this case, what happens depends on the result of the operation. We will discuss two simple cases:\n\n\n\n\nadding an element to an immutable object (like a tuple) and\n\n\nadding an element to a mutable object (like a list).\n\n\n\n\nLet\u2019s start with the case of the tuple.\n\n\n>>>\n \nanother_tuple\n \n+=\n  \n(\n4\n,)\n\n\n\n\n\n\nWhen you add a new element to a tuple using another_tuple += (4,), this creates a new object in memory. The immutability of tuples is key to understanding this. Since tuples are immutable, any operation that leads to a changed tuple would result in an independent copy.\nThis is the reason why you don\u2019t need to explicitly copy immutable objects : it happens automatically under the hood. Here\u2019s an example.\n\n\n>>>\n \nmy_tuple\n \n=\n \n(\n1\n,\n \n2\n,\n \n3\n)\n\n\n>>>\n \nanother_tuple\n \n=\n \nmy_tuple\n     \n# both variables point to the same object\n\n\n>>>\n \nanother_tuple\n \n+=\n \n(\n4\n,)\n        \n# this statement creates a new independent object\n\n\n>>>\n \nprint\n(\nanother_tuple\n)\n \n\n(\n1\n,\n \n2\n,\n \n3\n,\n \n4\n)\n\n\n>>>\n \nprint\n(\nmy_tuple\n)\n              \n# the old one remains unharmed\n\n\n(\n1\n,\n \n2\n,\n \n3\n)\n\n\n\n\n\n\nThe situation is much different for mutable objects and much more confusing. Let\u2019s try the same example, but now for lists.\n\n\n>>>\n \nmy_list\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n>>>\n \nanother_list\n \n=\n \nmy_list\n     \n# both variables point to the same object\n\n\n>>>\n \nanother_list\n \n+=\n \n[\n4\n,]\n       \n# this statement modifies the object in place\n\n\n>>>\n \nprint\n(\nanother_list\n)\n\n\n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n>>>\n \nprint\n(\nmy_list\n)\n             \n# the original list is modified\n\n\n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n\n\n\n\nMutable objects can be modified in place. Some operations modify the list in place and some operations don\u2019t. In this case, the statement another_list += [4,] calls another_list.\niadd\n([4,]) and \niadd\n modifies the existing object in place.\nTo make things doubly confusing, we would have completely different results if we used a slightly different notation.\n\n\n>>>\n \nmy_list\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n>>>\n \nanother_list\n \n=\n \nmy_list\n              \n# both variables point to the same object\n\n\n>>>\n \nanother_list\n \n=\n \nanother_list\n \n+\n \n[\n4\n,]\n  \n# this creates an independent copy\n\n\n>>>\n \nprint\n(\nanother_list\n)\n\n\n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n>>>\n \nprint\n(\nmy_list\n)\n                      \n# the original list is unharmed\n\n\n[\n1\n,\n \n2\n,\n \n3\n]\n  \n\n\n\n\n\nWoah! What\u2019s going on? What changed?\nIt turns out that when we change the third line, Python now internally calls a different function another_list.\nadd\n([4,]) instead of \niadd\n. This function returns a new copy instead of modifying the list in place.\nTo prevent this confusion, it is always better to create a true copy of the list if you wish to prevent modification to the original.\nLet\u2019s remember the list copy methods from before. They were List.copy(), [:], list() and copy.copy(). This is what we should use.\n\n\n>>>\n \nmy_list\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n>>>\n \nanother_list\n \n=\n \nmy_list\n.\ncopy\n()\n   \n# this creates an independent copy\n\n\n>>>\n \nanother_list\n \n+=\n \n[\n4\n,]\n            \n# this statement modifies the independent copy\n\n\n>>>\n \nprint\n(\nanother_list\n)\n\n\n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n>>>\n \nprint\n(\nmy_list\n)\n                  \n# the original list is unharmed\n\n\n[\n1\n,\n \n2\n,\n \n3\n]\n   \n\n\n\n\n\nThere\u2019s one last gotcha that can happen when copying lists.\nSuppose we have a list that has a nested list inside it. We copy this list using List.copy() and then modify the nested list. Unfortunately, this will modify the original list again!\n\n\n>>>\n \nmy_list\n \n=\n \n[[\n1\n,\n \n2\n,\n \n3\n],\n \n4\n,\n \n5\n]\n\n\n>>>\n \nanother_list\n \n=\n \nmy_list\n.\ncopy\n()\n\n\n>>>\n \nanother_list\n[\n0\n]\n \n+=\n \n[\n6\n,]\n\n\n>>>\n \nprint\n(\nanother_list\n)\n\n\n[[\n1\n,\n \n2\n,\n \n3\n,\n \n6\n],\n \n4\n,\n \n5\n]\n\n\n>>>\n \nprint\n(\nmy_list\n)\n\n\n[[\n1\n,\n \n2\n,\n \n3\n,\n \n6\n],\n \n4\n,\n \n5\n]\n \n\n\n\n\n\nWhy did that happen? Didn\u2019t we just copy the original list?\nThe truth is : we actually don\u2019t have a completely independent copy in this case. The copy() function generates a shallow copy. To see what it does, let\u2019s look at the ids of all the elements in my_list and the ids of all the elements in the copied list.\n\n\n# for my_list\n\n\n\n>>>\n \nmy_list\n \n=\n \n[[\n1\n,\n \n2\n,\n \n3\n],\n \n4\n,\n \n5\n]\n\n\n>>>\n \nid\n(\nmy_list\n)\n\n\n140371873277424\n\n\n>>>\n \nprint\n([\nid\n(\nx\n)\n \nfor\n \nx\n \nin\n \nmy_list\n])\n\n\n[\n140371873599288\n,\n \n13820176\n,\n \n13820152\n]\n\n\n\n# for another_list obtained by my_list.copy()\n\n\n\n>>>\n \nid\n(\nanother_list\n)\n\n\n140371873317016\n\n\n>>>\n \nprint\n([\nid\n(\nx\n)\n \nfor\n \nx\n \nin\n \nanother_list\n])\n\n\n[\n140371873599288\n,\n \n13820176\n,\n \n13820152\n]\n\n\n\n\n\n\nWe see the ids of my_list and another_list are indeed different, indicating another_list is a copy. But the ids of the elements contained in another_list have the same ids as the elements in my_list . So the elements have not been copied!\nThis is the property of shallow copy. It creates a new copy of the object but reuses the attributes and elements of the old copy. Thus, when you modify the elements of the new copy, you are modifying the elements of the old copy too.\nTo solve this problem, we need to copy an object along with all its attributes and elements. This can be achieved by copy.deepcopy.\n\n\n>>>\n \nmy_list\n \n=\n \n[[\n1\n,\n \n2\n,\n \n3\n],\n \n4\n,\n \n5\n]\n\n\n>>>\n \nanother_list\n \n=\n \ncopy\n.\ndeepcopy\n(\nmy_list\n)\n\n\n>>>\n \nanother_list\n[\n0\n]\n \n+=\n \n[\n6\n,]\n\n\n>>>\n \nanother_list\n\n\n[[\n1\n,\n \n2\n,\n \n3\n,\n \n6\n],\n \n4\n,\n \n5\n]\n\n\n>>>\n \nmy_list\n\n\n[[\n1\n,\n \n2\n,\n \n3\n],\n \n4\n,\n \n5\n]\n\n\n\n\n\n\nDeep copy is a quite time intensive operation and can take 1o times longer to complete compared to a shallow copy. But in some situations, it is unavoidable.\n\n\nConclusion\n\n\nThis brings me to the end of this discussion. To summarize, we have talked about the different scenarios which can arise in an assignment statement in Python. We found that:\n\n\n\n\nWhen the right hand side is a simple expression, a new copy is\n   created every time. There are some exceptions to this rule, which\n   depend on the implementation\n\n\nWhen the right hand side is an existing Python variable, then an\n   alias is created for the existing copy.\n\n\nWhen the right hand side is an operation, then the outcome depends on\n   the operation. In a simple case involving a tuple, we saw that an\n   independent copy was created. In the same case with lists, we saw\n   that the list was modified in place in one case (when we used\n   \niadd\n) and a new copy was generated in another case (when we used \nadd\n).\n\n\nList item\n\n\nMutable objects can be copied but immutable objects cannot be copied\n   in a straightforward way. There is also no need to copy immutable\n   objects.\n\n\nTo copy a mutable object along with all its attributes and elements,\n   we need to use deep copy.\n\n\n\n\n\n\nSource:\n \n\n\n https://medium.com/broken-window/many-names-one-memory-address-122f78734cb6",
            "title": "Variables and Assignment"
        },
        {
            "location": "/beginner/Variables_And_Assignment/#variables-and-assignment",
            "text": "Variables are named locations which are used to store references to the object stored in memory. The names we choose for variables and functions are commonly known as Identifiers. In python Identifiers must obey the following rules.   All identifiers must start with letter or underscore ( _ ) , you\n    can\u2019t use digits. For e.g my_var  is valid identifier while 1digit \n    is not.  Identifiers can contain letters, digits and underscores ( _  ).   They  can be of any length.   Identifier can\u2019t be a keyword (keywords are reserved words that\n    Python uses for special purpose).Following are Keywords in python 3.            and  exec  not    as  finally  or    assert  for  pass    break  from  print    class  global  raise    continue  if  return    def  import  try    del  in  while    elif  is  with    else  lambda  yield    except",
            "title": "Variables and Assignment"
        },
        {
            "location": "/beginner/Variables_And_Assignment/#assigning-values-to-variables",
            "text": "Values are basic things that programs works with. For e.g 1 , 11 , 3.14 , \"hello\"  are all values. In programming terminology they are also commonly known as literals. Literals can be of different type for e.g 1 , 11  are of type int , 3.14  is float and \"hello\"  is string . Remember in python everything is object even basic data types like int, float, string, we will elaborate more on this in later chapters.  In python you don\u2019t need to declare types of variable ahead of time. Interpreter automatically detects the type of the variable by the data it contains. To assign value to a variable equal sign ( = ) is used. =  is also known as assignment operator.  Following are some examples of variable declaration:  x   =   100                         # x is integer  pi   =   3.14                       # pi is float  empname   =   \"python is great\"     # empname is string  a   =   b   =   c   =   100   # this statement assign 100 to c, b and a.    Note: \nIn the above code x  stores reference to the 100  ( which is an int object ) , x  don\u2019t store 100 itself.   In Python comments are preceded by a pound sign ( # ). Comments are not programming statements that python interpreter executes while running the program. Comments are used by programmers to remind themselves how the program works. They are also used to write program documentation.  #display hello world  print ( \"hello world\" )",
            "title": "Assigning Values to Variables"
        },
        {
            "location": "/beginner/Variables_And_Assignment/#simultaneous-assignments",
            "text": "Python allow simultaneous assignment syntax like this:  var1 ,   var2 ,   ... ,   varn   =   exp1 ,   exp2 ,   ... ,   expn   this statements tells the python to evaluate all the expression on the right and assign them to the corresponding variables on the left. Simultaneous Assignments is helpful to swap values of two variables. For e.g  >>>   x   =   1  >>>   y   =   2  >>>   y ,   x   =   x ,   y   # assign y value to x and x value to y",
            "title": "Simultaneous Assignments"
        },
        {
            "location": "/beginner/Variables_And_Assignment/#python-data-types",
            "text": "Python has 5 standard data types namely. \na)  Numbers \nb)  String \nc)  List \nd)  Tuple \ne)  Dictionary \nf)  Boolean \u2013 In Python True and False  are boolean literals.  But the following values are also considered as false.  [] \u2013 empty list , () \u2013 empty tuple , {} \u2013 empty dictionary",
            "title": "Python Data Types"
        },
        {
            "location": "/beginner/Variables_And_Assignment/#receiving-input-from-console",
            "text": "input()  function is used to receive input from the console.  Syntax:  input([prompt]) -> string  input()  function accepts an optional string argument called prompt  and returns a string.  >>>   name   =   input ( \"Enter your name: \" )  >>>   Enter   your   name :   tim  >>>   name  'tim'   Note that input()  returns string even if you enter a number, to convert it to an integer you can use int() or eval() .  >>   age   =   int ( input ( \"Enter your age: \" ))  Enter   your   age :   22  >>>   age  22  >>>   type ( age )  < class   ' int '>    Source:     http://thepythonguru.com",
            "title": "Receiving input from Console"
        },
        {
            "location": "/beginner/Variables_And_Assignment/#understanding-python-variables-and-memory-management",
            "text": "Have you ever noticed any difference between variables in Python and C? For example, when you do an assignment like the following in C, it actually creates a block of memory space so that it can hold the value for that variable  int   a   =   1 ;   You can think of it as putting the value assigned in a box with the variable name as shown below.  And for all the variables you create a new box is created with the variable name to hold the value. If you change the value of the variable the box will be updated with the new value. That means doing  a   =   2 ;   will result in   Assigning one variable to another makes a copy of the value and put that value in the new box.  int   b   =   a ;      But in Python variables work more like tags unlike the boxes you have seen before. When you do an assignment in Python, it tags the value with the variable name.  a   =   1    and if you change the value of the varaible, it just changes the tag to the new value in memory. You dont need to do the housekeeping job of freeing the memory here. Python's Automatic Garbage Collection does it for you. When a value is without names/tags it is automatically removed from memory.  a   =   2    Assigning one variable to another makes a new tag bound to the same value as show below.  b   =   a   \nOther languages have 'variables'. Python has 'names'.",
            "title": "Understanding Python variables and Memory Management"
        },
        {
            "location": "/beginner/Variables_And_Assignment/#a-bit-about-pythons-memory-management",
            "text": "As you have seen before, a value will have only one copy in memory and all the variables having this value will refer to this memory location. For example when you have variables a, b, c having a value 10, it doesn't mean that there will be 3 copy of 10s in memory. There will be only one 10 and all the variables a, b, c will point to this value. Once a variable is updated, say you are doing a += 1 a new value 11 will be allocated in memory and a will be pointing to this.  Let's check this behaviour with Python Interpreter. Start the Python Shell and try the following for yourselves.  >>>   a   =   10  >>>   b   =   10  >>>   c   =   10  >>>   id ( a ),   id ( b ),   id ( c )  ( 140621897573616 ,   140621897573616 ,   140621897573616 )  >>>   a   +=   1  >>>   id ( a )  140621897573592   id() will return an objects memory address (object's identity). As you have noticed, when you assign the same integer value to the variables, we see the same ids. But this assumption does not hold true all the time. See the following for example  >>>   x   =   500  >>>   y   =   500  >>>   id ( x )  4338740848  >>>   id ( y )  4338741040   What happened here? Even after assigning the same integer values to different variable names, we are getting two different ids here. These are actually the effects of CPython optimization we are observing here. CPython implementation keeps an array of integer objects for all integers between -5 and 256. So when we create an integer in that range, they simply back reference to the existing object. You may refer the following  links  for more information.  Let's take a look at strings now.  >>>   s1   =   'hello'  >>>   s2   =   'hello'  >>>   id ( s1 ),   id ( s2 )  ( 4454725888 ,   4454725888 )  >>>   s1   ==   s2  True  >>>   s1   is   s2  True  >>>   s3   =   'hello, world!'  >>>   s4   =   'hello, world!'  >>>   id ( s3 ),   id ( s4 )  ( 4454721608 ,   4454721664 )  >>>   s3   ==   s4  True  >>>   s3   is   s4  False   Looks interesting, isn't it? When the string was a simple and shorter one the variable names where referring to the same object in memory. But when they became bigger, this was not the case. This is called interning, and Python does interning (to some extent) of shorter string literals (as in s1 and s2) which are created at compile time. But in general, Python string literals creates a new string object each time (as in s3 and s4). Interning is runtime dependant and is always a trade-off between memory use and the cost of checking if you are creating the same string. There's a built-in intern() function to forcefully apply interning. Read more about interning from the following links.  Stack Overflow: Does Python intern Strings?  Stack Overflow: Python String Interning  Internals of Python String Interning   Source:     http://foobarnbaz.com/2012/07/08/understanding-python-variables/",
            "title": "A bit about Python's memory management"
        },
        {
            "location": "/beginner/Variables_And_Assignment/#assignment-statements-in-python-are-more-interesting-than-you-might-think",
            "text": "In this article, we will take a deep look at three kinds of assignment statements in Python and discuss what\u2019s going on under the hood.  >>>   my_string   =   \"Hello World\"                  # right hand side is a simple expression  >>>   another_string   =   my_string                 # right hand side is another variable  >>>   another_string   =   another_string   +   \"!\"      # right hand side is an operation   What we find may surprise you.  What happens when the right hand side is a simple expression?  >>>   my_string   =   \"Hello World\"   In simple terms, this creates a string \u201cHello World\u201d in memory and assigns the name my_string to it. If you are using CPython[1], then we can even check the memory address explicitly by using the built in function id .  >>>   my_string   =   \u201c Hello   World \u201d   >>>   id ( my_string )  140400709562064   That big number 140400709562064 denotes where the data lives in the memory. It will be very useful for us in this entire discussion.\nWhat happens if we create another string with the same value?  >>>   another_string   =   \u201c Hello   World \u201d   Does it reuse the previous \u201cHello World\u201d stored in memory or does it create an independent copy? Let\u2019s check this by querying the id function again.  >>>   id ( another_string )  140400709562208   This outputs a different id, so this must be an independent copy. We conclude that:   Note: \nAssignment statements where the right hand side is a simple expression creates independent copies every time.   While for everyday programming, this is the rule we should remember, there are actually some weird exceptions to this rule. Here\u2019s an example.  >>>   my_string   =   \u201c hello \u201d  >>>   id ( my_string )  140400709562016  >>>   another_string   =   \u201c hello \u201d  >>>   id ( another_string )  140400709562016   In this case, two consecutive assignment statements did not create independent copies. Why?\nIt gets interesting now.\nFor optimizing memory, Python treats a special set of objects differently. The string \u201chello\u201d belongs to this privileged set and has a different behavior. The exact set depends on the implementation like CPython, PyPy, Jython or IronPython. For CPython, the special rule applies to:   Strings without whitespaces and less than 20 characters and  Integers from -5 to +255.   These objects are always reused or interned. The rationale behind doing this is as follows:   Since programmers use these objects frequently, interning existing\n    objects saves memory.  Since immutable objects like tuples and strings cannot be modified,\n    there is no risk in interning the same object.   However, Python does not do this for all immutable objects because there is a runtime cost involved for this feature. For interning an object, it must first search for the object in memory, and searching takes time. This is why the special treatment only applies for small integers and strings, because finding them is not that costly.  What happens when the right hand side is an existing Python variable? \nLet\u2019s move on to the second type of assignment statement where the right hand side is an existing Python variable.  >>>   another_string   =   my_string   In this case, nothing is created in memory. After the assignment, both variables refer to the already existing object. It\u2019s basically like giving the object an additional nickname or alias. Let\u2019s confirm this by using the id function.  >>>   my_string   =   \u201c Hello   World \u201d  >>>   id ( my_string )  140400709562160  >>>   another_string   =   my_string  >>>   id ( another_string )  140400709562160   The natural question at this stage is : what if, instead of just giving the existing object an alias, we wanted to create an independent copy?\nFor mutable objects, this is possible. You can either use the copy module of Python (which works on all objects) or you may use copy methods specific to the class. For a list, you have several possibilities for creating copies, all of which have different runtime.  >>>   my_list   =   [ 1 ,   2 ,   3 ]  >>>   copy_of_my_list   =   my_list . copy ()         # fastest, works only on latest Python versions  >>>   copy_of_my_list   =   my_list [:]             # same runtime as List.copy()  >>>   copy_of_my_list   =   list ( my_list )          # slightly slower  >>>   import   copy  >>>   copy_of_my_list   =   copy . copy ( my_list )     # slowest   How can you copy an immutable object? Well\u2026you can\u2019t! At least not in a straightforward way. If you try to use the copy module or the slicing notation, you will get back the same object and not an independent copy. Here\u2019s proof.  # Standard ways of copying lists do not apply for tuples  >>>   my_tuple   =   ( 1 ,   2 ,   3 )  >>>   id ( my_tuple )  140371873244816  >>>   another_tuple   =   my_tuple [:]  >>>   id ( another_tuple )  140371873244816  # The copy module also doesn\u2019t help  >>>   import   copy   >>>   another_tuple   =   copy . copy ( my_tuple )  >>>   id ( another_tuple )  140371873244816   More importantly, there is no reason for explicitly copying an immutable object anyway. We will see why in a moment when we discuss the third kind of assignment statement. What happpens when the right hand side is an operation?  In this case, what happens depends on the result of the operation. We will discuss two simple cases:   adding an element to an immutable object (like a tuple) and  adding an element to a mutable object (like a list).   Let\u2019s start with the case of the tuple.  >>>   another_tuple   +=    ( 4 ,)   When you add a new element to a tuple using another_tuple += (4,), this creates a new object in memory. The immutability of tuples is key to understanding this. Since tuples are immutable, any operation that leads to a changed tuple would result in an independent copy.\nThis is the reason why you don\u2019t need to explicitly copy immutable objects : it happens automatically under the hood. Here\u2019s an example.  >>>   my_tuple   =   ( 1 ,   2 ,   3 )  >>>   another_tuple   =   my_tuple       # both variables point to the same object  >>>   another_tuple   +=   ( 4 ,)          # this statement creates a new independent object  >>>   print ( another_tuple )   ( 1 ,   2 ,   3 ,   4 )  >>>   print ( my_tuple )                # the old one remains unharmed  ( 1 ,   2 ,   3 )   The situation is much different for mutable objects and much more confusing. Let\u2019s try the same example, but now for lists.  >>>   my_list   =   [ 1 ,   2 ,   3 ]  >>>   another_list   =   my_list       # both variables point to the same object  >>>   another_list   +=   [ 4 ,]         # this statement modifies the object in place  >>>   print ( another_list )  [ 1 ,   2 ,   3 ,   4 ]  >>>   print ( my_list )               # the original list is modified  [ 1 ,   2 ,   3 ,   4 ]   Mutable objects can be modified in place. Some operations modify the list in place and some operations don\u2019t. In this case, the statement another_list += [4,] calls another_list. iadd ([4,]) and  iadd  modifies the existing object in place.\nTo make things doubly confusing, we would have completely different results if we used a slightly different notation.  >>>   my_list   =   [ 1 ,   2 ,   3 ]  >>>   another_list   =   my_list                # both variables point to the same object  >>>   another_list   =   another_list   +   [ 4 ,]    # this creates an independent copy  >>>   print ( another_list )  [ 1 ,   2 ,   3 ,   4 ]  >>>   print ( my_list )                        # the original list is unharmed  [ 1 ,   2 ,   3 ]     Woah! What\u2019s going on? What changed?\nIt turns out that when we change the third line, Python now internally calls a different function another_list. add ([4,]) instead of  iadd . This function returns a new copy instead of modifying the list in place.\nTo prevent this confusion, it is always better to create a true copy of the list if you wish to prevent modification to the original.\nLet\u2019s remember the list copy methods from before. They were List.copy(), [:], list() and copy.copy(). This is what we should use.  >>>   my_list   =   [ 1 ,   2 ,   3 ]  >>>   another_list   =   my_list . copy ()     # this creates an independent copy  >>>   another_list   +=   [ 4 ,]              # this statement modifies the independent copy  >>>   print ( another_list )  [ 1 ,   2 ,   3 ,   4 ]  >>>   print ( my_list )                    # the original list is unharmed  [ 1 ,   2 ,   3 ]      There\u2019s one last gotcha that can happen when copying lists.\nSuppose we have a list that has a nested list inside it. We copy this list using List.copy() and then modify the nested list. Unfortunately, this will modify the original list again!  >>>   my_list   =   [[ 1 ,   2 ,   3 ],   4 ,   5 ]  >>>   another_list   =   my_list . copy ()  >>>   another_list [ 0 ]   +=   [ 6 ,]  >>>   print ( another_list )  [[ 1 ,   2 ,   3 ,   6 ],   4 ,   5 ]  >>>   print ( my_list )  [[ 1 ,   2 ,   3 ,   6 ],   4 ,   5 ]    Why did that happen? Didn\u2019t we just copy the original list?\nThe truth is : we actually don\u2019t have a completely independent copy in this case. The copy() function generates a shallow copy. To see what it does, let\u2019s look at the ids of all the elements in my_list and the ids of all the elements in the copied list.  # for my_list  >>>   my_list   =   [[ 1 ,   2 ,   3 ],   4 ,   5 ]  >>>   id ( my_list )  140371873277424  >>>   print ([ id ( x )   for   x   in   my_list ])  [ 140371873599288 ,   13820176 ,   13820152 ]  # for another_list obtained by my_list.copy()  >>>   id ( another_list )  140371873317016  >>>   print ([ id ( x )   for   x   in   another_list ])  [ 140371873599288 ,   13820176 ,   13820152 ]   We see the ids of my_list and another_list are indeed different, indicating another_list is a copy. But the ids of the elements contained in another_list have the same ids as the elements in my_list . So the elements have not been copied!\nThis is the property of shallow copy. It creates a new copy of the object but reuses the attributes and elements of the old copy. Thus, when you modify the elements of the new copy, you are modifying the elements of the old copy too.\nTo solve this problem, we need to copy an object along with all its attributes and elements. This can be achieved by copy.deepcopy.  >>>   my_list   =   [[ 1 ,   2 ,   3 ],   4 ,   5 ]  >>>   another_list   =   copy . deepcopy ( my_list )  >>>   another_list [ 0 ]   +=   [ 6 ,]  >>>   another_list  [[ 1 ,   2 ,   3 ,   6 ],   4 ,   5 ]  >>>   my_list  [[ 1 ,   2 ,   3 ],   4 ,   5 ]   Deep copy is a quite time intensive operation and can take 1o times longer to complete compared to a shallow copy. But in some situations, it is unavoidable.",
            "title": "Assignment statements in Python are more interesting than you might think"
        },
        {
            "location": "/beginner/Variables_And_Assignment/#conclusion",
            "text": "This brings me to the end of this discussion. To summarize, we have talked about the different scenarios which can arise in an assignment statement in Python. We found that:   When the right hand side is a simple expression, a new copy is\n   created every time. There are some exceptions to this rule, which\n   depend on the implementation  When the right hand side is an existing Python variable, then an\n   alias is created for the existing copy.  When the right hand side is an operation, then the outcome depends on\n   the operation. In a simple case involving a tuple, we saw that an\n   independent copy was created. In the same case with lists, we saw\n   that the list was modified in place in one case (when we used\n    iadd ) and a new copy was generated in another case (when we used  add ).  List item  Mutable objects can be copied but immutable objects cannot be copied\n   in a straightforward way. There is also no need to copy immutable\n   objects.  To copy a mutable object along with all its attributes and elements,\n   we need to use deep copy.    Source:     https://medium.com/broken-window/many-names-one-memory-address-122f78734cb6",
            "title": "Conclusion"
        },
        {
            "location": "/beginner/Conditions/",
            "text": "Conditional Execution\n\n\nIn order to write useful programs, we almost always need the ability to check conditions\nand change the behavior of the program accordingly. Conditional statements give us this\nability. The simplest form is the if statement:\n\n\nif\n \nx\n \n>\n \n0\n:\n\n    \nprint\n \n'x is positive'\n\n\n\n\n\n\nThe boolean expression after if is called the condition. If it is true, then the indented\nstatement gets executed. If not, nothing happens.\nif statements have the same structure as function definitions: a header followed by an\nindented body. Statements like this are called compound statements.\nThere is no limit on the number of statements that can appear in the body, but there has\nto be at least one. Occasionally, it is useful to have a body with no statements (usually\nas a place keeper for code you haven\u2019t written yet). In that case, you can use the pass\nstatement, which does nothing.\n\n\nif\n \nx\n \n<\n \n0\n:\n\n    \npass\n \n# need to handle negative values!\n\n\n\n\n\n\nAlternative Execution\n\n\nA second form of the if statement is alternative execution, in which there are two\npossibilities and the condition determines which one gets executed. The syntax looks\nlike this:\n\n\nif\n \nx\n%\n2\n \n==\n \n0\n:\n\n    \nprint\n \n'x is even'\n\n\nelse\n:\n\n    \nprint\n \n'x is odd'\n\n\n\n\n\n\nIf the remainder when x is divided by 2 is 0, then we know that x is even, and the program\ndisplays a message to that effect. If the condition is false, the second set of statements is\nexecuted. Since the condition must be true or false, exactly one of the alternatives will\nbe executed. The alternatives are called branches, because they are branches in the flow\nof execution.\n\n\nChained Conditionals\n\n\nSometimes there are more than two possibilities and we need more than two branches.\nOne way to express a computation like that is a chained conditional:  \n\n\nif\n \nx\n \n<\n \ny\n:\n\n    \nprint\n \n'x is less than y'\n\n\nelif\n \nx\n \n>\n \ny\n:\n\n    \nprint\n \n'x is greater than y'\n\n\nelse\n:\n\n    \nprint\n \n'x and y are equal'\n\n\n\n\n\n\nelif is an abbreviation of \u201celse if.\u201d Again, exactly one branch will be executed. There is\nno limit on the number of elif statements. If there is an else clause, it has to be at the\nend, but there doesn\u2019t have to be one.  \n\n\nif\n \nchoice\n \n==\n \n'a'\n:\n\n    \ndraw_a\n()\n\n\nelif\n \nchoice\n \n==\n \n'b'\n:\n\n    \ndraw_b\n()\n\n\nelif\n \nchoice\n \n==\n \n'c'\n:\n\n    \ndraw_c\n()\n\n\n\n\n\n\nEach condition is checked in order. If the first is false, the next is checked, and so on. If\none of them is true, the corresponding branch executes, and the statement ends. Even\nif more than one condition is true, only the first true branch executes.\n\n\nNested Conditionals\n\n\nOne conditional can also be nested within another. We could have written the tri\nchotomy example like this:\n\n\nif\n \nx\n \n==\n \ny\n:\n\n    \nprint\n \n'x and y are equal'\n\n\nelse\n:\n\n    \nif\n \nx\n \n<\n \ny\n:\n\n        \nprint\n \n'x is less than y'\n\n    \nelse\n:\n\n        \nprint\n \n'x is greater than y'\n\n\n\n\n\n\nThe outer conditional contains two branches. The first branch contains a simple state\nment. The second branch contains another if statement, which has two branches of its\nown. Those two branches are both simple statements, although they could have been\nconditional statements as well.\n\nAlthough the indentation of the statements makes the structure apparent, nested\nconditionals become difficult to read very quickly. In general, it is a good idea to avoid\nthem when you can.\n\nLogical operators often provide a way to simplify nested conditional statements. For\nexample, we can rewrite the following code using a single conditional:  \n\n\nif\n \n0\n \n<\n \nx\n:\n\n    \nif\n \nx\n \n<\n \n10\n:\n\n        \nprint\n \n'x is a positive single-digit number.'\n\n\n\n\n\n\nThe print statement is executed only if we make it past both conditionals, so we can\nget the same effect with the and operator:  \n\n\nif\n \n0\n \n<\n \nx\n \nand\n \nx\n \n<\n \n10\n:\n\n    \nprint\n \n'x is a positive single-digit number.'\n\n\n\n\n\n\n\n\nSource:\n \n\n\n  \nThink Python\n by Allen B. Downey  - 2012\n\n\n\n\nIf-Else statements in Python By Udemy\n\n\nThe if-else statement is a staple of most programming languages. It is used to test different conditions and execute code accordingly. You can think of it as a \u2018map\u2019 used to make decisions in the program.\n\n\nThe basic syntax is as follows:\n\n\nif\n \ncondition1\n \n=\n \nTrue\n:\n\n      \nexecute\n \ncode1\n\n\nelse\n:\n               \n      \nexecute\n \ncode2\n\n\n\n\n\n\nIn plain English, this can be described as follows:\n\nIf condition1 is true, then execute the code included in code1. If it is not true, then run code2\n\n\nA few things to note about the syntax:\n- Each if/else statement must close with a colon (:)\n- Code to be executed as part of any if/else statement must be indented by four spaces, equivalent to one press of the Tab key.\n- Although not explicitly required, every if statement must also include an else statement \u2013 it just makes for a better program.\n\n\nYou use if-else statements a lot in your every day. Virtually every decision you make involves some form of if-else statements. \u201cIf the bacon is cheap, I\u2019ll buy a pound. If not, I\u2019ll grab some mac and cheese\u201d, \u201cif I wake up before 6, I\u2019ll head out for a jog. Otherwise, I\u2019ll head straight to work\u201d, and \u201cif the traffic is light, we\u2019ll make the movie theater in time. Else, we\u2019ll just have to grab dinner and go back home\u201d \u2013 these are some simple if-else decisions we\u2019ve all made in our everyday life. Thus, by using if-else statements in Python, you give the program the ability to make decisions depending on the user input.\n\n\nBut enough talk; let\u2019s try to understand if-else statements with an example:\n\n\nx\n \n=\n \n5\n\n\nif\n \nx\n \n>\n \n5\n:\n\n          \nprint\n \n\"X is larger than five!\"\n\n\nelse\n:\n\n          \nprint\n \n\"X is smaller than or equal to five!\"\n\n\n\n\n\n\nthis program basically instructs Python to:\n- Check the value of x.\n- If the value of x is more than 5, print that \u201cX is larger than five\u201d.\n- If the value of x is less than or equal to 5, print \u201cX is smaller than or equal to five\u201d.\n\n\nAs we\u2019ll learn below, the decision making capabilities of if-else conditions will come very handy when you want to create complicated programs.\n\n\nTesting Multiple Conditions with Elif\n\n\nThe above if-else syntax is great if you want to test just one condition, but what happens when you want to check multiple conditions?\n\n\nThis is where the Elif statement comes in handy.\n\nElif is a shortened form of Else-If. The syntax can be seen as follows:\n\n\nif\n \ncondition1\n \n=\n \nTrue\n:\n\n         \nexecute\n \ncode1\n\n\nelif\n \ncondition2\n \n=\n \nTrue\n:\n\n         \nexecute\n \ncode2\n\n\nelse\n:\n  \n         \nexecute\n \ncode3\n\n\n\n\n\n\nIn plain English, you can read this as follows:\n\nIf condition1 is true, execute code1. Else, if condition2 is true, execute code2. If neither condition1 or condition2 are true, execute code3.\n\n\nThere is no limit to the number of elif statements you can include in a Python program. You can test dozens of conditions using multiple elif statements as long as you close with an else statement.\n\nLet\u2019s try to understand this with an example:  \n\n\nx\n \n=\n \n5\n\n\nif\n \nx\n \n==\n \n5\n:\n\n          \nprint\n \n\"Wow, X is EXACTLY five!\"\n\n\nelif\n \nx\n \n>\n \n5\n:\n\n          \nprint\n \n\"X is now MORE than five!\"\n\n\nelse\n:\n\n          \nprint\n \n\"X is now LESS than five!\"\n\n\n\n\n\n\nSo what exactly is happening here? Let\u2019s break it down into individual steps:  \n\n\n\n\nPython first checks if the value of x is exactly equal to 5, as given in the first if statement.\n\n\nIf x is equal to five, Python executes the code included within the first if statement and exits the program.\n\n\nIf, however, x is not equal to 5, Python goes to the second elif statement. It now checks if x is greater than 5.\n\n\nIn case x is more than 5, Python executes the second block of code under the elif statement and exits the program.\n\n\nHowever, if both conditions are not met, that is, x is neither equal to, nor greater than five, Python displays the output under the third else statement.\n\n\n\n\nAs mentioned above, an if-else conditional block can include as many elif statements as you want.\n\n\nNested If-Else Statements\n\n\nSo far, we\u2019ve used just a single level of if-else statements. But what if you want to make decisions within decisions? That\u2019s like saying: \u201cif the oranges are fresh, buy a dozen if they are more than $5/lb, and two dozen if they are less than $5/lb\u201d\n\n\nIn programmer-speak (i.e. algorithmically) this can be written as follows: \n\n\norange_quality\n \n=\n \n\u201c\nfresh\n\u201d\n\n\norange_price\n \n=\n \n4.0\n\n\nif\n \norange_quality\n \n==\n \n\u201c\nfresh\n\u201d\n:\n\n          \nif\n \norange_price\n \n<\n \n5\n:\n\n                    \nbuy\n \n24.0\n\n          \nelse\n:\n \n                    \nbuy\n \n12.0\n\n\nelse\n:\n\n          \ndon\n\u2019\nt_buy_oranges\n\n\n\n\n\n\nThis is an example of a nested if-else statement \u2013 an if-else statement inside another if-else statement. These can help you make more complex decisions and give you even finer control over the program flow. In terms of syntax, they can be written as follows:  \n\n\nif\n \ncondition1\n \n=\n  \nTrue\n:\n\n          \nif\n \ncondition2\n \n=\n \nTrue\n:\n\n                  \nexecute\n \ncode1\n\n          \nelif\n \ncondition3\n \n=\n \nTrue\n:\n\n                  \nexecute\n \ncode2\n\n          \nelse\n:\n\n                  \nexecute\n \ncode3\n\n\nelse\n:\n\n          \nexecute\n \ncode4\n\n\n\n\n\n\nThus, the syntax rules are the same as a standard if-statement \u2013 i.e. nested statements must be tabbed in. Theoretically, you can nest as many if-else statements as you want, but it is poor practice to go more than two levels deep. \n\n\n\n\nSource:\n \n\n\n https://blog.udemy.com/python-if-else/\n\n\n\n\nHow To Write Conditional Statements in Python 3\n\n\nConditional statements are part of every programming language. With conditional statements, we can have code that sometimes runs and at other times does not run, depending on the conditions of the program at that time.\n\n\nWhen we fully execute each statement of a program, moving from the top to the bottom with each line executed in order, we are not asking the program to evaluate specific conditions. By using conditional statements, programs can determine whether certain conditions are being met and then be told what to do next.  \n\n\nLet\u2019s look at some examples where we would use conditional statements:  \n\n\n\n\nIf the student receives over 65% on her test, report that her grade passes; if not, report that her grade fails\n\n\nIf he has money in his account, calculate interest; if he doesn\u2019t, charge a penalty fee\n\n\nIf they buy 10 oranges or more, calculate a discount of 5%; if they buy fewer, then don\u2019t\n\n\n\n\nThrough evaluating conditions and assigning code to run based on whether or not those conditions are met, we are writing conditional code.  \n\n\nThis tutorial will take you through writing conditional statements in the Python programming language.  \n\n\nIf statement\n\n\nWe will start with the if statement, which will evaluate whether a statement is true or false, and run code only in the case that the statement is true.\n\n\nIn a plain text editor, open a file and write the following code:  \n\n\ngrade\n \n=\n \n70\n\n\n\nif\n \ngrade\n \n>=\n \n65\n:\n\n    \nprint\n(\n\"Passing grade\"\n)\n\n\n\n\n\n\nWith this code, we have the variable grade and are giving it the integer value of 70. We are then using the if statement to evaluate whether or not the variable grade is greater than or equal ( >= ) to 65. If it does meet this condition, we are telling the program to print out the string Passing grade.\n\n\nIn this case, the grade of 70 does meet the condition of being greater than or equal to 65, so you will receive the following output once you run the program:  \n\n\nOutput\n\n\nPassing\n \ngrade\n\n\n\n\n\n\nLet\u2019s now change the result of this program by changing the value of the grade variable to 60:\n\n\ngrade\n \n=\n \n60\n\n\n\nif\n \ngrade\n \n>=\n \n65\n:\n\n    \nprint\n(\n\"Passing grade\"\n)\n\n\n\n\n\n\nWhen we save and run this code, we will receive no output because the condition was not met and we did not tell the program to execute another statement.\n\n\nTo give one more example, let us calculate whether a bank account balance is below 0. Let\u2019s create a file called \naccount.py\n and write the following program:\n\n\nbalance\n \n=\n \n-\n5\n\n\n\nif\n \nbalance\n \n<\n \n0\n:\n\n    \nprint\n(\n\"Balance is below 0, add funds now or you will be charged a penalty.\"\n)\n\n\n\n\n\n\nWhen we run the program with python account.py, we\u2019ll receive the following output:\n\n\nOutput\n\n\nBalance\n \nis\n \nbelow\n \n0\n,\n \nadd\n \nfunds\n \nnow\n \nor\n \nyou\n \nwill\n \nbe\n \ncharged\n \na\n \npenalty\n.\n\n\n\n\n\n\nIn the program we initialized the variable \nbalance\n with the value of -5, which is less than 0. Since the balance met the condition of the if statement (balance < 0), once we save and run the code, we will receive the string output. Again, if we change the balance to 0 or a positive number, we will receive no output.\n\n\nElse Statement\n\n\nIt is likely that we will want the program to do something even when an \nif\n statement evaluates to false. In our grade example, we will want output whether the grade is passing or failing.\n\n\nTo do this, we will add an else statement to the grade condition above that is constructed like this:\n\n\ngrade\n \n=\n \n60\n\n\n\nif\n \ngrade\n \n>=\n \n65\n:\n\n    \nprint\n(\n\"Passing grade\"\n)\n\n\n\nelse\n:\n\n    \nprint\n(\n\"Failing grade\"\n)\n\n\n\n\n\n\nSince the grade variable above has the value of 60, the if statement evaluates as false, so the program will not print out Passing grade. The else statement that follows tells the program to do something anyway.\n\n\nWhen we save and run the program, we\u2019ll receive the following output:\n\n\nOutput\n\n\nFailing\n \ngrade\n\n\n\n\n\n\nIf we then rewrite the program to give the grade a value of \n65\n or higher, we will instead receive the output \nPassing grade\n.\n\n\nTo add an else statement to the bank account example, we rewrite the code like this:\n\n\nbalance\n \n=\n \n522\n\n\n\nif\n \nbalance\n \n<\n \n0\n:\n\n    \nprint\n(\n\"Balance is below 0, add funds now or you will be charged a penalty.\"\n)\n\n\n\nelse\n:\n\n    \nprint\n(\n\"Your balance is 0 or above.\"\n)\n\n\n\n\n\n\nHere, we changed the balance variable value to a positive number so that the else statement will print. To get the first if statement to print, we can rewrite the value to a negative number.\n\n\nBy combining an if statement with an else statement, you are constructing a two-part conditional statement that will tell the computer to execute certain code whether or not the if condition is met.  \n\n\nElse if statement\n\n\nSo far, we have presented a Boolean option for conditional statements, with each if statement evaluating to either true or false. In many cases, we will want a program that evaluates more than two possible outcomes. For this, we will use an else if statement, which is written in Python as elif. The elif or else if statement looks like the if statement and will evaluate another condition.\n\n\nIn the bank account program, we may want to have three discrete outputs for three different situations:\n\n\n\n\nThe balance is below 0\n\n\nThe balance is equal to 0\n\n\nThe balance is above 0\n\n\n\n\nThe \nelif\n statement will be placed between the if statement and the else statement as follows:\n\n\n.\n \n.\n \n.\n\n\nif\n \nbalance\n \n<\n \n0\n:\n\n    \nprint\n(\n\"Balance is below 0, add funds now or you will be charged a penalty.\"\n)\n\n\n\nelif\n \nbalance\n \n==\n \n0\n:\n\n    \nprint\n(\n\"Balance is equal to 0, add funds soon.\"\n)\n\n\n\nelse\n:\n\n    \nprint\n(\n\"Your balance is 0 or above.\"\n)\n\n\n\n\n\n\nNow, there are three possible outputs that can occur once we run the program:\n- If the variable balance is equal to 0 we will receive the output from the elif statement (Balance is equal to 0, add funds soon.)\n- If the variable balance is set to a positive number, we will receive the output from the else statement (Your balance is 0 or above.).\n- If the variable balance is set to a negative number, the output will be the string from the if statement (Balance is below 0, add funds now or you will be charged a penalty).\n\n\nWhat if we want to have more than three possibilities, though? We can do this by writing more than one elif statement into our code.\n\n\nIn the \ngrade.py\n program, let\u2019s rewrite the code so that there are a few letter grades corresponding to ranges of numerical grades:\n\n\n\n\n90 or above is equivalent to an A grade\n\n\n80-89 is equivalent to a B grade\n\n\n70-79 is equivalent to a C grade\n\n\n65-69 is equivalent to a D grade\n\n\n64 or below is equivalent to an F grade\n\n\n\n\nTo run this code, we will need one \nif\n statement, three \nelif\n statements, and an \nelse\n statement that will handle all failing cases.\n\n\nLet\u2019s rewrite the code from the example above to have strings that print out each of the letter grades. We can keep our else statement the same.\n\n\n.\n \n.\n \n.\n\n\nif\n \ngrade\n \n>=\n \n90\n:\n\n    \nprint\n(\n\"A grade\"\n)\n\n\n\nelif\n \ngrade\n \n>=\n80\n:\n\n    \nprint\n(\n\"B grade\"\n)\n\n\n\nelif\n \ngrade\n \n>=\n70\n:\n\n    \nprint\n(\n\"C grade\"\n)\n\n\n\nelif\n \ngrade\n \n>=\n \n65\n:\n\n    \nprint\n(\n\"D grade\"\n)\n\n\n\nelse\n:\n\n    \nprint\n(\n\"Failing grade\"\n)\n\n\n\n\n\n\nSince elif statements will evaluate in order, we can keep our statements pretty basic. This program is completing the following steps:\n\n\n\n\nIf the grade is greater than 90, the program will print A grade, if the grade is less than 90, the program will continue to the next statement...\n\n\nIf the grade is greater than or equal to 80, the program will print B grade, if the grade is 79 or less, the program will continue to the next statement...\n\n\nIf the grade is greater than or equal to 70, the program will print C grade, if the grade is 69 or less, the program will continue to the next statement...\n\n\nIf the grade is greater than or equal to 65, the program will print D grade, if the grade is 64 or less, the program will continue to the next statement...\n\n\nThe program will print Failing grade because all of the above conditions were not met.\n\n\n\n\nNested If Statements\n\n\nOnce you are feeling comfortable with the if, elif, and else statements, you can move on to nested conditional statements. We can use nested if statements for situations where we want to check for a secondary condition if the first condition executes as true. For this, we can have an if-else statement inside of another if-else statement. Let\u2019s look at the syntax of a nested if statement:\n\n\nif\n \nstatement1\n:\n              \n#outer if statement\n\n    \nprint\n(\n\"true\"\n)\n\n\n    \nif\n \nnested_statement\n:\n    \n#nested if statement\n\n        \nprint\n(\n\"yes\"\n)\n\n\n    \nelse\n:\n                   \n#nested else statement\n\n        \nprint\n(\n\"no\"\n)\n\n\n\nelse\n:\n                       \n#outer else statement\n\n    \nprint\n(\n\"false\"\n)\n\n\n\n\n\n\nA few possible outputs can result from this code:\n\n- If \nstatement1\n evaluates to true, the program will then evaluate whether the nested_statement also evaluates to true. If both cases are true, the output will be:\n\n\nOutput\n\n\ntrue\n\n\nyes\n\n\n\n\n\n\n\n\nIf, however, statement1 evaluates to true, but nested_statement evaluates to false, then the output will be:\n\n\n\n\nOutput\n\n\ntrue\n\n\nno\n\n\n\n\n\n\n\n\nAnd if statement1 evaluates to false, the nested if-else statement will not run, so the else statement will run alone, and the output will be:\n\n\n\n\nOutput\n\n\nfalse\n\n\n\n\n\n\nWe can also have multiple if statements nested throughout our code:\n\n\nif\n \nstatement1\n:\n                  \n#outer if \n\n    \nprint\n(\n\"hello world\"\n)\n\n\n    \nif\n \nnested_statement1\n:\n       \n#first nested if \n\n        \nprint\n(\n\"yes\"\n)\n\n\n    \nelif\n \nnested_statement2\n:\n     \n#first nested elif\n\n        \nprint\n(\n\"maybe\"\n)\n\n\n    \nelse\n:\n                       \n#first nested else\n\n        \nprint\n(\n\"no\"\n)\n\n\n\nelif\n \nstatement2\n:\n                \n#outer elif\n\n    \nprint\n(\n\"hello galaxy\"\n)\n\n\n    \nif\n \nnested_statement3\n:\n       \n#second nested if\n\n        \nprint\n(\n\"yes\"\n)\n\n\n    \nelif\n \nnested_statement4\n:\n     \n#second nested elif\n\n        \nprint\n(\n\"maybe\"\n)\n\n\n    \nelse\n:\n                       \n#second nested else\n\n        \nprint\n(\n\"no\"\n)\n\n\n\nelse\n:\n                           \n#outer else\n\n    \nstatement\n(\n\"hello universe\"\n)\n\n\n\n\n\n\nIn the above code, there is a nested if statement inside each if statement in addition to the elif statement. This will allow for more options within each condition.\n\n\nLet\u2019s look at an example of nested if statements with our grade.py program. We can check for whether a grade is passing first (greater than or equal to 65%), then evaluate which letter grade the numerical grade should be equivalent to. If the grade is not passing, though, we do not need to run through the letter grades, and instead can have the program report that the grade is failing. Our modified code with the nested if statement will look like this:\n\n\n.\n \n.\n \n.\n\n\nif\n \ngrade\n \n>=\n \n65\n:\n\n    \nprint\n(\n\"Passing grade of:\"\n)\n\n\n    \nif\n \ngrade\n \n>=\n \n90\n:\n\n        \nprint\n(\n\"A\"\n)\n\n\n    \nelif\n \ngrade\n \n>=\n80\n:\n\n        \nprint\n(\n\"B\"\n)\n\n\n    \nelif\n \ngrade\n \n>=\n70\n:\n\n        \nprint\n(\n\"C\"\n)\n\n\n    \nelif\n \ngrade\n \n>=\n \n65\n:\n\n        \nprint\n(\n\"D\"\n)\n\n\n\nelse\n:\n\n    \nprint\n(\n\"Failing grade\"\n)\n\n\n\n\n\n\nIf we run the code with the variable grade set to the integer value 92, the first condition is met, and the program will print out Passing grade of:. Next, it will check to see if the grade is greater than or equal to 90, and since this condition is also met, it will print out A.\n\n\nIf we run the code with the grade variable set to 60, then the first condition is not met, so the program will skip the nested if statements and move down to the else statement, with the program printing out \nFailing grade\n.\n\n\nWe can of course add even more options to this, and use a second layer of nested if statements. Perhaps we will want to evaluate for grades of A+, A and A- separately. We can do so by first checking if the grade is passing, then checkingto see if the grade is 90 or above, then checkingto see if the grade is over 96 for an A+ for instance:\n\n\n.\n \n.\n \n.\n\n\nif\n \ngrade\n \n>=\n \n65\n:\n\n    \nprint\n(\n\"Passing grade of:\"\n)\n\n\n    \nif\n \ngrade\n \n>=\n \n90\n:\n\n        \nif\n \ngrade\n \n>\n \n96\n:\n\n            \nprint\n(\n\"A+\"\n)\n\n\n        \nelif\n \ngrade\n \n>\n \n93\n \nand\n \ngrade\n \n<=\n \n96\n:\n\n            \nprint\n(\n\"A\"\n)\n\n\n        \nelif\n \ngrade\n \n>=\n \n90\n:\n\n            \nprint\n(\n\"A-\"\n)\n\n\n.\n \n.\n \n.\n\n\n\n\n\n\nIn the code above, for a grade variable set to 96, the program will run the following:\n\n\n\n\nCheck if the grade is greater than or equal to 65 (true)\n\n\nPrint out Passing grade of:\n\n\nCheck if the grade is greater than or equal to 90 (true)\n\n\nCheck if the grade is greater than 96 (false)\n\n\nCheck if the grade is greater than 93 and also less than or equal to 96 (true)\n\n\nPrint A\n\n\nLeave these nested conditional statements and continue with remaining code\n\n\n\n\nThe output of the program for a grade of 96 therefore looks like this:\n\n\nOutput\n\n\nPassing\n \ngrade\n \nof\n:\n\n\nA\n\n\n\n\n\n\nNested if statements can provide the opportunity to add several specific levels of conditions to your code.\n\n\nConclusion\n\n\nBy using conditional statements like the if statement, you will have greater control over what your program executes. Conditional statements tell the program to evaluate whether a certain condition is being met. If the condition is met it will execute specific code, but if it is not met the program will continue to move down to other code.\n\n\n\n\nSource:\n \n\n\n https://www.digitalocean.com/community/tutorials/how-to-write-conditional-statements-in-python-3-2",
            "title": "Conditions"
        },
        {
            "location": "/beginner/Conditions/#conditional-execution",
            "text": "In order to write useful programs, we almost always need the ability to check conditions\nand change the behavior of the program accordingly. Conditional statements give us this\nability. The simplest form is the if statement:  if   x   >   0 : \n     print   'x is positive'   The boolean expression after if is called the condition. If it is true, then the indented\nstatement gets executed. If not, nothing happens.\nif statements have the same structure as function definitions: a header followed by an\nindented body. Statements like this are called compound statements.\nThere is no limit on the number of statements that can appear in the body, but there has\nto be at least one. Occasionally, it is useful to have a body with no statements (usually\nas a place keeper for code you haven\u2019t written yet). In that case, you can use the pass\nstatement, which does nothing.  if   x   <   0 : \n     pass   # need to handle negative values!",
            "title": "Conditional Execution"
        },
        {
            "location": "/beginner/Conditions/#alternative-execution",
            "text": "A second form of the if statement is alternative execution, in which there are two\npossibilities and the condition determines which one gets executed. The syntax looks\nlike this:  if   x % 2   ==   0 : \n     print   'x is even'  else : \n     print   'x is odd'   If the remainder when x is divided by 2 is 0, then we know that x is even, and the program\ndisplays a message to that effect. If the condition is false, the second set of statements is\nexecuted. Since the condition must be true or false, exactly one of the alternatives will\nbe executed. The alternatives are called branches, because they are branches in the flow\nof execution.",
            "title": "Alternative Execution"
        },
        {
            "location": "/beginner/Conditions/#chained-conditionals",
            "text": "Sometimes there are more than two possibilities and we need more than two branches.\nOne way to express a computation like that is a chained conditional:    if   x   <   y : \n     print   'x is less than y'  elif   x   >   y : \n     print   'x is greater than y'  else : \n     print   'x and y are equal'   elif is an abbreviation of \u201celse if.\u201d Again, exactly one branch will be executed. There is\nno limit on the number of elif statements. If there is an else clause, it has to be at the\nend, but there doesn\u2019t have to be one.    if   choice   ==   'a' : \n     draw_a ()  elif   choice   ==   'b' : \n     draw_b ()  elif   choice   ==   'c' : \n     draw_c ()   Each condition is checked in order. If the first is false, the next is checked, and so on. If\none of them is true, the corresponding branch executes, and the statement ends. Even\nif more than one condition is true, only the first true branch executes.",
            "title": "Chained Conditionals"
        },
        {
            "location": "/beginner/Conditions/#nested-conditionals",
            "text": "One conditional can also be nested within another. We could have written the tri\nchotomy example like this:  if   x   ==   y : \n     print   'x and y are equal'  else : \n     if   x   <   y : \n         print   'x is less than y' \n     else : \n         print   'x is greater than y'   The outer conditional contains two branches. The first branch contains a simple state\nment. The second branch contains another if statement, which has two branches of its\nown. Those two branches are both simple statements, although they could have been\nconditional statements as well. \nAlthough the indentation of the statements makes the structure apparent, nested\nconditionals become difficult to read very quickly. In general, it is a good idea to avoid\nthem when you can. \nLogical operators often provide a way to simplify nested conditional statements. For\nexample, we can rewrite the following code using a single conditional:    if   0   <   x : \n     if   x   <   10 : \n         print   'x is a positive single-digit number.'   The print statement is executed only if we make it past both conditionals, so we can\nget the same effect with the and operator:    if   0   <   x   and   x   <   10 : \n     print   'x is a positive single-digit number.'    Source:       Think Python  by Allen B. Downey  - 2012",
            "title": "Nested Conditionals"
        },
        {
            "location": "/beginner/Conditions/#if-else-statements-in-python-by-udemy",
            "text": "The if-else statement is a staple of most programming languages. It is used to test different conditions and execute code accordingly. You can think of it as a \u2018map\u2019 used to make decisions in the program.  The basic syntax is as follows:  if   condition1   =   True : \n       execute   code1  else :                \n       execute   code2   In plain English, this can be described as follows: If condition1 is true, then execute the code included in code1. If it is not true, then run code2  A few things to note about the syntax:\n- Each if/else statement must close with a colon (:)\n- Code to be executed as part of any if/else statement must be indented by four spaces, equivalent to one press of the Tab key.\n- Although not explicitly required, every if statement must also include an else statement \u2013 it just makes for a better program.  You use if-else statements a lot in your every day. Virtually every decision you make involves some form of if-else statements. \u201cIf the bacon is cheap, I\u2019ll buy a pound. If not, I\u2019ll grab some mac and cheese\u201d, \u201cif I wake up before 6, I\u2019ll head out for a jog. Otherwise, I\u2019ll head straight to work\u201d, and \u201cif the traffic is light, we\u2019ll make the movie theater in time. Else, we\u2019ll just have to grab dinner and go back home\u201d \u2013 these are some simple if-else decisions we\u2019ve all made in our everyday life. Thus, by using if-else statements in Python, you give the program the ability to make decisions depending on the user input.  But enough talk; let\u2019s try to understand if-else statements with an example:  x   =   5  if   x   >   5 : \n           print   \"X is larger than five!\"  else : \n           print   \"X is smaller than or equal to five!\"   this program basically instructs Python to:\n- Check the value of x.\n- If the value of x is more than 5, print that \u201cX is larger than five\u201d.\n- If the value of x is less than or equal to 5, print \u201cX is smaller than or equal to five\u201d.  As we\u2019ll learn below, the decision making capabilities of if-else conditions will come very handy when you want to create complicated programs.",
            "title": "If-Else statements in Python By Udemy"
        },
        {
            "location": "/beginner/Conditions/#testing-multiple-conditions-with-elif",
            "text": "The above if-else syntax is great if you want to test just one condition, but what happens when you want to check multiple conditions?  This is where the Elif statement comes in handy. \nElif is a shortened form of Else-If. The syntax can be seen as follows:  if   condition1   =   True : \n          execute   code1  elif   condition2   =   True : \n          execute   code2  else :   \n          execute   code3   In plain English, you can read this as follows: If condition1 is true, execute code1. Else, if condition2 is true, execute code2. If neither condition1 or condition2 are true, execute code3.  There is no limit to the number of elif statements you can include in a Python program. You can test dozens of conditions using multiple elif statements as long as you close with an else statement. \nLet\u2019s try to understand this with an example:    x   =   5  if   x   ==   5 : \n           print   \"Wow, X is EXACTLY five!\"  elif   x   >   5 : \n           print   \"X is now MORE than five!\"  else : \n           print   \"X is now LESS than five!\"   So what exactly is happening here? Let\u2019s break it down into individual steps:     Python first checks if the value of x is exactly equal to 5, as given in the first if statement.  If x is equal to five, Python executes the code included within the first if statement and exits the program.  If, however, x is not equal to 5, Python goes to the second elif statement. It now checks if x is greater than 5.  In case x is more than 5, Python executes the second block of code under the elif statement and exits the program.  However, if both conditions are not met, that is, x is neither equal to, nor greater than five, Python displays the output under the third else statement.   As mentioned above, an if-else conditional block can include as many elif statements as you want.",
            "title": "Testing Multiple Conditions with Elif"
        },
        {
            "location": "/beginner/Conditions/#nested-if-else-statements",
            "text": "So far, we\u2019ve used just a single level of if-else statements. But what if you want to make decisions within decisions? That\u2019s like saying: \u201cif the oranges are fresh, buy a dozen if they are more than $5/lb, and two dozen if they are less than $5/lb\u201d  In programmer-speak (i.e. algorithmically) this can be written as follows:   orange_quality   =   \u201c fresh \u201d  orange_price   =   4.0  if   orange_quality   ==   \u201c fresh \u201d : \n           if   orange_price   <   5 : \n                     buy   24.0 \n           else :  \n                     buy   12.0  else : \n           don \u2019 t_buy_oranges   This is an example of a nested if-else statement \u2013 an if-else statement inside another if-else statement. These can help you make more complex decisions and give you even finer control over the program flow. In terms of syntax, they can be written as follows:    if   condition1   =    True : \n           if   condition2   =   True : \n                   execute   code1 \n           elif   condition3   =   True : \n                   execute   code2 \n           else : \n                   execute   code3  else : \n           execute   code4   Thus, the syntax rules are the same as a standard if-statement \u2013 i.e. nested statements must be tabbed in. Theoretically, you can nest as many if-else statements as you want, but it is poor practice to go more than two levels deep.    Source:     https://blog.udemy.com/python-if-else/",
            "title": "Nested If-Else Statements"
        },
        {
            "location": "/beginner/Conditions/#how-to-write-conditional-statements-in-python-3",
            "text": "Conditional statements are part of every programming language. With conditional statements, we can have code that sometimes runs and at other times does not run, depending on the conditions of the program at that time.  When we fully execute each statement of a program, moving from the top to the bottom with each line executed in order, we are not asking the program to evaluate specific conditions. By using conditional statements, programs can determine whether certain conditions are being met and then be told what to do next.    Let\u2019s look at some examples where we would use conditional statements:     If the student receives over 65% on her test, report that her grade passes; if not, report that her grade fails  If he has money in his account, calculate interest; if he doesn\u2019t, charge a penalty fee  If they buy 10 oranges or more, calculate a discount of 5%; if they buy fewer, then don\u2019t   Through evaluating conditions and assigning code to run based on whether or not those conditions are met, we are writing conditional code.    This tutorial will take you through writing conditional statements in the Python programming language.",
            "title": "How To Write Conditional Statements in Python 3"
        },
        {
            "location": "/beginner/Conditions/#if-statement",
            "text": "We will start with the if statement, which will evaluate whether a statement is true or false, and run code only in the case that the statement is true.  In a plain text editor, open a file and write the following code:    grade   =   70  if   grade   >=   65 : \n     print ( \"Passing grade\" )   With this code, we have the variable grade and are giving it the integer value of 70. We are then using the if statement to evaluate whether or not the variable grade is greater than or equal ( >= ) to 65. If it does meet this condition, we are telling the program to print out the string Passing grade.  In this case, the grade of 70 does meet the condition of being greater than or equal to 65, so you will receive the following output once you run the program:    Output  Passing   grade   Let\u2019s now change the result of this program by changing the value of the grade variable to 60:  grade   =   60  if   grade   >=   65 : \n     print ( \"Passing grade\" )   When we save and run this code, we will receive no output because the condition was not met and we did not tell the program to execute another statement.  To give one more example, let us calculate whether a bank account balance is below 0. Let\u2019s create a file called  account.py  and write the following program:  balance   =   - 5  if   balance   <   0 : \n     print ( \"Balance is below 0, add funds now or you will be charged a penalty.\" )   When we run the program with python account.py, we\u2019ll receive the following output:  Output  Balance   is   below   0 ,   add   funds   now   or   you   will   be   charged   a   penalty .   In the program we initialized the variable  balance  with the value of -5, which is less than 0. Since the balance met the condition of the if statement (balance < 0), once we save and run the code, we will receive the string output. Again, if we change the balance to 0 or a positive number, we will receive no output.",
            "title": "If statement"
        },
        {
            "location": "/beginner/Conditions/#else-statement",
            "text": "It is likely that we will want the program to do something even when an  if  statement evaluates to false. In our grade example, we will want output whether the grade is passing or failing.  To do this, we will add an else statement to the grade condition above that is constructed like this:  grade   =   60  if   grade   >=   65 : \n     print ( \"Passing grade\" )  else : \n     print ( \"Failing grade\" )   Since the grade variable above has the value of 60, the if statement evaluates as false, so the program will not print out Passing grade. The else statement that follows tells the program to do something anyway.  When we save and run the program, we\u2019ll receive the following output:  Output  Failing   grade   If we then rewrite the program to give the grade a value of  65  or higher, we will instead receive the output  Passing grade .  To add an else statement to the bank account example, we rewrite the code like this:  balance   =   522  if   balance   <   0 : \n     print ( \"Balance is below 0, add funds now or you will be charged a penalty.\" )  else : \n     print ( \"Your balance is 0 or above.\" )   Here, we changed the balance variable value to a positive number so that the else statement will print. To get the first if statement to print, we can rewrite the value to a negative number.  By combining an if statement with an else statement, you are constructing a two-part conditional statement that will tell the computer to execute certain code whether or not the if condition is met.",
            "title": "Else Statement"
        },
        {
            "location": "/beginner/Conditions/#else-if-statement",
            "text": "So far, we have presented a Boolean option for conditional statements, with each if statement evaluating to either true or false. In many cases, we will want a program that evaluates more than two possible outcomes. For this, we will use an else if statement, which is written in Python as elif. The elif or else if statement looks like the if statement and will evaluate another condition.  In the bank account program, we may want to have three discrete outputs for three different situations:   The balance is below 0  The balance is equal to 0  The balance is above 0   The  elif  statement will be placed between the if statement and the else statement as follows:  .   .   .  if   balance   <   0 : \n     print ( \"Balance is below 0, add funds now or you will be charged a penalty.\" )  elif   balance   ==   0 : \n     print ( \"Balance is equal to 0, add funds soon.\" )  else : \n     print ( \"Your balance is 0 or above.\" )   Now, there are three possible outputs that can occur once we run the program:\n- If the variable balance is equal to 0 we will receive the output from the elif statement (Balance is equal to 0, add funds soon.)\n- If the variable balance is set to a positive number, we will receive the output from the else statement (Your balance is 0 or above.).\n- If the variable balance is set to a negative number, the output will be the string from the if statement (Balance is below 0, add funds now or you will be charged a penalty).  What if we want to have more than three possibilities, though? We can do this by writing more than one elif statement into our code.  In the  grade.py  program, let\u2019s rewrite the code so that there are a few letter grades corresponding to ranges of numerical grades:   90 or above is equivalent to an A grade  80-89 is equivalent to a B grade  70-79 is equivalent to a C grade  65-69 is equivalent to a D grade  64 or below is equivalent to an F grade   To run this code, we will need one  if  statement, three  elif  statements, and an  else  statement that will handle all failing cases.  Let\u2019s rewrite the code from the example above to have strings that print out each of the letter grades. We can keep our else statement the same.  .   .   .  if   grade   >=   90 : \n     print ( \"A grade\" )  elif   grade   >= 80 : \n     print ( \"B grade\" )  elif   grade   >= 70 : \n     print ( \"C grade\" )  elif   grade   >=   65 : \n     print ( \"D grade\" )  else : \n     print ( \"Failing grade\" )   Since elif statements will evaluate in order, we can keep our statements pretty basic. This program is completing the following steps:   If the grade is greater than 90, the program will print A grade, if the grade is less than 90, the program will continue to the next statement...  If the grade is greater than or equal to 80, the program will print B grade, if the grade is 79 or less, the program will continue to the next statement...  If the grade is greater than or equal to 70, the program will print C grade, if the grade is 69 or less, the program will continue to the next statement...  If the grade is greater than or equal to 65, the program will print D grade, if the grade is 64 or less, the program will continue to the next statement...  The program will print Failing grade because all of the above conditions were not met.",
            "title": "Else if statement"
        },
        {
            "location": "/beginner/Conditions/#nested-if-statements",
            "text": "Once you are feeling comfortable with the if, elif, and else statements, you can move on to nested conditional statements. We can use nested if statements for situations where we want to check for a secondary condition if the first condition executes as true. For this, we can have an if-else statement inside of another if-else statement. Let\u2019s look at the syntax of a nested if statement:  if   statement1 :                #outer if statement \n     print ( \"true\" ) \n\n     if   nested_statement :      #nested if statement \n         print ( \"yes\" ) \n\n     else :                     #nested else statement \n         print ( \"no\" )  else :                         #outer else statement \n     print ( \"false\" )   A few possible outputs can result from this code: \n- If  statement1  evaluates to true, the program will then evaluate whether the nested_statement also evaluates to true. If both cases are true, the output will be:  Output  true  yes    If, however, statement1 evaluates to true, but nested_statement evaluates to false, then the output will be:   Output  true  no    And if statement1 evaluates to false, the nested if-else statement will not run, so the else statement will run alone, and the output will be:   Output  false   We can also have multiple if statements nested throughout our code:  if   statement1 :                    #outer if  \n     print ( \"hello world\" ) \n\n     if   nested_statement1 :         #first nested if  \n         print ( \"yes\" ) \n\n     elif   nested_statement2 :       #first nested elif \n         print ( \"maybe\" ) \n\n     else :                         #first nested else \n         print ( \"no\" )  elif   statement2 :                  #outer elif \n     print ( \"hello galaxy\" ) \n\n     if   nested_statement3 :         #second nested if \n         print ( \"yes\" ) \n\n     elif   nested_statement4 :       #second nested elif \n         print ( \"maybe\" ) \n\n     else :                         #second nested else \n         print ( \"no\" )  else :                             #outer else \n     statement ( \"hello universe\" )   In the above code, there is a nested if statement inside each if statement in addition to the elif statement. This will allow for more options within each condition.  Let\u2019s look at an example of nested if statements with our grade.py program. We can check for whether a grade is passing first (greater than or equal to 65%), then evaluate which letter grade the numerical grade should be equivalent to. If the grade is not passing, though, we do not need to run through the letter grades, and instead can have the program report that the grade is failing. Our modified code with the nested if statement will look like this:  .   .   .  if   grade   >=   65 : \n     print ( \"Passing grade of:\" ) \n\n     if   grade   >=   90 : \n         print ( \"A\" ) \n\n     elif   grade   >= 80 : \n         print ( \"B\" ) \n\n     elif   grade   >= 70 : \n         print ( \"C\" ) \n\n     elif   grade   >=   65 : \n         print ( \"D\" )  else : \n     print ( \"Failing grade\" )   If we run the code with the variable grade set to the integer value 92, the first condition is met, and the program will print out Passing grade of:. Next, it will check to see if the grade is greater than or equal to 90, and since this condition is also met, it will print out A.  If we run the code with the grade variable set to 60, then the first condition is not met, so the program will skip the nested if statements and move down to the else statement, with the program printing out  Failing grade .  We can of course add even more options to this, and use a second layer of nested if statements. Perhaps we will want to evaluate for grades of A+, A and A- separately. We can do so by first checking if the grade is passing, then checkingto see if the grade is 90 or above, then checkingto see if the grade is over 96 for an A+ for instance:  .   .   .  if   grade   >=   65 : \n     print ( \"Passing grade of:\" ) \n\n     if   grade   >=   90 : \n         if   grade   >   96 : \n             print ( \"A+\" ) \n\n         elif   grade   >   93   and   grade   <=   96 : \n             print ( \"A\" ) \n\n         elif   grade   >=   90 : \n             print ( \"A-\" )  .   .   .   In the code above, for a grade variable set to 96, the program will run the following:   Check if the grade is greater than or equal to 65 (true)  Print out Passing grade of:  Check if the grade is greater than or equal to 90 (true)  Check if the grade is greater than 96 (false)  Check if the grade is greater than 93 and also less than or equal to 96 (true)  Print A  Leave these nested conditional statements and continue with remaining code   The output of the program for a grade of 96 therefore looks like this:  Output  Passing   grade   of :  A   Nested if statements can provide the opportunity to add several specific levels of conditions to your code.",
            "title": "Nested If Statements"
        },
        {
            "location": "/beginner/Conditions/#conclusion",
            "text": "By using conditional statements like the if statement, you will have greater control over what your program executes. Conditional statements tell the program to evaluate whether a certain condition is being met. If the condition is met it will execute specific code, but if it is not met the program will continue to move down to other code.   Source:     https://www.digitalocean.com/community/tutorials/how-to-write-conditional-statements-in-python-3-2",
            "title": "Conclusion"
        },
        {
            "location": "/beginner/For_Loop/",
            "text": "How To Construct For Loops in Python 3\n\n\nUsing loops in computer programming allows us to automate and repeat similar tasks multiple times. In this tutorial, we\u2019ll be covering Python\u2019s for loop.\n\n\nA for loop implements the repeated execution of code based on a loop counter or loop variable. This means that for loops are used most often when the number of iterations is known before entering the loop, unlike while loops which are conditionally based.\n\n\nFor Loops\n\n\nIn Python, for loops are constructed like so:  \n\n\nfor\n \n[\niterating\n \nvariable\n]\n \nin\n \n[\nsequence\n]:\n\n    \n[\ndo\n \nsomething\n]\n\n\n\n\n\n\nThe something that is being done will be executed until the sequence is over.  \n\n\nLet\u2019s look at a for loop that iterates through a range of values:  \n\n\nfor\n \ni\n \nin\n \nrange\n(\n0\n,\n5\n):\n\n   \nprint\n(\ni\n)\n\n\n\n\n\n\nWhen we run this program, the output looks like this:\n\n\nOutput\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n\n\n\n\nThis for loop sets up i as its iterating variable, and the sequence exists in the range of 0 to 5.  \n\n\nThen within the loop we print out one integer per loop iteration. Keep in mind that in programming we tend to begin at index 0, so that is why although 5 numbers are printed out, they range from 0-4.  \n\n\nYou\u2019ll commonly see and use for loops when a program needs to repeat a block of code a number of times.  \n\n\nFor Loops using range()\n\n\nOne of Python\u2019s built-in immutable sequence types is range(). In loops, range() is used to control how many times the loop will be repeated.\n\nWhen working with range(), you can pass between 1 and 3 integer arguments to it:  \n\n\n\n\nstart states the integer value at which the sequence begins, if this is not included then start begins at 0\n\n\nstop is always required and is the integer that is counted up to but not included\n\n\nstep sets how much to increase (or decrease in the case of negative numbers) the next iteration, if this is omitted then step defaults to 1\n\n\n\n\nWe\u2019ll look at some examples of passing different arguments to \nrange()\n.\n\n\nFirst, let\u2019s only pass the stop argument, so that our sequence set up is \nrange(stop)\n:\n\n\nfor\n \ni\n \nin\n \nrange\n(\n6\n):\n\n   \nprint\n(\ni\n)\n\n\n\n\n\n\nIn the program above, the stop argument is 6, so the code will iterate from 0-6 (exclusive of 6):\n\n\nOutput\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n\n\n\n\nNext, we\u2019ll look at range(start, stop), with values passed for when the iteration should start and for when it should stop:  \n\n\nfor\n \ni\n \nin\n \nrange\n(\n20\n,\n25\n):\n\n   \nprint\n(\ni\n)\n\n\n\n\n\n\nHere, the range goes from 20 (inclusive) to 25 (exclusive), so the output looks like this:  \n\n\nOutput\n\n\n20\n\n\n21\n\n\n22\n\n\n23\n\n\n24\n\n\n\n\n\n\nThe step argument of range() is similar to specifying stride while slicing strings in that it can be used to skip values within the sequence.\n\n\nWith all three arguments, step comes in the final position: range(start, stop, step). First, let\u2019s use a step with a positive value:  \n\n\nfor\n \ni\n \nin\n \nrange\n(\n0\n,\n15\n,\n3\n):\n\n   \nprint\n(\ni\n)\n\n\n\n\n\n\nIn this case, the for loop is set up so that the numbers from 0 to 15 print out, but at a step of 3, so that only every third number is printed, like so:\n\n\nOutput\n\n\n0\n\n\n3\n\n\n6\n\n\n9\n\n\n12\n\n\n\n\n\n\nWe can also use a negative value for our step argument to iterate backwards, but we\u2019ll have to adjust our start and stop arguments accordingly:  \n\n\nfor\n \ni\n \nin\n \nrange\n(\n100\n,\n0\n,\n-\n10\n):\n\n   \nprint\n(\ni\n)\n\n\n\n\n\n\nHere, 100 is the start value, 0 is the stop value, and -10 is the range, so the loop begins at 100 and ends at 0, decreasing by 10 with each iteration. We can see this occur in the output:\n\n\nOutput\n\n\n100\n\n\n90\n\n\n80\n\n\n70\n\n\n60\n\n\n50\n\n\n40\n\n\n30\n\n\n20\n\n\n10\n\n\n\n\n\n\nWhen programming in Python, \nfor\n loops often make use of the range() sequence type as its parameters for iteration.\n\n\nFor Loops using Sequential Data Types\n\n\nLists and other data sequence types can also be leveraged as iteration parameters in for loops. Rather than iterating through a range(), you can define a list and iterate through that list.\n\n\nWe\u2019ll assign a list to a variable, and then iterate through the list: \n\n\nsharks\n \n=\n \n[\n'hammerhead'\n,\n \n'great white'\n,\n \n'dogfish'\n,\n \n'frilled'\n,\n \n'bullhead'\n,\n \n'requiem'\n]\n\n\n\nfor\n \nshark\n \nin\n \nsharks\n:\n\n   \nprint\n(\nshark\n)\n\n\n\n\n\n\nIn this case, we are printing out each item in the list. Though we used the variable shark, we could have called the variable any other valid variable name and we would get the same output:\n\n\nOutput\n\n\nhammerhead\n\n\ngreat\n \nwhite\n\n\ndogfish\n\n\nfrilled\n\n\nbullhead\n\n\nrequiem\n\n\n\n\n\n\nThe output above shows that the for loop iterated through the list, and printed each item from the list per line.\n\n\nLists and other sequence-based data types like strings and tuples are common to use with loops because they are iterable. You can combine these data types with range() to add items to a list, for example:\n\n\nsharks\n \n=\n \n[\n'hammerhead'\n,\n \n'great white'\n,\n \n'dogfish'\n,\n \n'frilled'\n,\n \n'bullhead'\n,\n \n'requiem'\n]\n\n\n\nfor\n \nitem\n \nin\n \nrange\n(\nlen\n(\nsharks\n)):\n\n   \nsharks\n.\nappend\n(\n'shark'\n)\n\n\n\nprint\n(\nsharks\n)\n\n\n\n\n\n\nOutput\n\n\n[\n'hammerhead'\n,\n \n'great white'\n,\n \n'dogfish'\n,\n \n'frilled'\n,\n \n'bullhead'\n,\n \n'requiem'\n,\n \n'shark'\n,\n \n'shark'\n,\n \n'shark'\n,\n \n'shark'\n,\n \n'shark'\n,\n \n'shark'\n]\n\n\n\n\n\n\nHere, we have added a placeholder string of 'shark' for each item of the length of the sharks list.\n\n\nYou can also use a for loop to construct a list from scratch:\n\n\nintegers\n \n=\n \n[]\n\n\n\nfor\n \ni\n \nin\n \nrange\n(\n10\n):\n\n   \nintegers\n.\nappend\n(\ni\n)\n\n\n\nprint\n(\nintegers\n)\n\n\n\n\n\n\nIn this example, the list integers is initialized empty, but the for loop populates the list like so:\n\n\nOutput\n\n\n[\n0\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n]\n\n\n\n\n\n\nSimilarly, we can iterate through strings:\n\n\nsammy\n \n=\n \n'Sammy'\n\n\n\nfor\n \nletter\n \nin\n \nsammy\n:\n\n   \nprint\n(\nletter\n)\n\n\n\n\n\n\nOutput\n\n\nS\n\n\na\n\n\nm\n\n\nm\n\n\ny\n\n\n\n\n\n\nIterating through tuples is done in the same format as iterating through lists or strings above.\n\n\nWhen iterating through a dictionary, it\u2019s important to keep the key : value structure in mind to ensure that you are calling the correct element of the dictionary. Here is an example that calls both the key and the value:\n\n\nsammy_shark\n \n=\n \n{\n'name'\n:\n \n'Sammy'\n,\n \n'animal'\n:\n \n'shark'\n,\n \n'color'\n:\n \n'blue'\n,\n \n'location'\n:\n \n'ocean'\n}\n\n\n\nfor\n \nkey\n \nin\n \nsammy_shark\n:\n\n   \nprint\n(\nkey\n \n+\n \n': '\n \n+\n \nsammy_shark\n[\nkey\n])\n\n\n\n\n\n\nOutput\n\n\nname\n:\n \nSammy\n\n\nanimal\n:\n \nshark\n\n\nlocation\n:\n \nocean\n\n\ncolor\n:\n \nblue\n\n\n\n\n\n\nWhen using dictionaries with for loops, the iterating variable corresponds to the keys of the dictionary, and dictionary_variable[iterating_variable] corresponds to the values. In the case above, the iterating variable key was used to stand for key, and sammy_shark[key] was used to stand for the values.\n\n\nLoops are often used to iterate and manipulate sequential data types.  \n\n\nNested For Loops\n\n\nLoops can be nested in Python, as they can with other programming languages.\n\n\nA nested loop is a loop that occurs within another loop, structurally similar to nested if statements. These are constructed like so: \n\n\nfor\n \n[\nfirst\n \niterating\n \nvariable\n]\n \nin\n \n[\nouter\n \nloop\n]:\n \n# Outer loop\n\n    \n[\ndo\n \nsomething\n]\n  \n# Optional\n\n    \nfor\n \n[\nsecond\n \niterating\n \nvariable\n]\n \nin\n \n[\nnested\n \nloop\n]:\n   \n# Nested loop\n\n        \n[\ndo\n \nsomething\n]\n  \n\n\n\n\n\nThe program first encounters the outer loop, executing its first iteration. This first iteration triggers the inner, nested loop, which then runs to completion. Then the program returns back to the top of the outer loop, completing the second iteration and again triggering the nested loop. Again, the nested loop runs to completion, and the program returns back to the top of the outer loop until the sequence is complete or a break or other statement disrupts the process.\n\n\nLet\u2019s implement a nested for loop so we can take a closer look. In this example, the outer loop will iterate through a list of integers called num_list, and the inner loop will iterate through a list of strings called alpha_list.\n\n\nnum_list\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\nalpha_list\n \n=\n \n[\n'a'\n,\n \n'b'\n,\n \n'c'\n]\n\n\n\nfor\n \nnumber\n \nin\n \nnum_list\n:\n\n    \nprint\n(\nnumber\n)\n\n    \nfor\n \nletter\n \nin\n \nalpha_list\n:\n\n        \nprint\n(\nletter\n)\n\n\n\n\n\n\nWhen we run this program, we\u2019ll receive the following output: \n\n\nOutput\n\n\n1\n\n\na\n\n\nb\n\n\nc\n\n\n2\n\n\na\n\n\nb\n\n\nc\n\n\n3\n\n\na\n\n\nb\n\n\nc\n\n\n\n\n\n\nThe output illustrates that the program completes the first iteration of the outer loop by printing 1, which then triggers completion of the inner loop, printing a, b, c consecutively. Once the inner loop has completed, the program returns to the top of the outer loop, prints 2, then again prints the inner loop in its entirety (a, b, c), etc.\n\n\nNested for loops can be useful for iterating through items within lists composed of lists. In a list composed of lists, if we employ just one for loop, the program will output each internal list as an item:\n\n\nlist_of_lists\n \n=\n \n[[\n'hammerhead'\n,\n \n'great white'\n,\n \n'dogfish'\n],[\n0\n,\n \n1\n,\n \n2\n],[\n9.9\n,\n \n8.8\n,\n \n7.7\n]]\n\n\n\nfor\n \nlist\n \nin\n \nlist_of_lists\n:\n\n    \nprint\n(\nlist\n)\n\n\n\n\n\n\nOutput\n\n\n[\n'hammerhead'\n,\n \n'great white'\n,\n \n'dogfish'\n]\n\n\n[\n0\n,\n \n1\n,\n \n2\n]\n\n\n[\n9.9\n,\n \n8.8\n,\n \n7.7\n]\n\n\n\n\n\n\nIn order to access each individual item of the internal lists, we\u2019ll implement a nested for loop:\n\n\nlist_of_lists\n \n=\n \n[[\n'hammerhead'\n,\n \n'great white'\n,\n \n'dogfish'\n],[\n0\n,\n \n1\n,\n \n2\n],[\n9.9\n,\n \n8.8\n,\n \n7.7\n]]\n\n\n\nfor\n \nlist\n \nin\n \nlist_of_lists\n:\n\n    \nfor\n \nitem\n \nin\n \nlist\n:\n\n        \nprint\n(\nitem\n)\n\n\n\n\n\n\nOutput\n\n\nhammerhead\n\n\ngreat\n \nwhite\n\n\ndogfish\n\n\n0\n\n\n1\n\n\n2\n\n\n9.9\n\n\n8.8\n\n\n7.7\n\n\n\n\n\n\nWhen we utilize a nested for loop we are able to iterate over the individual items contained in the lists.\n\n\nConclusion\n\n\nThis tutorial went over how for loops work in Python and how to construct them. For loops continue to loop through a block of code provided a certain number of times.\n\n\nFrom here, you can continue to learn about looping by reading tutorials on \nwhile\n loops and \nbreak, continue, and pass statements.",
            "title": "For Loop"
        },
        {
            "location": "/beginner/For_Loop/#how-to-construct-for-loops-in-python-3",
            "text": "Using loops in computer programming allows us to automate and repeat similar tasks multiple times. In this tutorial, we\u2019ll be covering Python\u2019s for loop.  A for loop implements the repeated execution of code based on a loop counter or loop variable. This means that for loops are used most often when the number of iterations is known before entering the loop, unlike while loops which are conditionally based.",
            "title": "How To Construct For Loops in Python 3"
        },
        {
            "location": "/beginner/For_Loop/#for-loops",
            "text": "In Python, for loops are constructed like so:    for   [ iterating   variable ]   in   [ sequence ]: \n     [ do   something ]   The something that is being done will be executed until the sequence is over.    Let\u2019s look at a for loop that iterates through a range of values:    for   i   in   range ( 0 , 5 ): \n    print ( i )   When we run this program, the output looks like this:  Output  0  1  2  3  4   This for loop sets up i as its iterating variable, and the sequence exists in the range of 0 to 5.    Then within the loop we print out one integer per loop iteration. Keep in mind that in programming we tend to begin at index 0, so that is why although 5 numbers are printed out, they range from 0-4.    You\u2019ll commonly see and use for loops when a program needs to repeat a block of code a number of times.",
            "title": "For Loops"
        },
        {
            "location": "/beginner/For_Loop/#for-loops-using-range",
            "text": "One of Python\u2019s built-in immutable sequence types is range(). In loops, range() is used to control how many times the loop will be repeated. \nWhen working with range(), you can pass between 1 and 3 integer arguments to it:     start states the integer value at which the sequence begins, if this is not included then start begins at 0  stop is always required and is the integer that is counted up to but not included  step sets how much to increase (or decrease in the case of negative numbers) the next iteration, if this is omitted then step defaults to 1   We\u2019ll look at some examples of passing different arguments to  range() .  First, let\u2019s only pass the stop argument, so that our sequence set up is  range(stop) :  for   i   in   range ( 6 ): \n    print ( i )   In the program above, the stop argument is 6, so the code will iterate from 0-6 (exclusive of 6):  Output  0  1  2  3  4  5   Next, we\u2019ll look at range(start, stop), with values passed for when the iteration should start and for when it should stop:    for   i   in   range ( 20 , 25 ): \n    print ( i )   Here, the range goes from 20 (inclusive) to 25 (exclusive), so the output looks like this:    Output  20  21  22  23  24   The step argument of range() is similar to specifying stride while slicing strings in that it can be used to skip values within the sequence.  With all three arguments, step comes in the final position: range(start, stop, step). First, let\u2019s use a step with a positive value:    for   i   in   range ( 0 , 15 , 3 ): \n    print ( i )   In this case, the for loop is set up so that the numbers from 0 to 15 print out, but at a step of 3, so that only every third number is printed, like so:  Output  0  3  6  9  12   We can also use a negative value for our step argument to iterate backwards, but we\u2019ll have to adjust our start and stop arguments accordingly:    for   i   in   range ( 100 , 0 , - 10 ): \n    print ( i )   Here, 100 is the start value, 0 is the stop value, and -10 is the range, so the loop begins at 100 and ends at 0, decreasing by 10 with each iteration. We can see this occur in the output:  Output  100  90  80  70  60  50  40  30  20  10   When programming in Python,  for  loops often make use of the range() sequence type as its parameters for iteration.",
            "title": "For Loops using range()"
        },
        {
            "location": "/beginner/For_Loop/#for-loops-using-sequential-data-types",
            "text": "Lists and other data sequence types can also be leveraged as iteration parameters in for loops. Rather than iterating through a range(), you can define a list and iterate through that list.  We\u2019ll assign a list to a variable, and then iterate through the list:   sharks   =   [ 'hammerhead' ,   'great white' ,   'dogfish' ,   'frilled' ,   'bullhead' ,   'requiem' ]  for   shark   in   sharks : \n    print ( shark )   In this case, we are printing out each item in the list. Though we used the variable shark, we could have called the variable any other valid variable name and we would get the same output:  Output  hammerhead  great   white  dogfish  frilled  bullhead  requiem   The output above shows that the for loop iterated through the list, and printed each item from the list per line.  Lists and other sequence-based data types like strings and tuples are common to use with loops because they are iterable. You can combine these data types with range() to add items to a list, for example:  sharks   =   [ 'hammerhead' ,   'great white' ,   'dogfish' ,   'frilled' ,   'bullhead' ,   'requiem' ]  for   item   in   range ( len ( sharks )): \n    sharks . append ( 'shark' )  print ( sharks )   Output  [ 'hammerhead' ,   'great white' ,   'dogfish' ,   'frilled' ,   'bullhead' ,   'requiem' ,   'shark' ,   'shark' ,   'shark' ,   'shark' ,   'shark' ,   'shark' ]   Here, we have added a placeholder string of 'shark' for each item of the length of the sharks list.  You can also use a for loop to construct a list from scratch:  integers   =   []  for   i   in   range ( 10 ): \n    integers . append ( i )  print ( integers )   In this example, the list integers is initialized empty, but the for loop populates the list like so:  Output  [ 0 ,   1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ]   Similarly, we can iterate through strings:  sammy   =   'Sammy'  for   letter   in   sammy : \n    print ( letter )   Output  S  a  m  m  y   Iterating through tuples is done in the same format as iterating through lists or strings above.  When iterating through a dictionary, it\u2019s important to keep the key : value structure in mind to ensure that you are calling the correct element of the dictionary. Here is an example that calls both the key and the value:  sammy_shark   =   { 'name' :   'Sammy' ,   'animal' :   'shark' ,   'color' :   'blue' ,   'location' :   'ocean' }  for   key   in   sammy_shark : \n    print ( key   +   ': '   +   sammy_shark [ key ])   Output  name :   Sammy  animal :   shark  location :   ocean  color :   blue   When using dictionaries with for loops, the iterating variable corresponds to the keys of the dictionary, and dictionary_variable[iterating_variable] corresponds to the values. In the case above, the iterating variable key was used to stand for key, and sammy_shark[key] was used to stand for the values.  Loops are often used to iterate and manipulate sequential data types.",
            "title": "For Loops using Sequential Data Types"
        },
        {
            "location": "/beginner/For_Loop/#nested-for-loops",
            "text": "Loops can be nested in Python, as they can with other programming languages.  A nested loop is a loop that occurs within another loop, structurally similar to nested if statements. These are constructed like so:   for   [ first   iterating   variable ]   in   [ outer   loop ]:   # Outer loop \n     [ do   something ]    # Optional \n     for   [ second   iterating   variable ]   in   [ nested   loop ]:     # Nested loop \n         [ do   something ]     The program first encounters the outer loop, executing its first iteration. This first iteration triggers the inner, nested loop, which then runs to completion. Then the program returns back to the top of the outer loop, completing the second iteration and again triggering the nested loop. Again, the nested loop runs to completion, and the program returns back to the top of the outer loop until the sequence is complete or a break or other statement disrupts the process.  Let\u2019s implement a nested for loop so we can take a closer look. In this example, the outer loop will iterate through a list of integers called num_list, and the inner loop will iterate through a list of strings called alpha_list.  num_list   =   [ 1 ,   2 ,   3 ]  alpha_list   =   [ 'a' ,   'b' ,   'c' ]  for   number   in   num_list : \n     print ( number ) \n     for   letter   in   alpha_list : \n         print ( letter )   When we run this program, we\u2019ll receive the following output:   Output  1  a  b  c  2  a  b  c  3  a  b  c   The output illustrates that the program completes the first iteration of the outer loop by printing 1, which then triggers completion of the inner loop, printing a, b, c consecutively. Once the inner loop has completed, the program returns to the top of the outer loop, prints 2, then again prints the inner loop in its entirety (a, b, c), etc.  Nested for loops can be useful for iterating through items within lists composed of lists. In a list composed of lists, if we employ just one for loop, the program will output each internal list as an item:  list_of_lists   =   [[ 'hammerhead' ,   'great white' ,   'dogfish' ],[ 0 ,   1 ,   2 ],[ 9.9 ,   8.8 ,   7.7 ]]  for   list   in   list_of_lists : \n     print ( list )   Output  [ 'hammerhead' ,   'great white' ,   'dogfish' ]  [ 0 ,   1 ,   2 ]  [ 9.9 ,   8.8 ,   7.7 ]   In order to access each individual item of the internal lists, we\u2019ll implement a nested for loop:  list_of_lists   =   [[ 'hammerhead' ,   'great white' ,   'dogfish' ],[ 0 ,   1 ,   2 ],[ 9.9 ,   8.8 ,   7.7 ]]  for   list   in   list_of_lists : \n     for   item   in   list : \n         print ( item )   Output  hammerhead  great   white  dogfish  0  1  2  9.9  8.8  7.7   When we utilize a nested for loop we are able to iterate over the individual items contained in the lists.",
            "title": "Nested For Loops"
        },
        {
            "location": "/beginner/For_Loop/#conclusion",
            "text": "This tutorial went over how for loops work in Python and how to construct them. For loops continue to loop through a block of code provided a certain number of times.  From here, you can continue to learn about looping by reading tutorials on  while  loops and  break, continue, and pass statements.",
            "title": "Conclusion"
        },
        {
            "location": "/beginner/Functions/",
            "text": "Function Calls\n\n\nIn the context of programming, a function is a named sequence of statements that\nperforms a computation. When you define a function, you specify the name and the\nsequence of statements. Later, you can \u201ccall\u201d the function by name. We have already seen\none example of a function call:\n\n\n>>>\n \ntype\n(\n32\n)\n\n\n<\ntype\n \n'int'\n>\n\n\n\n\n\n\nThe name of the function is type. The expression in parentheses is called the argument\nof the function. The result, for this function, is the type of the argument.\n\nIt is common to say that a function \u201ctakes\u201d an argument and \u201creturns\u201d a result. The result\nis called the return value.\n\n\nType Conversion Functions\n\n\nPython provides built-in functions that convert values from one type to another. The\nint function takes any value and converts it to an integer, if it can, or complains\notherwise:\n\n\n>>>\n \nint\n(\n'32'\n)\n\n\n32\n\n\n>>>\n \nint\n(\n'Hello'\n)\n\n\nValueError\n:\n \ninvalid\n \nliteral\n \nfor\n \nint\n():\n \nHello\n\n\n\n\n\n\nint can convert floating-point values to integers, but it doesn\u2019t round off; it chops off\nthe fraction part:\n\n\n>>>\n \nint\n(\n3.99999\n)\n\n\n3\n\n\n>>>\n \nint\n(\n-\n2.3\n)\n\n\n-\n2\n\n\n\n\n\n\nfloat converts integers and strings to floating-point numbers:\n\n\n>>>\n \nfloat\n(\n32\n)\n\n\n32.0\n\n\n>>>\n \nfloat\n(\n'3.14159'\n)\n\n\n3.14159\n\n\n\n\n\n\nFinally, str converts its argument to a string:\n\n\n>>>\n \nstr\n(\n32\n)\n\n\n'32'\n\n\n>>>\n \nstr\n(\n3.14159\n)\n\n\n'3.14159'\n\n\n\n\n\n\nAdding New Functions\n\n\nSo far, we have only been using the functions that come with Python, but it is also possible\nto add new functions. A function definition specifies the name of a new function and\nthe sequence of statements that execute when the function is called.\n\nHere is an example:\n\n\ndef\n \nprint_lyrics\n():\n\n    \nprint\n \n\"I'm a lumberjack, and I'm okay.\"\n\n    \nprint\n \n\"I sleep all night and I work all day.\"\n\n\n\n\n\n\ndef\n is a keyword that indicates that this is a function definition. The name of the function\nis print_lyrics. The rules for function names are the same as for variable names: letters,\nnumbers and some punctuation marks are legal, but the first character can\u2019t be a number.\nYou can\u2019t use a keyword as the name of a function, and you should avoid having a variable\nand a function with the same name.\n\nThe empty parentheses after the name indicate that this function doesn\u2019t take any\narguments.\n\nThe first line of the function definition is called the header; the rest is called the body.\nThe header has to end with a colon and the body has to be indented. By convention, the\nindentation is always four spaces; see \u201cDebugging\u201d (page 33). The body can contain any\nnumber of statements.\n\nThe strings in the print statements are enclosed in double quotes. Single quotes and\ndouble quotes do the same thing; most people use single quotes except in cases like this\nwhere a single quote (which is also an apostrophe) appears in the string.\nIf you type a function definition in interactive mode, the interpreter prints ellipses (...)\nto let you know that the definition isn\u2019t complete:\n\n\ndef\n \nprint_lyrics\n():\n\n    \nprint\n \n\"I'm a lumberjack, and I'm okay.\"\n\n    \nprint\n \n\"I sleep all night and I work all day.\"\n\n\n\n\n\n\nTo end the function, you have to enter an empty line (this is not necessary in a script).\nDefining a function creates a variable with the same name.\n\n\n>>>\n \nprint\n \nprint_lyrics\n\n\n<\nfunction\n \nprint_lyrics\n \nat\n \n0xb7e99e9c\n>\n\n\n>>>\n \ntype\n(\nprint_lyrics\n)\n\n\n<\ntype\n \n'function'\n>\n\n\n\n\n\n\nThe value of print_lyrics is a function object, which has type 'function'.\nThe syntax for calling the new function is the same as for built-in functions:\n\n\n>>>\n \nprint_lyrics\n()\n\n\nI\n'm a lumberjack, and I'\nm\n \nokay\n.\n\n\nI\n \nsleep\n \nall\n \nnight\n \nand\n \nI\n \nwork\n \nall\n \nday\n.\n\n\n\n\n\n\nOnce you have defined a function, you can use it inside another function. For example,\nto repeat the previous refrain, we could write a function called repeat_lyrics:  \n\n\ndef\n \nrepeat_lyrics\n():\n\n    \nprint_lyrics\n()\n\n    \nprint_lyrics\n()\n\n\n\n\n\n\nAnd then call repeat_lyrics:  \n\n\n>>>\n \nrepeat_lyrics\n()\n\n\nI\n'm a lumberjack, and I'\nm\n \nokay\n.\n\n\nI\n \nsleep\n \nall\n \nnight\n \nand\n \nI\n \nwork\n \nall\n \nday\n.\n\n\nI\n'm a lumberjack, and I'\nm\n \nokay\n.\n\n\nI\n \nsleep\n \nall\n \nnight\n \nand\n \nI\n \nwork\n \nall\n \nday\n.\n\n\n\n\n\n\nBut that\u2019s not really how the song goes.\n\n\nDefinitions and Uses\n\n\nPulling together the code fragments from the previous section, the whole program looks\nlike this:\n\n\ndef\n \nprint_lyrics\n():\n\n    \nprint\n \n\"I'm a lumberjack, and I'm okay.\"\n\n    \nprint\n \n\"I sleep all night and I work all day.\"\n\n\ndef\n \nrepeat_lyrics\n():\n\n    \nprint_lyrics\n()\n\n    \nprint_lyrics\n()\n  \n\n\nrepeat_lyrics\n()\n\n\n\n\n\n\nThis program contains two function definitions: print_lyrics and repeat_lyrics.\nFunction definitions get executed just like other statements, but the result creates func\ntion objects. The statements inside the function do not get executed until the function\nis called, and the function definition generates no output.\n\nAs you might expect, you have to create a function before you can execute it. In other\nwords, the function definition has to be executed before the function is called the first\ntime.  \n\n\nFlow of Execution\n\n\nIn order to ensure that a function is defined before its first use, you have to know the\norder in which statements are executed, which is called the flow of execution.\n\nExecution always begins at the first statement of the program. Statements are executed\none at a time, in order, from top to bottom.\n\n\nFunction definitions do not alter the flow of execution of the program, but remember\nthat statements inside the function are not executed until the function is called.\nA function call is like a detour in the flow of execution. Instead of going to the next\nstatement, the flow jumps to the body of the function, executes all the statements there,\nand then comes back to pick up where it left off.\n\nThat sounds simple enough, until you remember that one function can call another.\nWhile in the middle of one function, the program might have to execute the statements\nin another function. But while executing that new function, the program might have to\nexecute yet another function!\n\nFortunately, Python is good at keeping track of where it is, so each time a function\ncompletes, the program picks up where it left off in the function that called it. When it\ngets to the end of the program, it terminates.\n\nWhat\u2019s the moral of this sordid tale? When you read a program, you don\u2019t always want\nto read from top to bottom. Sometimes it makes more sense if you follow the flow of\nexecution.  \n\n\nParameters and Arguments\n\n\nSome of the built-in functions we have seen require arguments. For example, when you\ncall math.sin you pass a number as an argument. Some functions take more than one\nargument: \nmath.pow\n takes two, the base and the exponent.\nInside the function, the arguments are assigned to variables called parameters. Here is\nan example of a user-defined function that takes an argument:\n\n\n \ndef\n \nprint_twice\n(\nbruce\n):\n\n    \nprint\n \nbruce\n\n    \nprint\n \nbruce\n\n\n\n\n\n\nThis function assigns the argument to a parameter named bruce. When the function is\ncalled, it prints the value of the parameter (whatever it is) twice.\n\nThis function works with any value that can be printed.\n\n\n>>>\n \nprint_twice\n(\n'Spam'\n)\n\n\nSpam\n\n\nSpam\n\n\n>>>\n \nprint_twice\n(\n17\n)\n\n\n17\n\n\n17\n\n\n>>>\n \nprint_twice\n(\nmath\n.\npi\n)\n\n\n3.14159265359\n\n\n3.14159265359\n \n\n\n\n\n\nThe same rules of composition that apply to built-in functions also apply to user-defined\nfunctions, so we can use any kind of expression as an argument for \nprint_twice\n:\n\n\n>>>\n \nprint_twice\n(\n'Spam '\n*\n4\n)\n\n\nSpam\n \nSpam\n \nSpam\n \nSpam\n\n\nSpam\n \nSpam\n \nSpam\n \nSpam\n\n\n>>>\n \nprint_twice\n(\nmath\n.\ncos\n(\nmath\n.\npi\n))\n\n\n-\n1.0\n\n\n-\n1.0\n\n\n\n\n\n\nThe argument is evaluated before the function is called, so in the examples the expres\nsions 'Spam '*4 and math.cos(math.pi) are only evaluated once.\n\nYou can also use a variable as an argument:\n\n\n>>>\n \nmichael\n \n=\n \n'Eric, the half a bee.'\n\n\n>>>\n \nprint_twice\n(\nmichael\n)\n\n\nEric\n,\n \nthe\n \nhalf\n \na\n \nbee\n.\n\n\nEric\n,\n \nthe\n \nhalf\n \na\n \nbee\n.\n\n\n\n\n\n\nThe name of the variable we pass as an argument (michael) has nothing to do with the\nname of the parameter (bruce). It doesn\u2019t matter what the value was called back home\n(in the caller); here in print_twice, we call everybody bruce.\n\n\nVariables and Parameters Are Local\n\n\nWhen you create a variable inside a function, it is local, which means that it only exists\ninside the function. For example:\n\n\ndef\n \ncat_twice\n(\npart1\n,\n \npart2\n):\n\n    \ncat\n \n=\n \npart1\n \n+\n \npart2\n\n    \nprint_twice\n(\ncat\n)\n\n\n\n\n\n\nThis function takes two arguments, concatenates them, and prints the result twice. Here\nis an example that uses it:\n\n\n>>>\n \nline1\n \n=\n \n'Bing tiddle '\n\n\n>>>\n \nline2\n \n=\n \n'tiddle bang.'\n\n\n>>>\n \ncat_twice\n(\nline1\n,\n \nline2\n)\n\n\nBing\n \ntiddle\n \ntiddle\n \nbang\n.\n\n\nBing\n \ntiddle\n \ntiddle\n \nbang\n.\n\n\n\n\n\n\nWhen cat_twice terminates, the variable cat is destroyed. If we try to print it, we get\nan exception:\n\n\n>>>\n \nprint\n \ncat\n\n\nNameError\n:\n \nname\n \n'cat'\n \nis\n \nnot\n \ndefined\n\n\n\n\n\n\nParameters are also local. For example, outside print_twice, there is no such thing as\nbruce.\n\n\nStack Diagrams\n\n\nTo keep track of which variables can be used where, it is sometimes useful to draw a\nstack diagram. Like state diagrams, stack diagrams show the value of each variable, but\nthey also show the function each variable belongs to.\n\nEach function is represented by a frame. A frame is a box with the name of a function\nbeside it and the parameters and variables of the function inside it. The stack diagram\nfor the previous example is shown in Figure 3-1.\n\n\n\n\nThe frames are arranged in a stack that indicates which function called which, and so\non. In this example, print_twice was called by cat_twice, and cat_twice was called\nby \n\\__main\\__\n, which is a special name for the topmost frame. When you create a variable\noutside of any function, it belongs to \n\\__main\\__\n.\n\n\nEach parameter refers to the same value as its corresponding argument. So, part1 has\nthe same value as line1, part2 has the same value as line2, and bruce has the same\nvalue as cat.\nIf an error occurs during a function call, Python prints the name of the function, and\nthe name of the function that called it, and the name of the function that called that, all\nthe way back to \n\\__main__\\\n.\n\n\nFor example, if you try to access cat from within print_twice, you get a NameError:\n\n\nTraceback\n \n(\ninnermost\n \nlast\n):\n\n    \nFile\n \n\"test.py\"\n,\n \nline\n \n13\n,\n \nin\n \n__main__\n\n        \ncat_twice\n(\nline1\n,\n \nline2\n)\n\n    \nFile\n \n\"test.py\"\n,\n \nline\n \n5\n,\n \nin\n \ncat_twice\n\n        \nprint_twice\n(\ncat\n)\n\n    \nFile\n \n\"test.py\"\n,\n \nline\n \n9\n,\n \nin\n \nprint_twice\n\n        \nprint\n \ncat\n\n    \nNameError\n:\n \nname\n \n'cat'\n \nis\n \nnot\n \ndefined\n\n\n\n\n\n\nThis list of functions is called a traceback. It tells you what program file the error oc\ncurred in, and what line, and what functions were executing at the time. It also shows\nthe line of code that caused the error.\nThe order of the functions in the traceback is the same as the order of the frames in the\nstack diagram. The function that is currently running is listed at the bottom.\n\n\nFruitful Functions and Void Functions\n\n\nSome of the functions we are using, such as the math functions, yield results; for lack of\na better name, I call them fruitful functions. Other functions, like print_twice, per\nform an action but don\u2019t return a value. They are called void functions.\nWhen you call a fruitful function, you almost always want to do something with the\nresult; for example, you might assign it to a variable or use it as part of an expression:\n\n\nx\n \n=\n \nmath\n.\ncos\n(\nradians\n)\n\n\ngolden\n \n=\n \n(\nmath\n.\nsqrt\n(\n5\n)\n \n+\n \n1\n)\n \n/\n \n2\n\n\n\n\n\n\nWhen you call a function in interactive mode, Python displays the result:\n\n\n>>>\n \nmath\n.\nsqrt\n(\n5\n)\n\n\n2.2360679774997898\n\n\n\n\n\n\nBut in a script, if you call a fruitful function all by itself, the return value is lost forever!\n\n\nmath\n.\nsqrt\n(\n5\n)\n\n\n\n\n\n\nThis script computes the square root of 5, but since it doesn\u2019t store or display the result,\nit is not very useful.\nVoid functions might display something on the screen or have some other effect, but\nthey don\u2019t have a return value. If you try to assign the result to a variable, you get a special\nvalue called None.\n\n\n>>>\n \nresult\n \n=\n \nprint_twice\n(\n'Bing'\n)\n\n\nBing\n\n\nBing\n\n\n>>>\n \nprint\n \nresult\n\n\nNone\n\n\n\n\n\n\nThe value None is not the same as the string 'None'. It is a special value that has its own\ntype:\n\n\n>>>\n \nprint\n \ntype\n(\nNone\n)\n\n\n<\ntype\n \n'NoneType'\n>\n\n\n\n\n\n\nThe functions we have written so far are all void. We will start writing fruitful functions\nin a few chapters.\n\n\nWhy Functions?\n\n\nIt may not be clear why it is worth the trouble to divide a program into functions. There\nare several reasons:\n\n- Creating a new function gives you an opportunity to name a group of statements,\nwhich makes your program easier to read and debug.\n- Functions can make a program smaller by eliminating repetitive code. Later, if you\nmake a change, you only have to make it in one place.\n- Dividing a long program into functions allows you to debug the parts one at a time\nand then assemble them into a working whole.\n- Well-designed functions are often useful for many programs. Once you write and\ndebug one, you can reuse it.\n\n\n\n\nSource:\n \n\n\n  \nThink Python\n by Allen B. Downey  - 2012\n\n\n\n\nFunctions by by Mark Lutz (Learning Python, Fourth Edition)\n\n\nFunction Basics\n\n\nIn Part III, we looked at basic procedural statements in Python. Here, we\u2019ll move on to\nexplore a set of additional statements that we can use to create functions of our own.\n\nIn simple terms, a function is a device that groups a set of statements so they can be run\nmore than once in a program. Functions also can compute a result value and let us\nspecify parameters that serve as function inputs, which may differ each time the code\nis run. Coding an operation as a function makes it a generally useful tool, which we\ncan use in a variety of contexts.\n\nMore fundamentally, functions are the alternative to programming by cutting and\npasting\u2014rather than having multiple redundant copies of an operation\u2019s code, we can\nfactor it into a single function. In so doing, we reduce our future work radically: if the\noperation must be changed later, we only have one copy to update, not many.\n\nFunctions are the most basic program structure Python provides for maximizing code\nreuse and minimizing code redundancy. As we\u2019ll see, functions are also a design tool\nthat lets us split complex systems into manageable parts. Table 16-1 summarizes the\nprimary function-related tools we\u2019ll study in this part of the book.\n\n\n\n\n\n\n\n\nStatement\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\nCalls\n\n\nmyfunc('spam', 'eggs', meat=ham)\n\n\n\n\n\n\ndef, return\n\n\ndef adder(a, b=1, *c): return a + b + c[0]\n\n\n\n\n\n\nglobal\n\n\ndef changer():global x; x = 'new'\n\n\n\n\n\n\nnonlocal\n\n\ndef changer():nonlocal x; x = 'new'\n\n\n\n\n\n\nyield\n\n\ndef squares(x):for i in range(x): yield i ** 2\n\n\n\n\n\n\nlambda\n\n\nfuncs = [lambda x: x*\n2, lambda x: x\n3]\n\n\n\n\n\n\n\n\nWhy Use Functions?\n\n\nBefore we get into the details, let\u2019s establish a clear picture of what functions are all\nabout. Functions are a nearly universal program-structuring device. You may have\ncome across them before in other languages, where they may have been called subroutines\nor procedures. As a brief introduction, functions serve two primary development\nroles:\n\n\nMaximizing code reuse and minimizing redundancy\n\nAs in most programming languages, Python functions are the simplest way to\npackage logic you may wish to use in more than one place and more than one time.\nUp until now, all the code we\u2019ve been writing has run immediately. Functions allow\nus to group and generalize code to be used arbitrarily many times later. Because\nthey allow us to code an operation in a single place and use it in many places,\nPython functions are the most basic factoring tool in the language: they allow us\nto reduce code redundancy in our programs, and thereby reduce maintenance\neffort.  \n\n\nProcedural decomposition\n\nFunctions also provide a tool for splitting systems into pieces that have well-defined\nroles. For instance, to make a pizza from scratch, you would start by mixing the\ndough, rolling it out, adding toppings, baking it, and so on. If you were programming\na pizza-making robot, functions would help you divide the overall \u201cmake\npizza\u201d task into chunks\u2014one function for each subtask in the process. It\u2019s easier\nto implement the smaller tasks in isolation than it is to implement the entire process\nat once. In general, functions are about procedure\u2014how to do something, rather\nthan what you\u2019re doing it to. We\u2019ll see why this distinction matters in Part VI, when\nwe start making new object with classes.  \n\n\n\n\nIn this part of the book, we\u2019ll explore the tools used to code functions in Python: function\nbasics, scope rules, and argument passing, along with a few related concepts such\nas generators and functional tools. Because its importance begins to become more apparent\nat this level of coding, we\u2019ll also revisit the notion of polymorphism introduced\nearlier in the book. As you\u2019ll see, functions don\u2019t imply much new syntax, but they do\nlead us to some bigger programming ideas.\n\n\nCoding Functions\n\n\nAlthough it wasn\u2019t made very formal, we\u2019ve already used some functions in earlier\nchapters. For instance, to make a file object, we called the built-in open function; similarly,\nwe used the len built-in function to ask for the number of items in a collection\nobject.\n\nIn this chapter, we will explore how to write new functions in Python. Functions we\nwrite behave the same way as the built-ins we\u2019ve already seen: they are called in expressions, are passed values, and return results. But writing new functions requires\nthe application of a few additional ideas that haven\u2019t yet been introduced. Moreover,\nfunctions behave very differently in Python than they do in compiled languages like C.\nHere is a brief introduction to the main concepts behind Python functions, all of which\nwe will study in this part of the book:  \n\n\n\n\ndef is executable code.\n Python functions are written with a new statement, the\ndef. Unlike functions in compiled languages such as C, def is an executable statement\u2014\nyour function does not exist until Python reaches and runs the def. In fact,\nit\u2019s legal (and even occasionally useful) to nest def statements inside if statements,\nwhile loops, and even other defs. In typical operation, def statements are coded in\nmodule files and are naturally run to generate functions when a module file is first\nimported.\n\n\n\n\ndef creates an object and assigns it to a name.\n When Python reaches and runs\na def statement, it generates a new function object and assigns it to the function\u2019s\nname. As with all assignments, the function name becomes a reference to the function\nobject. There\u2019s nothing magic about the name of a function\u2014as you\u2019ll see,\nthe function object can be assigned to other names, stored in a list, and so on.\nFunction objects may also have arbitrary user-defined attributes attached to them\nto record data.\n\n\n\n\n\n\nlambda creates an object but returns it as a result.\n Functions may also be created\nwith the lambda expression, a feature that allows us to in-line function definitions\nin places where a def statement won\u2019t work syntactically\n\n\n\n\n\n\nreturn sends a result object back to the caller.\n When a function is called, the\ncaller stops until the function finishes its work and returns control to the caller.\nFunctions that compute a value send it back to the caller with a return statement;\nthe returned value becomes the result of the function call.\n\n\n\n\n\n\nyield sends a result object back to the caller, but remembers where it left\noff.\n Functions known as generators may also use the yield statement to send back\na value and suspend their state such that they may be resumed later, to produce a\nseries of results over time. This is another advanced topic covered later in this part\nof the book.\n\n\n\n\n\n\nglobal declares module-level variables that are to be assigned.\n By default, all\nnames assigned in a function are local to that function and exist only while the\nfunction runs. To assign a name in the enclosing module, functions need to list it\nin a global statement. More generally, names are always looked up in scopes\u2014\nplaces where variables are stored\u2014and assignments bind names to scopes.\n\n\n\n\n\n\nnonlocal declares enclosing function variables that are to be assigned.\n Similarly,\nthe nonlocal statement added in Python 3.0 allows a function to assign a\nname that exists in the scope of a syntactically enclosing def statement. This allows\nenclosing functions to serve as a place to retain state\u2014information remembered\nwhen a function is called\u2014without using shared global names.\n\n\n\n\n\n\nArguments are passed by assignment (object reference).\n In Python, arguments\nare passed to functions by assignment (which, as we\u2019ve learned, means by object\nreference). As you\u2019ll see, in Python\u2019s model the caller and function share objects\nby references, but there is no name aliasing. Changing an argument name within\na function does not also change the corresponding name in the caller, but changing\npassed-in mutable objects can change objects shared by the caller.\n\n\n\n\n\n\nArguments, return values, and variables are not declared.\n As with everything\nin Python, there are no type constraints on functions. In fact, nothing about a\nfunction needs to be declared ahead of time: you can pass in arguments of any type,\nreturn any kind of object, and so on. As one consequence, a single function can\noften be applied to a variety of object types\u2014any objects that sport a compatible\ninterface (methods and expressions) will do, regardless of their specific types.\n\n\n\n\n\n\nIf some of the preceding words didn\u2019t sink in, don\u2019t worry\u2014we\u2019ll explore all of these\nconcepts with real code in this part of the book. Let\u2019s get started by expanding on some\nof these ideas and looking at a few examples.\n\n\ndef Statements\n\n\nThe def statement creates a function object and assigns it to a name. Its general format\nis as follows:\n\n\ndef\n \n<\nname\n>\n(\narg1\n,\n \narg2\n,\n...\n \nargN\n):\n\n    \n<\nstatements\n>\n\n\n\n\n\n\nAs with all compound Python statements, def consists of a header line followed by a\nblock of statements, usually indented (or a simple statement after the colon). The\nstatement block becomes the function\u2019s body\u2014that is, the code Python executes each\ntime the function is called.\n\nThe def header line specifies a function name that is assigned the function object, along\nwith a list of zero or more arguments (sometimes called parameters) in parentheses.\nThe argument names in the header are assigned to the objects passed in parentheses at\nthe point of call.\n\n\nFunction bodies often contain a return statement:\n\n\ndef\n \n<\nname\n>\n(\narg1\n,\n \narg2\n,\n...\n \nargN\n):\n\n    \n...\n\n    \nreturn\n \n<\nvalue\n>\n\n\n\n\n\n\nThe Python return statement can show up anywhere in a function body; it ends the\nfunction call and sends a result back to the caller. The return statement consists of an\nobject expression that gives the function\u2019s result. The return statement is optional; if\nit\u2019s not present, the function exits when the control flow falls off the end of the function\nbody. Technically, a function without a return statement returns the None object automatically,\nbut this return value is usually ignored.\n\n\ndef Executes at Runtime\n\n\nThe Python def is a true executable statement: when it runs, it creates a new function\nobject and assigns it to a name. (Remember, all we have in Python is runtime; there is\nno such thing as a separate compile time.) Because it\u2019s a statement, a def can appear\nanywhere a statement can\u2014even nested in other statements. For instance, although\ndefs normally are run when the module enclosing them is imported, it\u2019s also completely\nlegal to nest a function def inside an if statement to select between alternative\ndefinitions:\n\n\nif\n \ntest\n:\n\n    \ndef\n \nfunc\n():\n \n# Define func this way\n\n\n...\n\n\nelse\n:\n\n    \ndef\n \nfunc\n():\n \n# Or else this way\n\n    \n...\n\n    \n...\n\n\nfunc\n()\n \n# Call the version selected and built\n\n\n\n\n\n\nOne way to understand this code is to realize that the def is much like an = statement:\nit simply assigns a name at runtime. Unlike in compiled languages such as C, Python\nfunctions do not need to be fully defined before the program runs. More generally,\ndefs are not evaluated until they are reached and run, and the code inside defs is not\nevaluated until the functions are later called.\nBecause function definition happens at runtime, there\u2019s nothing special about the\nfunction name. What\u2019s important is the object to which it refers:  \n\n\nothername\n \n=\n \nfunc\n \n# Assign function object\n\n\nothername\n()\n \n# Call func again\n\n\n\n\n\n\nHere, the function was assigned to a different name and called through the new name.\nLike everything else in Python, functions are just objects; they are recorded explicitly\nin memory at program execution time. In fact, besides calls, functions allow arbitrary\nattributes to be attached to record information for later use:\n\n\ndef\n \nfunc\n():\n \n...\n \n# Create function object\n\n\nfunc\n()\n \n# Call object\n\n\nfunc\n.\nattr\n \n=\n \nvalue\n \n# Attach attributes\n\n\n\n\n\n\nA First Example: Definitions and Calls\n\n\nApart from such runtime concepts (which tend to seem most unique to programmers\nwith backgrounds in traditional compiled languages), Python functions are straightforward\nto use. Let\u2019s code a first real example to demonstrate the basics. As you\u2019ll see,\nthere are two sides to the function picture: a definition (the def that creates a function)\nand a call (an expression that tells Python to run the function\u2019s body).\n\n\nDefinition\n\n\nHere\u2019s a definition typed interactively that defines a function called times, which returns\nthe product of its two arguments:\n\n\n>>>\n \ndef\n \ntimes\n(\nx\n,\n \ny\n):\n \n# Create and assign function\n\n\n...\n \nreturn\n \nx\n \n*\n \ny\n \n# Body executed when called\n\n\n...\n\n\n\n\n\n\nWhen Python reaches and runs this def, it creates a new function object that packages\nthe function\u2019s code and assigns the object to the name times. Typically, such a statement\nis coded in a module file and runs when the enclosing file is imported; for something\nthis small, though, the interactive prompt suffices.\n\n\nCalls\n\n\nAfter the def has run, you can call (run) the function in your program by adding\nparentheses after the function\u2019s name. The parentheses may optionally contain one or\nmore object arguments, to be passed (assigned) to the names in the function\u2019s header:\n\n\n>>>\n \ntimes\n(\n2\n,\n \n4\n)\n \n# Arguments in parentheses\n\n\n8\n\n\n\n\n\n\nThis expression passes two arguments to times. As mentioned previously, arguments\nare passed by assignment, so in this case the name x in the function header is assigned\nthe value 2, y is assigned the value 4, and the function\u2019s body is run. For this function,\nthe body is just a return statement that sends back the result as the value of the call\nexpression. The returned object was printed here interactively (as in most languages,\n2 * 4 is 8 in Python), but if we needed to use it later we could instead assign it to a\nvariable. For example:\n\n\n>>>\n \nx\n \n=\n \ntimes\n(\n3.14\n,\n \n4\n)\n \n# Save the result object\n\n\n>>>\n \nx\n\n\n12.56\n\n\n\n\n\n\nNow, watch what happens when the function is called a third time, with very different\nkinds of objects passed in:\n\n\n>>>\n \ntimes\n(\n'Ni'\n,\n \n4\n)\n \n# Functions are \"typeless\"\n\n\n'NiNiNiNi'\n\n\n\n\n\n\nThis time, our function means something completely different (Monty Python reference\nagain intended). In this third call, a string and an integer are passed to x and y, instead\nof two numbers. Recall that * works on both numbers and sequences; because we never\ndeclare the types of variables, arguments, or return values in Python, we can use\ntimes to either multiply numbers or repeat sequences.\n\nIn other words, what our times function means and does depends on what we pass into\nit. This is a core idea in Python (and perhaps the key to using the language well), which\nwe\u2019ll explore in the next section.\n\n\n\n\nSource:\n \n\n\n  \nLearning Python, Fourth Edition\n by Mark Lutz  - 2009\n\n\n\n\nHow To Define Functions in Python 3\n\n\nA function is a block of instructions that performs an action and, once defined, can be reused. Functions make code more modular, allowing you to use the same code over and over again.\n\n\nPython has a number of built-in functions that you may be familiar with, including: \n\n\n\n\nprint() which will print an object to the terminal\n\n\nint() which will convert a string or number data type to an integer data type\n\n\nlen() which returns the length of an object\n\n\n\n\nFunction names include parentheses and may include parameters.  \n\n\nIn this tutorial, we\u2019ll go over how to define your own functions to use in your coding projects.\n\n\nDefining a Function\n\n\nLet\u2019s start with turning the classic \u201cHello, World!\u201d program into a function.\n\n\nWe\u2019ll create a new text file in our text editor of choice, and call the program hello.py. Then, we\u2019ll define the function.\n\n\nA function is defined by using the def keyword, followed by a name of your choosing, followed by a set of parentheses which hold any parameters the function will take (they can be empty), and ending with a colon.\n\n\nIn this case, we\u2019ll define a function named hello():\n\n\ndef\n \nhello\n():\n\n\n\n\n\n\nThis sets up the initial statement for creating a function.\n\n\nFrom here, we\u2019ll add a second line with a 4-space indent to provide the instructions for what the function does. In this case, we\u2019ll be printing Hello, World! to the console:\n\n\ndef\n \nhello\n():\n\n    \nprint\n(\n\"Hello, World!\"\n)\n\n\n\n\n\n\nOur function is now fully defined, but if we run the program at this point, nothing will happen since we didn\u2019t call the function.\n\n\nSo, outside of our defined function block, let\u2019s call the function with hello(): \n\n\ndef\n \nhello\n():\n\n    \nprint\n(\n\"Hello, World!\"\n)\n\n\n\nhello\n()\n\n\n\n\n\n\nNow, let\u2019s run the program:\n\n\npython\n \nhello\n.\npy\n\n\n\n\n\n\nYou should receive the following output:\n\n\nHello\n,\n \nWorld\n!\n\n\n\n\n\n\nFunctions can be more complicated than the \nhello()\n function we defined above. For example, we can use for loops, conditional statements, and more within our function block.\n\n\nFor example, the function defined below utilizes a conditional statement to check if the input for the name variable contains a vowel, then uses a \nfor\n loop to iterate over the letters in the \nname\n string.\n\n\n# Define function names()\n\n\ndef\n \nnames\n():\n\n    \n# Set up name variable with input\n\n    \nname\n \n=\n \nstr\n(\ninput\n(\n'Enter your name: '\n))\n\n    \n# Check whether name has a vowel\n\n    \nif\n \nset\n(\n'aeiou'\n)\n.\nintersection\n(\nname\n.\nlower\n()):\n\n        \nprint\n(\n'Your name contains a vowel.'\n)\n\n    \nelse\n:\n\n        \nprint\n(\n'Your name does not contain a vowel.'\n)\n\n\n    \n# Iterate over name\n\n    \nfor\n \nletter\n \nin\n \nname\n:\n\n        \nprint\n(\nletter\n)\n\n\n\n# Call the function\n\n\nnames\n()\n\n\n\n\n\n\nThe \nnames()\n function we defined above sets up a conditional statement and a for loop, showing how code can be organized within a function definition. However, depending on what we intend with our program and how we want to set up our code, we may want to define the conditional statement and the for loop as two separate functions.\n\n\nDefining functions within a program makes our code modular and reusable so that we can call the same functions without rewriting them.\n\n\nWorking with Parameters\n\n\nSo far we have looked at functions with empty parentheses that do not take arguments, but we can define parameters in function definitions within their parentheses.\n\n\nA parameter is a named entity in a function definition, specifying an argument that the function can accept.\n\n\nLet\u2019s create a small program that takes in parameters x, y, and z. We\u2019ll create a function that adds the parameters together in different configurations. The sums of these will be printed by the function. Then we\u2019ll call the function and pass numbers into the function.\n\n\ndef\n \nadd_numbers\n(\nx\n,\n \ny\n,\n \nz\n):\n\n    \na\n \n=\n \nx\n \n+\n \ny\n\n    \nb\n \n=\n \nx\n \n+\n \nz\n\n    \nc\n \n=\n \ny\n \n+\n \nz\n\n    \nprint\n(\na\n,\n \nb\n,\n \nc\n)\n\n\n\nadd_numbers\n(\n1\n,\n \n2\n,\n \n3\n)\n\n\n\n\n\n\nWe passed the number 1 in for the x parameter, 2 in for the y parameter, and 3 in for the z parameter. These values correspond with each parameter in the order they are given.\n\n\nThe program is essentially doing the following math based on the values we passed to the parameters:\n\n\na\n \n=\n \n1\n \n+\n \n2\n\n\nb\n \n=\n \n1\n \n+\n \n3\n\n\nc\n \n=\n \n2\n \n+\n \n3\n\n\n\n\n\n\nThe function also prints a, b, and c, and based on the math above we would expect a to be equal to 3, b to be 4, and c to be 5. Let\u2019s run the program:\n\n\npython\n \nadd_numbers\n.\npy\n\n\nOutput\n \n:\n \n3\n \n4\n \n5\n\n\n\n\n\n\nWhen we pass 1, 2, and 3 as parameters to the add_numbers() function, we receive the expected output.\n\n\nParameters are arguments that are typically defined as variables within function definitions. They can be assigned values when you run the method, passing the arguments into the function.\n\n\nKeyword Arguments\n\n\nIn addition to calling parameters in order, you can use \nkeyword arguments\n in a function call, in which the caller identifies the arguments by the parameter name.\n\n\nWhen you use keyword arguments, you can use parameters out of order because the Python interpreter will use the keywords provided to match the values to the parameters.\n\n\nLet\u2019s create a function that will show us profile information for a user. We\u2019ll pass parameters to it in the form of \nusername\n (intended as a string), and \nfollowers\n (intended as an integer).\n\n\n# Define function with parameters\n\n\ndef\n \nprofile_info\n(\nusername\n,\n \nfollowers\n):\n\n    \nprint\n(\n\"Username: \"\n \n+\n \nusername\n)\n\n    \nprint\n(\n\"Followers: \"\n \n+\n \nstr\n(\nfollowers\n))\n \n\n\n\n\n\nWithin the function definition statement, \nusername\n and \nfollowers\n are contained in the parentheses of the profile_info() function. The block of the function prints out information about the user as strings, making use of the two parameters.\n\n\nNow, we can call the function and assign parameters to it:\n\n\ndef\n \nprofile_info\n(\nusername\n,\n \nfollowers\n):\n\n    \nprint\n(\n\"Username: \"\n \n+\n \nusername\n)\n\n    \nprint\n(\n\"Followers: \"\n \n+\n \nstr\n(\nfollowers\n))\n\n\n\n# Call function with parameters assigned as above\n\n\nprofile_info\n(\n\"sammyshark\"\n,\n \n945\n)\n\n\n\n# Call function with keyword arguments\n\n\nprofile_info\n(\nusername\n=\n\"AlexAnglerfish\"\n,\n \nfollowers\n=\n342\n)\n\n\n\n\n\n\nIn the first function call, we have filled in the information with a username of sammyshark and followers being 945, in the second function call we used keyword arguments, assigning values to the argument variables.\n\n\nLet\u2019s run the program:\n\n\npython\n \nprofile\n.\npy\n\n\nOutput\n \n:\n \n\nUsername\n:\n \nsammyshark\n\n\nFollowers\n:\n \n945\n\n\nUsername\n:\n \nAlexAnglerfish\n\n\nFollowers\n:\n \n342\n\n\n\n\n\n\nThe output shows us the usernames and numbers of followers for both users.\n\n\nThis also permits us to modify the order of the parameters, as in this example of the same program with a different call:\n\n\ndef\n \nprofile_info\n(\nusername\n,\n \nfollowers\n):\n\n    \nprint\n(\n\"Username: \"\n \n+\n \nusername\n)\n\n    \nprint\n(\n\"Followers: \"\n \n+\n \nstr\n(\nfollowers\n))\n\n\n\n# Change order of parameters\n\n\nprofile_info\n(\nfollowers\n=\n820\n,\n \nusername\n=\n\"cameron-catfish\"\n)\n\n\n\n\n\n\nWhen we run the program again with the python profile.py command, we\u2019ll receive the following output:\n\n\nOutput\n:\n\n\nUsername\n:\n \ncameron\n-\ncatfish\n\n\nFollowers\n:\n \n820\n\n\n\n\n\n\nBecause the function definition maintains the same order of print() statements, if we use keyword arguments, it does not matter which order we pass them into the function call.\n\n\nDefault Argument Values\n\n\nWe can also provide default values for one or both of the parameters. Let\u2019s create a default value for the \nfollowers\n parameter with a value of 1:\n\n\ndef\n \nprofile_info\n(\nusername\n,\n \nfollowers\n=\n1\n):\n\n    \nprint\n(\n\"Username: \"\n \n+\n \nusername\n)\n\n    \nprint\n(\n\"Followers: \"\n \n+\n \nstr\n(\nfollowers\n))\n\n\n\n\n\n\nNow, we can run the function with only the username function assigned, and the number of followers will automatically default to 1. We can also still change the number of followers if we would like.\n\n\ndef\n \nprofile_info\n(\nusername\n,\n \nfollowers\n=\n1\n):\n\n    \nprint\n(\n\"Username: \"\n \n+\n \nusername\n)\n\n    \nprint\n(\n\"Followers: \"\n \n+\n \nstr\n(\nfollowers\n))\n\n\n\nprofile_info\n(\nusername\n=\n\"JOctopus\"\n)\n\n\nprofile_info\n(\nusername\n=\n\"sammyshark\"\n,\n \nfollowers\n=\n945\n)\n\n\n\n\n\n\nWhen we run the program with the python profile.py command, we\u2019ll receive the following output:\n\n\nOutput\n:\n\n\nUsername\n:\n \nJOctopus\n\n\nFollowers\n:\n \n1\n\n\nUsername\n:\n \nsammyshark\n\n\nFollowers\n:\n \n945\n\n\n\n\n\n\nProviding default parameters with values can let us skip defining values for each argument that already has a default.\n\n\nReturning a Value\n\n\nYou can pass a parameter value into a function, and a function can also produce a value.\n\n\nA function can produce a value with the return statement, which will exit a function and optionally pass an expression back to the caller. If you use a return statement with no arguments, the function will return None.\n\n\nSo far, we have used the print() statement instead of the return statement in our functions. Let\u2019s create a program that instead of printing will return a variable.\n\n\nIn a new text file called square.py, we\u2019ll create a program that squares the parameter x and returns the variable y. We issue a call to print the result variable, which is formed by running the square() function with 3 passed into it.\n\n\ndef\n \nsquare\n(\nx\n):\n\n    \ny\n \n=\n \nx\n \n**\n \n2\n\n    \nreturn\n \ny\n\n\n\nresult\n \n=\n \nsquare\n(\n3\n)\n\n\nprint\n(\nresult\n)\n\n\n\n\n\n\nWe can run the program and see the output:\n\n\npython\n \nsquare\n.\npy\n\n\nOutput\n:\n\n\n9\n\n\n\n\n\n\nThe integer 9 is returned as output, which is what we would expect by asking Python to find the square of 3.\n\n\nTo further understand how the \nreturn\n statement works, we can comment out the \nreturn\n statement in the program:\n\n\ndef\n \nsquare\n(\nx\n):\n\n    \ny\n \n=\n \nx\n \n**\n \n2\n\n    \n# return y\n\n\n\nresult\n \n=\n \nsquare\n(\n3\n)\n\n\nprint\n(\nresult\n)\n\n\n\n\n\n\nNow, let\u2019s run the program again:\n\n\npython\n \nsquare\n.\npy\n\n\nOutput\n:\n\n\nNone\n\n\n\n\n\n\nWithout using the \nreturn\n statement here, the program cannot return a value so the value defaults to None.\n\n\nAs another example, in the \nadd_numbers.py\n program above, we could swap out the \nprint()\n statement for a return statement.\n\n\ndef\n \nadd_numbers\n(\nx\n,\n \ny\n,\n \nz\n):\n\n    \na\n \n=\n \nx\n \n+\n \ny\n\n    \nb\n \n=\n \nx\n \n+\n \nz\n\n    \nc\n \n=\n \ny\n \n+\n \nz\n\n    \nreturn\n \na\n,\n \nb\n,\n \nc\n\n\n\nsums\n \n=\n \nadd_numbers\n(\n1\n,\n \n2\n,\n \n3\n)\n\n\nprint\n(\nsums\n)\n\n\n\n\n\n\nOutside of the function, we set the variable sums equal to the result of the function taking in 1, 2, and 3 as we did above. Then we called a print of the sums variable.\n\n\nLet\u2019s run the program again now that it has the return statement:\n\n\nOutput\n:\n\n\n(\n3\n,\n \n4\n,\n \n5\n)\n\n\n\n\n\n\nWe receive the same numbers 3, 4, and 5 as output that we received previously by using the print() statement in the function. This time it is delivered as a tuple because the return statement\u2019s expression list has at least one comma.\n\n\nFunctions exit immediately when they hit a return statement, whether or not they\u2019re returning a value.\n\n\ndef\n \nloop_five\n():\n\n    \nfor\n \nx\n \nin\n \nrange\n(\n0\n,\n \n25\n):\n\n        \nprint\n(\nx\n)\n\n        \nif\n \nx\n \n==\n \n5\n:\n\n            \n# Stop function at x == 5\n\n            \nreturn\n\n    \nprint\n(\n\"This line will not execute.\"\n)\n\n\n\nloop_five\n()\n\n\n\n\n\n\nUsing the \nreturn\n statement within the \nfor\n loop ends the function, so the line that is outside of the loop will not run. If, instead, we had used a \nbreak\n statement, only the loop would have exited at that time, and the last print() line would run.\n\n\nThe \nreturn\n statement exits a function, and may return a value when issued with a parameter.\n\n\nUsing \nmain()\n as a Function\n\n\nAlthough in Python you can call the function at the bottom of your program and it will run (as we have done in the examples above), many programming languages (like C++ and Java) require a main function in order to execute. Including a main() function, though not required, can structure our Python programs in a logical way that puts the most important components of the program into one function. It can also make our programs easier for non-Python programmers to read.\n\n\nWe\u2019ll start with adding a main() function to the hello.py program above. We\u2019ll keep our hello() function, and then define a main() function:\n\n\ndef\n \nhello\n():\n\n    \nprint\n(\n\"Hello, World!\"\n)\n\n\n\ndef\n \nmain\n():\n\n\n\n\n\n\nWithin the main() function, let\u2019s include a print() statement to let us know that we\u2019re in the main() function. Additionally, let\u2019s call the hello() function within the main() function:\n\n\ndef\n \nhello\n():\n\n    \nprint\n(\n\"Hello, World!\"\n)\n\n\n\n\ndef\n \nmain\n():\n\n    \nprint\n(\n\"This is the main function\"\n)\n\n    \nhello\n()\n\n\n\n\n\n\nFinally, at the bottom of the program we\u2019ll call the main() function:\n\n\ndef\n \nhello\n():\n\n    \nprint\n(\n\"Hello, World!\"\n)\n\n\n\ndef\n \nmain\n():\n\n    \nprint\n(\n\"This is the main function.\"\n)\n\n    \nhello\n()\n\n\n\nmain\n()\n\n\n\n\n\n\nAt this point, we can run our program:\n\n\npython\n \nhello\n.\npy\n\n\nOutput\n:\n\n\nThis\n \nis\n \nthe\n \nmain\n \nfunction\n.\n\n\nHello\n,\n \nWorld\n!\n\n\n\n\n\n\nBecause we called the \nhello()\n function within main() and then only called \nmain()\n to run, the \nHello, World!\n text printed only once, after the string that told us we were in the main function.\n\n\nNext we\u2019re going to be working with multiple functions, so it is worth reviewing the variable scope of global and local variables. If you define a variable within a function block, you\u2019ll only be able to use that variable within that function. If you would like to use variables across functions it may be better to declare a global variable.\n\n\nIn Python, '_\nmain_\n' is the name of the scope where top-level code will execute. When a program is run from standard input, a script, or from an interactive prompt, its _\nname_\n is set equal to '_\nmain_\n'.\n\n\nBecause of this, there is a convention to use the following construction:\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \n# Code to run when this is the main program here\n\n\n\n\n\n\nThis lets program files be used either:\n- as the main program and run what follows the if statement\n- as a module and not run what follows the if statement.\n\n\nAny code that is not contained within this statement will be executed upon running. If you\u2019re using your program file as a module, the code that is not in this statement will also execute upon its import while running the secondary file.\n\n\nLet\u2019s expand on our names.py program above, and create a new file called more_names.py. In this program we\u2019ll declare a global variable and modify our original names() function so that the instructions are in two discrete functions.\n\n\nThe first function, \nhas_vowel()\n will check to see if the name string contains a vowel.\n\n\nThe second function \nprint_letters()\n will print each letter of the \nname\n string.\n\n\n# Declare global variable name for use in all functions\n\n\nname\n \n=\n \nstr\n(\ninput\n(\n'Enter your name: '\n))\n\n\n\n\n# Define function to check if name contains a vowel\n\n\ndef\n \nhas_vowel\n():\n\n    \nif\n \nset\n(\n'aeiou'\n)\n.\nintersection\n(\nname\n.\nlower\n()):\n\n        \nprint\n(\n'Your name contains a vowel.'\n)\n\n    \nelse\n:\n\n        \nprint\n(\n'Your name does not contain a vowel.'\n)\n\n\n\n\n# Iterate over letters in name string\n\n\ndef\n \nprint_letters\n():\n\n    \nfor\n \nletter\n \nin\n \nname\n:\n\n        \nprint\n(\nletter\n)\n\n\n\n\n\n\nWith this set up, let\u2019s define the main() function which will contain a call to both the has_vowel() and the print_letters() functions.\n\n\n# Declare global variable name for use in all functions\n\n\nname\n \n=\n \nstr\n(\ninput\n(\n'Enter your name: '\n))\n\n\n\n\n# Define function to check if name contains a vowel\n\n\ndef\n \nhas_vowel\n():\n\n    \nif\n \nset\n(\n'aeiou'\n)\n.\nintersection\n(\nname\n.\nlower\n()):\n\n        \nprint\n(\n'Your name contains a vowel.'\n)\n\n    \nelse\n:\n\n        \nprint\n(\n'Your name does not contain a vowel.'\n)\n\n\n\n\n# Iterate over letters in name string\n\n\ndef\n \nprint_letters\n():\n\n    \nfor\n \nletter\n \nin\n \nname\n:\n\n        \nprint\n(\nletter\n)\n\n\n\n\n# Define main method that calls other functions\n\n\ndef\n \nmain\n():\n\n    \nhas_vowel\n()\n\n    \nprint_letters\n()\n\n\n\n\n\n\nFinally, we\u2019ll add the \nif \\__name\\__ == '\\__main\\__':\n construction at the bottom of the file. For our purposes, since we have put all the functions we would like to do in the \nmain()\n function, we\u2019ll call the \nmain()\n function following this if statement.\n\n\n# Declare global variable name for use in all functions\n\n\nname\n \n=\n \nstr\n(\ninput\n(\n'Enter your name: '\n))\n\n\n\n\n# Define function to check if name contains a vowel\n\n\ndef\n \nhas_vowel\n():\n\n    \nif\n \nset\n(\n'aeiou'\n)\n.\nintersection\n(\nname\n.\nlower\n()):\n\n        \nprint\n(\n'Your name contains a vowel.'\n)\n\n    \nelse\n:\n\n        \nprint\n(\n'Your name does not contain a vowel.'\n)\n\n\n\n\n# Iterate over letters in name string\n\n\ndef\n \nprint_letters\n():\n\n    \nfor\n \nletter\n \nin\n \nname\n:\n\n        \nprint\n(\nletter\n)\n\n\n\n\n# Define main method that calls other functions\n\n\ndef\n \nmain\n():\n\n    \nhas_vowel\n()\n\n    \nprint_letters\n()\n\n\n\n\n# Execute main() function\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nmain\n()\n\n\n\n\n\n\nWe can now run the program:\n\n\npython\n \nmore_names\n.\npy\n\n\n\n\n\n\nThe program will show the same output as the names.py program, but here the code is more organized and can be used in a modular way without modification.\n\n\nIf you did not want to declare a main() function, you alternatively could have ended the program like this:\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nhas_vowel\n()\n\n    \nprint_letters\n()\n\n\n\n\n\n\nUsing \nmain()\n as a function and the if _\nname_\n == '_\nmain_\n': statement can organize your code in a logical way, making it more readable and modular.\n\n\nConclusion\n\n\nFunctions are code blocks of instructions that perform actions within a program, helping to make our code reusable and modular.\n\n\nTo learn more about how to make your code more modular, you can read our guide on \nHow To Write Modules in Python 3.\n\n\n\n\nSource:\n \n\n\n https://stackoverflow.com/questions/1909512/what-is-python-used-for\n\n\n\n\nPrefer Exceptions to Returning None\n\n\nWhen writing utility functions, there\u2019s a draw for Python programmers to give special\nmeaning to the return value of None. It seems to makes sense in some cases. For example,\nsay you want a helper function that divides one number by another. In the case of dividing\nby zero, returning None seems natural because the result is undefined.\n\n\ndef\n \ndivide\n(\na\n,\n \nb\n):\n\n    \ntry\n:\n\n        \nreturn\n \na\n \n/\n \nb\n\n    \nexcept\n \nZeroDivisionError\n:\n\n        \nreturn\n \nNone\n\n\n\n\n\n\nCode using this function can interpret the return value accordingly.\n\n\nresult\n \n=\n \ndivide\n(\nx\n,\n \ny\n)\n\n\nif\n \nresult\n \nis\n \nNone\n:\n\n    \nprint\n(\n\u2018\nInvalid\n \ninputs\n\u2019\n)\n\n\n\n\n\n\nWhat happens when the numerator is zero? That will cause the return value to also be zero\n(if the denominator is non-zero). This can cause problems when you evaluate the result in\na condition like an if statement. You may accidentally look for any False equivalent\nvalue to indicate errors instead of only looking for None.\n\n\nx\n,\n \ny\n \n=\n \n0\n,\n \n5\n\n\nresult\n \n=\n \ndivide\n(\nx\n,\n \ny\n)\n\n\nif\n \nnot\n \nresult\n:\n\n    \nprint\n(\n\u2018\nInvalid\n \ninputs\n\u2019\n)\n \n# This is wrong!\n\n\n\n\n\n\nThis is a common mistake in Python code when None has special meaning. This is why\nreturning None from a function is error prone. There are two ways to reduce the chance of\nsuch errors.  \n\n\nThe first way is to split the return value into a two-tuple. The first part of the tuple\nindicates that the operation was a success or failure. The second part is the actual result\nthat was computed.\n\n\ndef\n \ndivide\n(\na\n,\n \nb\n):\n\n    \ntry\n:\n\n        \nreturn\n \nTrue\n,\n \na\n \n/\n \nb\n\n    \nexcept\n \nZeroDivisionError\n:\n\n        \nreturn\n \nFalse\n,\n \nNone\n\n\n\n\n\n\nCallers of this function have to unpack the tuple. That forces them to consider the status\npart of the tuple instead of just looking at the result of division.\n\n\nsuccess\n,\n \nresult\n \n=\n \ndivide\n(\nx\n,\n \ny\n)\n\n\nif\n \nnot\n \nsuccess\n:\n\n    \nprint\n(\n\u2018\nInvalid\n \ninputs\n\u2019\n)\n\n\n\n\n\n\nThe problem is that callers can easily ignore the first part of the tuple (using the\nunderscore variable name, a Python convention for unused variables). The resulting code\ndoesn\u2019t look wrong at first glance. This is as bad as just returning None.\n\n\n_\n,\n \nresult\n \n=\n \ndivide\n(\nx\n,\n \ny\n)\n\n\nif\n \nnot\n \nresult\n:\n\n    \nprint\n(\n\u2018\nInvalid\n \ninputs\n\u2019\n)\n\n\n\n\n\n\nThe second, better way to reduce these errors is to never return None at all. Instead, raise\nan exception up to the caller and make them deal with it. Here, I turn a\nZeroDivisionError into a ValueError to indicate to the caller that the input\nvalues are bad:  \n\n\ndef\n \ndivide\n(\na\n,\n \nb\n):\n\n    \ntry\n:\n\n        \nreturn\n \na\n \n/\n \nb\n\n    \nexcept\n \nZeroDivisionError\n \nas\n \ne\n:\n\n        \nraise\n \nValueError\n(\n\u2018\nInvalid\n \ninputs\n\u2019\n)\n \nfrom\n \ne\n\n\n\n\n\n\nNow the caller should handle the exception for the invalid input case.\nThe caller no longer requires a condition on the return value of the function. If the\nfunction didn\u2019t raise an exception, then the return value must be good. The outcome of\nexception handling is clear.\n\n\nx\n,\n \ny\n \n=\n \n5\n,\n \n2\n\n\ntry\n:\n\n    \nresult\n \n=\n \ndivide\n(\nx\n,\n \ny\n)\n\n\nexcept\n \nValueError\n:\n\n    \nprint\n(\n\u2018\nInvalid\n \ninputs\n\u2019\n)\n\n\nelse\n:\n\n    \nprint\n(\n\u2018\nResult\n \nis\n \n%.\n1\nf\n\u2019\n \n%\n \nresult\n)\n\n\n>>>\n\n\nResult\n \nis\n \n2.5\n\n\n\n\n\n\nThings to Remember\n\n\n\n\nFunctions that return None to indicate special meaning are error prone because\nNone and other values (e.g., zero, the empty string) all evaluate to False in\nconditional expressions.  \n\n\nRaise exceptions to indicate special situations instead of returning None. Expect the\ncalling code to handle exceptions properly when they\u2019re documented.\n\n\n\n\n\n\nSource:\n \n\n\n  \nEffective Python\n by Brett Slatkin",
            "title": "Functions"
        },
        {
            "location": "/beginner/Functions/#function-calls",
            "text": "In the context of programming, a function is a named sequence of statements that\nperforms a computation. When you define a function, you specify the name and the\nsequence of statements. Later, you can \u201ccall\u201d the function by name. We have already seen\none example of a function call:  >>>   type ( 32 )  < type   'int' >   The name of the function is type. The expression in parentheses is called the argument\nof the function. The result, for this function, is the type of the argument. \nIt is common to say that a function \u201ctakes\u201d an argument and \u201creturns\u201d a result. The result\nis called the return value.",
            "title": "Function Calls"
        },
        {
            "location": "/beginner/Functions/#type-conversion-functions",
            "text": "Python provides built-in functions that convert values from one type to another. The\nint function takes any value and converts it to an integer, if it can, or complains\notherwise:  >>>   int ( '32' )  32  >>>   int ( 'Hello' )  ValueError :   invalid   literal   for   int ():   Hello   int can convert floating-point values to integers, but it doesn\u2019t round off; it chops off\nthe fraction part:  >>>   int ( 3.99999 )  3  >>>   int ( - 2.3 )  - 2   float converts integers and strings to floating-point numbers:  >>>   float ( 32 )  32.0  >>>   float ( '3.14159' )  3.14159   Finally, str converts its argument to a string:  >>>   str ( 32 )  '32'  >>>   str ( 3.14159 )  '3.14159'",
            "title": "Type Conversion Functions"
        },
        {
            "location": "/beginner/Functions/#adding-new-functions",
            "text": "So far, we have only been using the functions that come with Python, but it is also possible\nto add new functions. A function definition specifies the name of a new function and\nthe sequence of statements that execute when the function is called. \nHere is an example:  def   print_lyrics (): \n     print   \"I'm a lumberjack, and I'm okay.\" \n     print   \"I sleep all night and I work all day.\"   def  is a keyword that indicates that this is a function definition. The name of the function\nis print_lyrics. The rules for function names are the same as for variable names: letters,\nnumbers and some punctuation marks are legal, but the first character can\u2019t be a number.\nYou can\u2019t use a keyword as the name of a function, and you should avoid having a variable\nand a function with the same name. \nThe empty parentheses after the name indicate that this function doesn\u2019t take any\narguments. \nThe first line of the function definition is called the header; the rest is called the body.\nThe header has to end with a colon and the body has to be indented. By convention, the\nindentation is always four spaces; see \u201cDebugging\u201d (page 33). The body can contain any\nnumber of statements. \nThe strings in the print statements are enclosed in double quotes. Single quotes and\ndouble quotes do the same thing; most people use single quotes except in cases like this\nwhere a single quote (which is also an apostrophe) appears in the string.\nIf you type a function definition in interactive mode, the interpreter prints ellipses (...)\nto let you know that the definition isn\u2019t complete:  def   print_lyrics (): \n     print   \"I'm a lumberjack, and I'm okay.\" \n     print   \"I sleep all night and I work all day.\"   To end the function, you have to enter an empty line (this is not necessary in a script).\nDefining a function creates a variable with the same name.  >>>   print   print_lyrics  < function   print_lyrics   at   0xb7e99e9c >  >>>   type ( print_lyrics )  < type   'function' >   The value of print_lyrics is a function object, which has type 'function'.\nThe syntax for calling the new function is the same as for built-in functions:  >>>   print_lyrics ()  I 'm a lumberjack, and I' m   okay .  I   sleep   all   night   and   I   work   all   day .   Once you have defined a function, you can use it inside another function. For example,\nto repeat the previous refrain, we could write a function called repeat_lyrics:    def   repeat_lyrics (): \n     print_lyrics () \n     print_lyrics ()   And then call repeat_lyrics:    >>>   repeat_lyrics ()  I 'm a lumberjack, and I' m   okay .  I   sleep   all   night   and   I   work   all   day .  I 'm a lumberjack, and I' m   okay .  I   sleep   all   night   and   I   work   all   day .   But that\u2019s not really how the song goes.",
            "title": "Adding New Functions"
        },
        {
            "location": "/beginner/Functions/#definitions-and-uses",
            "text": "Pulling together the code fragments from the previous section, the whole program looks\nlike this:  def   print_lyrics (): \n     print   \"I'm a lumberjack, and I'm okay.\" \n     print   \"I sleep all night and I work all day.\"  def   repeat_lyrics (): \n     print_lyrics () \n     print_lyrics ()    repeat_lyrics ()   This program contains two function definitions: print_lyrics and repeat_lyrics.\nFunction definitions get executed just like other statements, but the result creates func\ntion objects. The statements inside the function do not get executed until the function\nis called, and the function definition generates no output. \nAs you might expect, you have to create a function before you can execute it. In other\nwords, the function definition has to be executed before the function is called the first\ntime.",
            "title": "Definitions and Uses"
        },
        {
            "location": "/beginner/Functions/#flow-of-execution",
            "text": "In order to ensure that a function is defined before its first use, you have to know the\norder in which statements are executed, which is called the flow of execution. \nExecution always begins at the first statement of the program. Statements are executed\none at a time, in order, from top to bottom.  Function definitions do not alter the flow of execution of the program, but remember\nthat statements inside the function are not executed until the function is called.\nA function call is like a detour in the flow of execution. Instead of going to the next\nstatement, the flow jumps to the body of the function, executes all the statements there,\nand then comes back to pick up where it left off. \nThat sounds simple enough, until you remember that one function can call another.\nWhile in the middle of one function, the program might have to execute the statements\nin another function. But while executing that new function, the program might have to\nexecute yet another function! \nFortunately, Python is good at keeping track of where it is, so each time a function\ncompletes, the program picks up where it left off in the function that called it. When it\ngets to the end of the program, it terminates. \nWhat\u2019s the moral of this sordid tale? When you read a program, you don\u2019t always want\nto read from top to bottom. Sometimes it makes more sense if you follow the flow of\nexecution.",
            "title": "Flow of Execution"
        },
        {
            "location": "/beginner/Functions/#parameters-and-arguments",
            "text": "Some of the built-in functions we have seen require arguments. For example, when you\ncall math.sin you pass a number as an argument. Some functions take more than one\nargument:  math.pow  takes two, the base and the exponent.\nInside the function, the arguments are assigned to variables called parameters. Here is\nan example of a user-defined function that takes an argument:    def   print_twice ( bruce ): \n     print   bruce \n     print   bruce   This function assigns the argument to a parameter named bruce. When the function is\ncalled, it prints the value of the parameter (whatever it is) twice. \nThis function works with any value that can be printed.  >>>   print_twice ( 'Spam' )  Spam  Spam  >>>   print_twice ( 17 )  17  17  >>>   print_twice ( math . pi )  3.14159265359  3.14159265359    The same rules of composition that apply to built-in functions also apply to user-defined\nfunctions, so we can use any kind of expression as an argument for  print_twice :  >>>   print_twice ( 'Spam ' * 4 )  Spam   Spam   Spam   Spam  Spam   Spam   Spam   Spam  >>>   print_twice ( math . cos ( math . pi ))  - 1.0  - 1.0   The argument is evaluated before the function is called, so in the examples the expres\nsions 'Spam '*4 and math.cos(math.pi) are only evaluated once. \nYou can also use a variable as an argument:  >>>   michael   =   'Eric, the half a bee.'  >>>   print_twice ( michael )  Eric ,   the   half   a   bee .  Eric ,   the   half   a   bee .   The name of the variable we pass as an argument (michael) has nothing to do with the\nname of the parameter (bruce). It doesn\u2019t matter what the value was called back home\n(in the caller); here in print_twice, we call everybody bruce.",
            "title": "Parameters and Arguments"
        },
        {
            "location": "/beginner/Functions/#variables-and-parameters-are-local",
            "text": "When you create a variable inside a function, it is local, which means that it only exists\ninside the function. For example:  def   cat_twice ( part1 ,   part2 ): \n     cat   =   part1   +   part2 \n     print_twice ( cat )   This function takes two arguments, concatenates them, and prints the result twice. Here\nis an example that uses it:  >>>   line1   =   'Bing tiddle '  >>>   line2   =   'tiddle bang.'  >>>   cat_twice ( line1 ,   line2 )  Bing   tiddle   tiddle   bang .  Bing   tiddle   tiddle   bang .   When cat_twice terminates, the variable cat is destroyed. If we try to print it, we get\nan exception:  >>>   print   cat  NameError :   name   'cat'   is   not   defined   Parameters are also local. For example, outside print_twice, there is no such thing as\nbruce.",
            "title": "Variables and Parameters Are Local"
        },
        {
            "location": "/beginner/Functions/#stack-diagrams",
            "text": "To keep track of which variables can be used where, it is sometimes useful to draw a\nstack diagram. Like state diagrams, stack diagrams show the value of each variable, but\nthey also show the function each variable belongs to. \nEach function is represented by a frame. A frame is a box with the name of a function\nbeside it and the parameters and variables of the function inside it. The stack diagram\nfor the previous example is shown in Figure 3-1.   The frames are arranged in a stack that indicates which function called which, and so\non. In this example, print_twice was called by cat_twice, and cat_twice was called\nby  \\__main\\__ , which is a special name for the topmost frame. When you create a variable\noutside of any function, it belongs to  \\__main\\__ .  Each parameter refers to the same value as its corresponding argument. So, part1 has\nthe same value as line1, part2 has the same value as line2, and bruce has the same\nvalue as cat.\nIf an error occurs during a function call, Python prints the name of the function, and\nthe name of the function that called it, and the name of the function that called that, all\nthe way back to  \\__main__\\ .  For example, if you try to access cat from within print_twice, you get a NameError:  Traceback   ( innermost   last ): \n     File   \"test.py\" ,   line   13 ,   in   __main__ \n         cat_twice ( line1 ,   line2 ) \n     File   \"test.py\" ,   line   5 ,   in   cat_twice \n         print_twice ( cat ) \n     File   \"test.py\" ,   line   9 ,   in   print_twice \n         print   cat \n     NameError :   name   'cat'   is   not   defined   This list of functions is called a traceback. It tells you what program file the error oc\ncurred in, and what line, and what functions were executing at the time. It also shows\nthe line of code that caused the error.\nThe order of the functions in the traceback is the same as the order of the frames in the\nstack diagram. The function that is currently running is listed at the bottom.",
            "title": "Stack Diagrams"
        },
        {
            "location": "/beginner/Functions/#fruitful-functions-and-void-functions",
            "text": "Some of the functions we are using, such as the math functions, yield results; for lack of\na better name, I call them fruitful functions. Other functions, like print_twice, per\nform an action but don\u2019t return a value. They are called void functions.\nWhen you call a fruitful function, you almost always want to do something with the\nresult; for example, you might assign it to a variable or use it as part of an expression:  x   =   math . cos ( radians )  golden   =   ( math . sqrt ( 5 )   +   1 )   /   2   When you call a function in interactive mode, Python displays the result:  >>>   math . sqrt ( 5 )  2.2360679774997898   But in a script, if you call a fruitful function all by itself, the return value is lost forever!  math . sqrt ( 5 )   This script computes the square root of 5, but since it doesn\u2019t store or display the result,\nit is not very useful.\nVoid functions might display something on the screen or have some other effect, but\nthey don\u2019t have a return value. If you try to assign the result to a variable, you get a special\nvalue called None.  >>>   result   =   print_twice ( 'Bing' )  Bing  Bing  >>>   print   result  None   The value None is not the same as the string 'None'. It is a special value that has its own\ntype:  >>>   print   type ( None )  < type   'NoneType' >   The functions we have written so far are all void. We will start writing fruitful functions\nin a few chapters.",
            "title": "Fruitful Functions and Void Functions"
        },
        {
            "location": "/beginner/Functions/#why-functions",
            "text": "It may not be clear why it is worth the trouble to divide a program into functions. There\nare several reasons: \n- Creating a new function gives you an opportunity to name a group of statements,\nwhich makes your program easier to read and debug.\n- Functions can make a program smaller by eliminating repetitive code. Later, if you\nmake a change, you only have to make it in one place.\n- Dividing a long program into functions allows you to debug the parts one at a time\nand then assemble them into a working whole.\n- Well-designed functions are often useful for many programs. Once you write and\ndebug one, you can reuse it.   Source:       Think Python  by Allen B. Downey  - 2012",
            "title": "Why Functions?"
        },
        {
            "location": "/beginner/Functions/#functions-by-by-mark-lutz-learning-python-fourth-edition",
            "text": "",
            "title": "Functions by by Mark Lutz (Learning Python, Fourth Edition)"
        },
        {
            "location": "/beginner/Functions/#function-basics",
            "text": "In Part III, we looked at basic procedural statements in Python. Here, we\u2019ll move on to\nexplore a set of additional statements that we can use to create functions of our own. \nIn simple terms, a function is a device that groups a set of statements so they can be run\nmore than once in a program. Functions also can compute a result value and let us\nspecify parameters that serve as function inputs, which may differ each time the code\nis run. Coding an operation as a function makes it a generally useful tool, which we\ncan use in a variety of contexts. \nMore fundamentally, functions are the alternative to programming by cutting and\npasting\u2014rather than having multiple redundant copies of an operation\u2019s code, we can\nfactor it into a single function. In so doing, we reduce our future work radically: if the\noperation must be changed later, we only have one copy to update, not many. \nFunctions are the most basic program structure Python provides for maximizing code\nreuse and minimizing code redundancy. As we\u2019ll see, functions are also a design tool\nthat lets us split complex systems into manageable parts. Table 16-1 summarizes the\nprimary function-related tools we\u2019ll study in this part of the book.     Statement  Examples      Calls  myfunc('spam', 'eggs', meat=ham)    def, return  def adder(a, b=1, *c): return a + b + c[0]    global  def changer():global x; x = 'new'    nonlocal  def changer():nonlocal x; x = 'new'    yield  def squares(x):for i in range(x): yield i ** 2    lambda  funcs = [lambda x: x* 2, lambda x: x 3]",
            "title": "Function Basics"
        },
        {
            "location": "/beginner/Functions/#why-use-functions",
            "text": "Before we get into the details, let\u2019s establish a clear picture of what functions are all\nabout. Functions are a nearly universal program-structuring device. You may have\ncome across them before in other languages, where they may have been called subroutines\nor procedures. As a brief introduction, functions serve two primary development\nroles:  Maximizing code reuse and minimizing redundancy \nAs in most programming languages, Python functions are the simplest way to\npackage logic you may wish to use in more than one place and more than one time.\nUp until now, all the code we\u2019ve been writing has run immediately. Functions allow\nus to group and generalize code to be used arbitrarily many times later. Because\nthey allow us to code an operation in a single place and use it in many places,\nPython functions are the most basic factoring tool in the language: they allow us\nto reduce code redundancy in our programs, and thereby reduce maintenance\neffort.    Procedural decomposition \nFunctions also provide a tool for splitting systems into pieces that have well-defined\nroles. For instance, to make a pizza from scratch, you would start by mixing the\ndough, rolling it out, adding toppings, baking it, and so on. If you were programming\na pizza-making robot, functions would help you divide the overall \u201cmake\npizza\u201d task into chunks\u2014one function for each subtask in the process. It\u2019s easier\nto implement the smaller tasks in isolation than it is to implement the entire process\nat once. In general, functions are about procedure\u2014how to do something, rather\nthan what you\u2019re doing it to. We\u2019ll see why this distinction matters in Part VI, when\nwe start making new object with classes.     In this part of the book, we\u2019ll explore the tools used to code functions in Python: function\nbasics, scope rules, and argument passing, along with a few related concepts such\nas generators and functional tools. Because its importance begins to become more apparent\nat this level of coding, we\u2019ll also revisit the notion of polymorphism introduced\nearlier in the book. As you\u2019ll see, functions don\u2019t imply much new syntax, but they do\nlead us to some bigger programming ideas.",
            "title": "Why Use Functions?"
        },
        {
            "location": "/beginner/Functions/#coding-functions",
            "text": "Although it wasn\u2019t made very formal, we\u2019ve already used some functions in earlier\nchapters. For instance, to make a file object, we called the built-in open function; similarly,\nwe used the len built-in function to ask for the number of items in a collection\nobject. \nIn this chapter, we will explore how to write new functions in Python. Functions we\nwrite behave the same way as the built-ins we\u2019ve already seen: they are called in expressions, are passed values, and return results. But writing new functions requires\nthe application of a few additional ideas that haven\u2019t yet been introduced. Moreover,\nfunctions behave very differently in Python than they do in compiled languages like C.\nHere is a brief introduction to the main concepts behind Python functions, all of which\nwe will study in this part of the book:     def is executable code.  Python functions are written with a new statement, the\ndef. Unlike functions in compiled languages such as C, def is an executable statement\u2014\nyour function does not exist until Python reaches and runs the def. In fact,\nit\u2019s legal (and even occasionally useful) to nest def statements inside if statements,\nwhile loops, and even other defs. In typical operation, def statements are coded in\nmodule files and are naturally run to generate functions when a module file is first\nimported.   def creates an object and assigns it to a name.  When Python reaches and runs\na def statement, it generates a new function object and assigns it to the function\u2019s\nname. As with all assignments, the function name becomes a reference to the function\nobject. There\u2019s nothing magic about the name of a function\u2014as you\u2019ll see,\nthe function object can be assigned to other names, stored in a list, and so on.\nFunction objects may also have arbitrary user-defined attributes attached to them\nto record data.    lambda creates an object but returns it as a result.  Functions may also be created\nwith the lambda expression, a feature that allows us to in-line function definitions\nin places where a def statement won\u2019t work syntactically    return sends a result object back to the caller.  When a function is called, the\ncaller stops until the function finishes its work and returns control to the caller.\nFunctions that compute a value send it back to the caller with a return statement;\nthe returned value becomes the result of the function call.    yield sends a result object back to the caller, but remembers where it left\noff.  Functions known as generators may also use the yield statement to send back\na value and suspend their state such that they may be resumed later, to produce a\nseries of results over time. This is another advanced topic covered later in this part\nof the book.    global declares module-level variables that are to be assigned.  By default, all\nnames assigned in a function are local to that function and exist only while the\nfunction runs. To assign a name in the enclosing module, functions need to list it\nin a global statement. More generally, names are always looked up in scopes\u2014\nplaces where variables are stored\u2014and assignments bind names to scopes.    nonlocal declares enclosing function variables that are to be assigned.  Similarly,\nthe nonlocal statement added in Python 3.0 allows a function to assign a\nname that exists in the scope of a syntactically enclosing def statement. This allows\nenclosing functions to serve as a place to retain state\u2014information remembered\nwhen a function is called\u2014without using shared global names.    Arguments are passed by assignment (object reference).  In Python, arguments\nare passed to functions by assignment (which, as we\u2019ve learned, means by object\nreference). As you\u2019ll see, in Python\u2019s model the caller and function share objects\nby references, but there is no name aliasing. Changing an argument name within\na function does not also change the corresponding name in the caller, but changing\npassed-in mutable objects can change objects shared by the caller.    Arguments, return values, and variables are not declared.  As with everything\nin Python, there are no type constraints on functions. In fact, nothing about a\nfunction needs to be declared ahead of time: you can pass in arguments of any type,\nreturn any kind of object, and so on. As one consequence, a single function can\noften be applied to a variety of object types\u2014any objects that sport a compatible\ninterface (methods and expressions) will do, regardless of their specific types.    If some of the preceding words didn\u2019t sink in, don\u2019t worry\u2014we\u2019ll explore all of these\nconcepts with real code in this part of the book. Let\u2019s get started by expanding on some\nof these ideas and looking at a few examples.",
            "title": "Coding Functions"
        },
        {
            "location": "/beginner/Functions/#def-statements",
            "text": "The def statement creates a function object and assigns it to a name. Its general format\nis as follows:  def   < name > ( arg1 ,   arg2 , ...   argN ): \n     < statements >   As with all compound Python statements, def consists of a header line followed by a\nblock of statements, usually indented (or a simple statement after the colon). The\nstatement block becomes the function\u2019s body\u2014that is, the code Python executes each\ntime the function is called. \nThe def header line specifies a function name that is assigned the function object, along\nwith a list of zero or more arguments (sometimes called parameters) in parentheses.\nThe argument names in the header are assigned to the objects passed in parentheses at\nthe point of call.  Function bodies often contain a return statement:  def   < name > ( arg1 ,   arg2 , ...   argN ): \n     ... \n     return   < value >   The Python return statement can show up anywhere in a function body; it ends the\nfunction call and sends a result back to the caller. The return statement consists of an\nobject expression that gives the function\u2019s result. The return statement is optional; if\nit\u2019s not present, the function exits when the control flow falls off the end of the function\nbody. Technically, a function without a return statement returns the None object automatically,\nbut this return value is usually ignored.",
            "title": "def Statements"
        },
        {
            "location": "/beginner/Functions/#def-executes-at-runtime",
            "text": "The Python def is a true executable statement: when it runs, it creates a new function\nobject and assigns it to a name. (Remember, all we have in Python is runtime; there is\nno such thing as a separate compile time.) Because it\u2019s a statement, a def can appear\nanywhere a statement can\u2014even nested in other statements. For instance, although\ndefs normally are run when the module enclosing them is imported, it\u2019s also completely\nlegal to nest a function def inside an if statement to select between alternative\ndefinitions:  if   test : \n     def   func ():   # Define func this way  ...  else : \n     def   func ():   # Or else this way \n     ... \n     ...  func ()   # Call the version selected and built   One way to understand this code is to realize that the def is much like an = statement:\nit simply assigns a name at runtime. Unlike in compiled languages such as C, Python\nfunctions do not need to be fully defined before the program runs. More generally,\ndefs are not evaluated until they are reached and run, and the code inside defs is not\nevaluated until the functions are later called.\nBecause function definition happens at runtime, there\u2019s nothing special about the\nfunction name. What\u2019s important is the object to which it refers:    othername   =   func   # Assign function object  othername ()   # Call func again   Here, the function was assigned to a different name and called through the new name.\nLike everything else in Python, functions are just objects; they are recorded explicitly\nin memory at program execution time. In fact, besides calls, functions allow arbitrary\nattributes to be attached to record information for later use:  def   func ():   ...   # Create function object  func ()   # Call object  func . attr   =   value   # Attach attributes",
            "title": "def Executes at Runtime"
        },
        {
            "location": "/beginner/Functions/#a-first-example-definitions-and-calls",
            "text": "Apart from such runtime concepts (which tend to seem most unique to programmers\nwith backgrounds in traditional compiled languages), Python functions are straightforward\nto use. Let\u2019s code a first real example to demonstrate the basics. As you\u2019ll see,\nthere are two sides to the function picture: a definition (the def that creates a function)\nand a call (an expression that tells Python to run the function\u2019s body).",
            "title": "A First Example: Definitions and Calls"
        },
        {
            "location": "/beginner/Functions/#definition",
            "text": "Here\u2019s a definition typed interactively that defines a function called times, which returns\nthe product of its two arguments:  >>>   def   times ( x ,   y ):   # Create and assign function  ...   return   x   *   y   # Body executed when called  ...   When Python reaches and runs this def, it creates a new function object that packages\nthe function\u2019s code and assigns the object to the name times. Typically, such a statement\nis coded in a module file and runs when the enclosing file is imported; for something\nthis small, though, the interactive prompt suffices.",
            "title": "Definition"
        },
        {
            "location": "/beginner/Functions/#calls",
            "text": "After the def has run, you can call (run) the function in your program by adding\nparentheses after the function\u2019s name. The parentheses may optionally contain one or\nmore object arguments, to be passed (assigned) to the names in the function\u2019s header:  >>>   times ( 2 ,   4 )   # Arguments in parentheses  8   This expression passes two arguments to times. As mentioned previously, arguments\nare passed by assignment, so in this case the name x in the function header is assigned\nthe value 2, y is assigned the value 4, and the function\u2019s body is run. For this function,\nthe body is just a return statement that sends back the result as the value of the call\nexpression. The returned object was printed here interactively (as in most languages,\n2 * 4 is 8 in Python), but if we needed to use it later we could instead assign it to a\nvariable. For example:  >>>   x   =   times ( 3.14 ,   4 )   # Save the result object  >>>   x  12.56   Now, watch what happens when the function is called a third time, with very different\nkinds of objects passed in:  >>>   times ( 'Ni' ,   4 )   # Functions are \"typeless\"  'NiNiNiNi'   This time, our function means something completely different (Monty Python reference\nagain intended). In this third call, a string and an integer are passed to x and y, instead\nof two numbers. Recall that * works on both numbers and sequences; because we never\ndeclare the types of variables, arguments, or return values in Python, we can use\ntimes to either multiply numbers or repeat sequences. \nIn other words, what our times function means and does depends on what we pass into\nit. This is a core idea in Python (and perhaps the key to using the language well), which\nwe\u2019ll explore in the next section.   Source:       Learning Python, Fourth Edition  by Mark Lutz  - 2009",
            "title": "Calls"
        },
        {
            "location": "/beginner/Functions/#how-to-define-functions-in-python-3",
            "text": "A function is a block of instructions that performs an action and, once defined, can be reused. Functions make code more modular, allowing you to use the same code over and over again.  Python has a number of built-in functions that you may be familiar with, including:    print() which will print an object to the terminal  int() which will convert a string or number data type to an integer data type  len() which returns the length of an object   Function names include parentheses and may include parameters.    In this tutorial, we\u2019ll go over how to define your own functions to use in your coding projects.",
            "title": "How To Define Functions in Python 3"
        },
        {
            "location": "/beginner/Functions/#defining-a-function",
            "text": "Let\u2019s start with turning the classic \u201cHello, World!\u201d program into a function.  We\u2019ll create a new text file in our text editor of choice, and call the program hello.py. Then, we\u2019ll define the function.  A function is defined by using the def keyword, followed by a name of your choosing, followed by a set of parentheses which hold any parameters the function will take (they can be empty), and ending with a colon.  In this case, we\u2019ll define a function named hello():  def   hello ():   This sets up the initial statement for creating a function.  From here, we\u2019ll add a second line with a 4-space indent to provide the instructions for what the function does. In this case, we\u2019ll be printing Hello, World! to the console:  def   hello (): \n     print ( \"Hello, World!\" )   Our function is now fully defined, but if we run the program at this point, nothing will happen since we didn\u2019t call the function.  So, outside of our defined function block, let\u2019s call the function with hello():   def   hello (): \n     print ( \"Hello, World!\" )  hello ()   Now, let\u2019s run the program:  python   hello . py   You should receive the following output:  Hello ,   World !   Functions can be more complicated than the  hello()  function we defined above. For example, we can use for loops, conditional statements, and more within our function block.  For example, the function defined below utilizes a conditional statement to check if the input for the name variable contains a vowel, then uses a  for  loop to iterate over the letters in the  name  string.  # Define function names()  def   names (): \n     # Set up name variable with input \n     name   =   str ( input ( 'Enter your name: ' )) \n     # Check whether name has a vowel \n     if   set ( 'aeiou' ) . intersection ( name . lower ()): \n         print ( 'Your name contains a vowel.' ) \n     else : \n         print ( 'Your name does not contain a vowel.' ) \n\n     # Iterate over name \n     for   letter   in   name : \n         print ( letter )  # Call the function  names ()   The  names()  function we defined above sets up a conditional statement and a for loop, showing how code can be organized within a function definition. However, depending on what we intend with our program and how we want to set up our code, we may want to define the conditional statement and the for loop as two separate functions.  Defining functions within a program makes our code modular and reusable so that we can call the same functions without rewriting them.",
            "title": "Defining a Function"
        },
        {
            "location": "/beginner/Functions/#working-with-parameters",
            "text": "So far we have looked at functions with empty parentheses that do not take arguments, but we can define parameters in function definitions within their parentheses.  A parameter is a named entity in a function definition, specifying an argument that the function can accept.  Let\u2019s create a small program that takes in parameters x, y, and z. We\u2019ll create a function that adds the parameters together in different configurations. The sums of these will be printed by the function. Then we\u2019ll call the function and pass numbers into the function.  def   add_numbers ( x ,   y ,   z ): \n     a   =   x   +   y \n     b   =   x   +   z \n     c   =   y   +   z \n     print ( a ,   b ,   c )  add_numbers ( 1 ,   2 ,   3 )   We passed the number 1 in for the x parameter, 2 in for the y parameter, and 3 in for the z parameter. These values correspond with each parameter in the order they are given.  The program is essentially doing the following math based on the values we passed to the parameters:  a   =   1   +   2  b   =   1   +   3  c   =   2   +   3   The function also prints a, b, and c, and based on the math above we would expect a to be equal to 3, b to be 4, and c to be 5. Let\u2019s run the program:  python   add_numbers . py  Output   :   3   4   5   When we pass 1, 2, and 3 as parameters to the add_numbers() function, we receive the expected output.  Parameters are arguments that are typically defined as variables within function definitions. They can be assigned values when you run the method, passing the arguments into the function.",
            "title": "Working with Parameters"
        },
        {
            "location": "/beginner/Functions/#keyword-arguments",
            "text": "In addition to calling parameters in order, you can use  keyword arguments  in a function call, in which the caller identifies the arguments by the parameter name.  When you use keyword arguments, you can use parameters out of order because the Python interpreter will use the keywords provided to match the values to the parameters.  Let\u2019s create a function that will show us profile information for a user. We\u2019ll pass parameters to it in the form of  username  (intended as a string), and  followers  (intended as an integer).  # Define function with parameters  def   profile_info ( username ,   followers ): \n     print ( \"Username: \"   +   username ) \n     print ( \"Followers: \"   +   str ( followers ))    Within the function definition statement,  username  and  followers  are contained in the parentheses of the profile_info() function. The block of the function prints out information about the user as strings, making use of the two parameters.  Now, we can call the function and assign parameters to it:  def   profile_info ( username ,   followers ): \n     print ( \"Username: \"   +   username ) \n     print ( \"Followers: \"   +   str ( followers ))  # Call function with parameters assigned as above  profile_info ( \"sammyshark\" ,   945 )  # Call function with keyword arguments  profile_info ( username = \"AlexAnglerfish\" ,   followers = 342 )   In the first function call, we have filled in the information with a username of sammyshark and followers being 945, in the second function call we used keyword arguments, assigning values to the argument variables.  Let\u2019s run the program:  python   profile . py  Output   :   Username :   sammyshark  Followers :   945  Username :   AlexAnglerfish  Followers :   342   The output shows us the usernames and numbers of followers for both users.  This also permits us to modify the order of the parameters, as in this example of the same program with a different call:  def   profile_info ( username ,   followers ): \n     print ( \"Username: \"   +   username ) \n     print ( \"Followers: \"   +   str ( followers ))  # Change order of parameters  profile_info ( followers = 820 ,   username = \"cameron-catfish\" )   When we run the program again with the python profile.py command, we\u2019ll receive the following output:  Output :  Username :   cameron - catfish  Followers :   820   Because the function definition maintains the same order of print() statements, if we use keyword arguments, it does not matter which order we pass them into the function call.",
            "title": "Keyword Arguments"
        },
        {
            "location": "/beginner/Functions/#default-argument-values",
            "text": "We can also provide default values for one or both of the parameters. Let\u2019s create a default value for the  followers  parameter with a value of 1:  def   profile_info ( username ,   followers = 1 ): \n     print ( \"Username: \"   +   username ) \n     print ( \"Followers: \"   +   str ( followers ))   Now, we can run the function with only the username function assigned, and the number of followers will automatically default to 1. We can also still change the number of followers if we would like.  def   profile_info ( username ,   followers = 1 ): \n     print ( \"Username: \"   +   username ) \n     print ( \"Followers: \"   +   str ( followers ))  profile_info ( username = \"JOctopus\" )  profile_info ( username = \"sammyshark\" ,   followers = 945 )   When we run the program with the python profile.py command, we\u2019ll receive the following output:  Output :  Username :   JOctopus  Followers :   1  Username :   sammyshark  Followers :   945   Providing default parameters with values can let us skip defining values for each argument that already has a default.",
            "title": "Default Argument Values"
        },
        {
            "location": "/beginner/Functions/#returning-a-value",
            "text": "You can pass a parameter value into a function, and a function can also produce a value.  A function can produce a value with the return statement, which will exit a function and optionally pass an expression back to the caller. If you use a return statement with no arguments, the function will return None.  So far, we have used the print() statement instead of the return statement in our functions. Let\u2019s create a program that instead of printing will return a variable.  In a new text file called square.py, we\u2019ll create a program that squares the parameter x and returns the variable y. We issue a call to print the result variable, which is formed by running the square() function with 3 passed into it.  def   square ( x ): \n     y   =   x   **   2 \n     return   y  result   =   square ( 3 )  print ( result )   We can run the program and see the output:  python   square . py  Output :  9   The integer 9 is returned as output, which is what we would expect by asking Python to find the square of 3.  To further understand how the  return  statement works, we can comment out the  return  statement in the program:  def   square ( x ): \n     y   =   x   **   2 \n     # return y  result   =   square ( 3 )  print ( result )   Now, let\u2019s run the program again:  python   square . py  Output :  None   Without using the  return  statement here, the program cannot return a value so the value defaults to None.  As another example, in the  add_numbers.py  program above, we could swap out the  print()  statement for a return statement.  def   add_numbers ( x ,   y ,   z ): \n     a   =   x   +   y \n     b   =   x   +   z \n     c   =   y   +   z \n     return   a ,   b ,   c  sums   =   add_numbers ( 1 ,   2 ,   3 )  print ( sums )   Outside of the function, we set the variable sums equal to the result of the function taking in 1, 2, and 3 as we did above. Then we called a print of the sums variable.  Let\u2019s run the program again now that it has the return statement:  Output :  ( 3 ,   4 ,   5 )   We receive the same numbers 3, 4, and 5 as output that we received previously by using the print() statement in the function. This time it is delivered as a tuple because the return statement\u2019s expression list has at least one comma.  Functions exit immediately when they hit a return statement, whether or not they\u2019re returning a value.  def   loop_five (): \n     for   x   in   range ( 0 ,   25 ): \n         print ( x ) \n         if   x   ==   5 : \n             # Stop function at x == 5 \n             return \n     print ( \"This line will not execute.\" )  loop_five ()   Using the  return  statement within the  for  loop ends the function, so the line that is outside of the loop will not run. If, instead, we had used a  break  statement, only the loop would have exited at that time, and the last print() line would run.  The  return  statement exits a function, and may return a value when issued with a parameter.",
            "title": "Returning a Value"
        },
        {
            "location": "/beginner/Functions/#using-main-as-a-function",
            "text": "Although in Python you can call the function at the bottom of your program and it will run (as we have done in the examples above), many programming languages (like C++ and Java) require a main function in order to execute. Including a main() function, though not required, can structure our Python programs in a logical way that puts the most important components of the program into one function. It can also make our programs easier for non-Python programmers to read.  We\u2019ll start with adding a main() function to the hello.py program above. We\u2019ll keep our hello() function, and then define a main() function:  def   hello (): \n     print ( \"Hello, World!\" )  def   main ():   Within the main() function, let\u2019s include a print() statement to let us know that we\u2019re in the main() function. Additionally, let\u2019s call the hello() function within the main() function:  def   hello (): \n     print ( \"Hello, World!\" )  def   main (): \n     print ( \"This is the main function\" ) \n     hello ()   Finally, at the bottom of the program we\u2019ll call the main() function:  def   hello (): \n     print ( \"Hello, World!\" )  def   main (): \n     print ( \"This is the main function.\" ) \n     hello ()  main ()   At this point, we can run our program:  python   hello . py  Output :  This   is   the   main   function .  Hello ,   World !   Because we called the  hello()  function within main() and then only called  main()  to run, the  Hello, World!  text printed only once, after the string that told us we were in the main function.  Next we\u2019re going to be working with multiple functions, so it is worth reviewing the variable scope of global and local variables. If you define a variable within a function block, you\u2019ll only be able to use that variable within that function. If you would like to use variables across functions it may be better to declare a global variable.  In Python, '_ main_ ' is the name of the scope where top-level code will execute. When a program is run from standard input, a script, or from an interactive prompt, its _ name_  is set equal to '_ main_ '.  Because of this, there is a convention to use the following construction:  if   __name__   ==   '__main__' : \n     # Code to run when this is the main program here   This lets program files be used either:\n- as the main program and run what follows the if statement\n- as a module and not run what follows the if statement.  Any code that is not contained within this statement will be executed upon running. If you\u2019re using your program file as a module, the code that is not in this statement will also execute upon its import while running the secondary file.  Let\u2019s expand on our names.py program above, and create a new file called more_names.py. In this program we\u2019ll declare a global variable and modify our original names() function so that the instructions are in two discrete functions.  The first function,  has_vowel()  will check to see if the name string contains a vowel.  The second function  print_letters()  will print each letter of the  name  string.  # Declare global variable name for use in all functions  name   =   str ( input ( 'Enter your name: ' ))  # Define function to check if name contains a vowel  def   has_vowel (): \n     if   set ( 'aeiou' ) . intersection ( name . lower ()): \n         print ( 'Your name contains a vowel.' ) \n     else : \n         print ( 'Your name does not contain a vowel.' )  # Iterate over letters in name string  def   print_letters (): \n     for   letter   in   name : \n         print ( letter )   With this set up, let\u2019s define the main() function which will contain a call to both the has_vowel() and the print_letters() functions.  # Declare global variable name for use in all functions  name   =   str ( input ( 'Enter your name: ' ))  # Define function to check if name contains a vowel  def   has_vowel (): \n     if   set ( 'aeiou' ) . intersection ( name . lower ()): \n         print ( 'Your name contains a vowel.' ) \n     else : \n         print ( 'Your name does not contain a vowel.' )  # Iterate over letters in name string  def   print_letters (): \n     for   letter   in   name : \n         print ( letter )  # Define main method that calls other functions  def   main (): \n     has_vowel () \n     print_letters ()   Finally, we\u2019ll add the  if \\__name\\__ == '\\__main\\__':  construction at the bottom of the file. For our purposes, since we have put all the functions we would like to do in the  main()  function, we\u2019ll call the  main()  function following this if statement.  # Declare global variable name for use in all functions  name   =   str ( input ( 'Enter your name: ' ))  # Define function to check if name contains a vowel  def   has_vowel (): \n     if   set ( 'aeiou' ) . intersection ( name . lower ()): \n         print ( 'Your name contains a vowel.' ) \n     else : \n         print ( 'Your name does not contain a vowel.' )  # Iterate over letters in name string  def   print_letters (): \n     for   letter   in   name : \n         print ( letter )  # Define main method that calls other functions  def   main (): \n     has_vowel () \n     print_letters ()  # Execute main() function  if   __name__   ==   '__main__' : \n     main ()   We can now run the program:  python   more_names . py   The program will show the same output as the names.py program, but here the code is more organized and can be used in a modular way without modification.  If you did not want to declare a main() function, you alternatively could have ended the program like this:  if   __name__   ==   '__main__' : \n     has_vowel () \n     print_letters ()   Using  main()  as a function and the if _ name_  == '_ main_ ': statement can organize your code in a logical way, making it more readable and modular.",
            "title": "Using main() as a Function"
        },
        {
            "location": "/beginner/Functions/#conclusion",
            "text": "Functions are code blocks of instructions that perform actions within a program, helping to make our code reusable and modular.  To learn more about how to make your code more modular, you can read our guide on  How To Write Modules in Python 3.   Source:     https://stackoverflow.com/questions/1909512/what-is-python-used-for",
            "title": "Conclusion"
        },
        {
            "location": "/beginner/Functions/#prefer-exceptions-to-returning-none",
            "text": "When writing utility functions, there\u2019s a draw for Python programmers to give special\nmeaning to the return value of None. It seems to makes sense in some cases. For example,\nsay you want a helper function that divides one number by another. In the case of dividing\nby zero, returning None seems natural because the result is undefined.  def   divide ( a ,   b ): \n     try : \n         return   a   /   b \n     except   ZeroDivisionError : \n         return   None   Code using this function can interpret the return value accordingly.  result   =   divide ( x ,   y )  if   result   is   None : \n     print ( \u2018 Invalid   inputs \u2019 )   What happens when the numerator is zero? That will cause the return value to also be zero\n(if the denominator is non-zero). This can cause problems when you evaluate the result in\na condition like an if statement. You may accidentally look for any False equivalent\nvalue to indicate errors instead of only looking for None.  x ,   y   =   0 ,   5  result   =   divide ( x ,   y )  if   not   result : \n     print ( \u2018 Invalid   inputs \u2019 )   # This is wrong!   This is a common mistake in Python code when None has special meaning. This is why\nreturning None from a function is error prone. There are two ways to reduce the chance of\nsuch errors.    The first way is to split the return value into a two-tuple. The first part of the tuple\nindicates that the operation was a success or failure. The second part is the actual result\nthat was computed.  def   divide ( a ,   b ): \n     try : \n         return   True ,   a   /   b \n     except   ZeroDivisionError : \n         return   False ,   None   Callers of this function have to unpack the tuple. That forces them to consider the status\npart of the tuple instead of just looking at the result of division.  success ,   result   =   divide ( x ,   y )  if   not   success : \n     print ( \u2018 Invalid   inputs \u2019 )   The problem is that callers can easily ignore the first part of the tuple (using the\nunderscore variable name, a Python convention for unused variables). The resulting code\ndoesn\u2019t look wrong at first glance. This is as bad as just returning None.  _ ,   result   =   divide ( x ,   y )  if   not   result : \n     print ( \u2018 Invalid   inputs \u2019 )   The second, better way to reduce these errors is to never return None at all. Instead, raise\nan exception up to the caller and make them deal with it. Here, I turn a\nZeroDivisionError into a ValueError to indicate to the caller that the input\nvalues are bad:    def   divide ( a ,   b ): \n     try : \n         return   a   /   b \n     except   ZeroDivisionError   as   e : \n         raise   ValueError ( \u2018 Invalid   inputs \u2019 )   from   e   Now the caller should handle the exception for the invalid input case.\nThe caller no longer requires a condition on the return value of the function. If the\nfunction didn\u2019t raise an exception, then the return value must be good. The outcome of\nexception handling is clear.  x ,   y   =   5 ,   2  try : \n     result   =   divide ( x ,   y )  except   ValueError : \n     print ( \u2018 Invalid   inputs \u2019 )  else : \n     print ( \u2018 Result   is   %. 1 f \u2019   %   result )  >>>  Result   is   2.5",
            "title": "Prefer Exceptions to Returning None"
        },
        {
            "location": "/beginner/Functions/#things-to-remember",
            "text": "Functions that return None to indicate special meaning are error prone because\nNone and other values (e.g., zero, the empty string) all evaluate to False in\nconditional expressions.    Raise exceptions to indicate special situations instead of returning None. Expect the\ncalling code to handle exceptions properly when they\u2019re documented.    Source:       Effective Python  by Brett Slatkin",
            "title": "Things to Remember"
        },
        {
            "location": "/beginner/Scopes/",
            "text": "Scopes - Python Scope Basics\n\n\nNow that you\u2019re ready to start writing your own functions, we need to get more formal\nabout what names mean in Python. When you use a name in a program, Python creates,\nchanges, or looks up the name in what is known as a namespace\u2014a place where names\nlive. When we talk about the search for a name\u2019s value in relation to code, the term\nscope refers to a namespace: that is, the location of a name\u2019s assignment in your code\ndetermines the scope of the name\u2019s visibility to your code.\n\nJust about everything related to names, including scope classification, happens at assignment\ntime in Python. As we\u2019ve seen, names in Python spring into existence when\nthey are first assigned values, and they must be assigned before they are used. Because\nnames are not declared ahead of time, Python uses the location of the assignment of a\nname to associate it with (i.e., bind it to) a particular namespace. In other words, the\nplace where you assign a name in your source code determines the namespace it will\nlive in, and hence its scope of visibility.\n\nBesides packaging code, functions add an extra namespace layer to your programs\u2014\nby default, all names assigned inside a function are associated with that function\u2019s\nnamespace, and no other. This means that:  \n\n\n\n\nNames defined inside a def can only be seen by the code within that def. You cannot\neven refer to such names from outside the function.  \n\n\nNames defined inside a def do not clash with variables outside the def, even if the\nsame names are used elsewhere. A name X assigned outside a given def (i.e., in a\ndifferent def or at the top level of a module file) is a completely different variable\nfrom a name X assigned inside that def.  \n\n\n\n\nIn all cases, the scope of a variable (where it can be used) is always determined by where\nit is assigned in your source code and has nothing to do with which functions call which.\nIn fact, as we\u2019ll learn in this chapter, variables may be assigned in three different places,\ncorresponding to three different scopes:\n\n- If a variable is assigned inside a def, it is local to that function.\n\n- If a variable is assigned in an enclosing def, it is nonlocal to nested functions.\n\n- If a variable is assigned outside all defs, it is global to the entire file.\n\nWe call this lexical scoping because variable scopes are determined entirely by the locations\nof the variables in the source code of your program files, not by function calls.\n\nFor example, in the following module file, the X = 99 assignment creates a global variable\nnamed X (visible everywhere in this file), but the X = 88 assignment creates a\nlocal variable X (visible only within the def statement):  \n\n\nX\n \n=\n \n99\n\n\ndef\n \nfunc\n():\n\n    \nX\n \n=\n \n88\n\n\n\n\n\n\nEven though both variables are named X, their scopes make them different. The net\neffect is that function scopes help to avoid name clashes in your programs and help to\nmake functions more self-contained program units.  \n\n\nScope Rules\n\n\nBefore we started writing functions, all the code we wrote was at the top level of a\nmodule (i.e., not nested in a def), so the names we used either lived in the module itself\nor were built-ins predefined by Python (e.g., open). Functions provide nested namespaces\n(scopes) that localize the names they use, such that names inside a function\nwon\u2019t clash with those outside it (in a module or another function). Again, functions\ndefine a local scope, and modules define a global scope. The two scopes are related as\nfollows:\n\n- \nThe enclosing module is a global scope.\n Each module is a global scope\u2014that\nis, a namespace in which variables created (assigned) at the top level of the module\nfile live. Global variables become attributes of a module object to the outside world\nbut can be used as simple variables within a module file.\n- \nThe global scope spans a single file only.\n Don\u2019t be fooled by the word \u201cglobal\u201d\nhere\u2014names at the top level of a file are only global to code within that single file.\nThere is really no notion of a single, all-encompassing global file-based scope in Python. Instead, names are partitioned into modules, and you must always import\na module explicitly if you want to be able to use the names its file defines. When\nyou hear \u201cglobal\u201d in Python, think \u201cmodule.\u201d\n\n- \nEach call to a function creates a new local scope.\n Every time you call a function,\nyou create a new local scope\u2014that is, a namespace in which the names created\ninside that function will usually live. You can think of each def statement (and\nlambda expression) as defining a new local scope, but because Python allows functions\nto call themselves to loop (an advanced technique known as recursion), the\nlocal scope in fact technically corresponds to a function call\u2014in other words, each\ncall creates a new local namespace. Recursion is useful when processing structures\nwhose shapes can\u2019t be predicted ahead of time.\n\n- \nAssigned names are local unless declared global or nonlocal.\n By default, all\nthe names assigned inside a function definition are put in the local scope (the\nnamespace associated with the function call). If you need to assign a name that\nlives at the top level of the module enclosing the function, you can do so by declaring\nit in a global statement inside the function. If you need to assign a name\nthat lives in an enclosing def, as of Python 3.0 you can do so by declaring it in a\nnonlocal statement.\n\n- \nAll other names are enclosing function locals, globals, or built-ins.\n Names\nnot assigned a value in the function definition are assumed to be enclosing scope\nlocals (in an enclosing def), globals (in the enclosing module\u2019s namespace), or builtins\n(in the predefined \nbuiltin\n module Python provides).\n\n\nThere are a few subtleties to note here. First, keep in mind that code typed at the\ninteractive command prompt follows these same rules. You may not know it yet, but\ncode run interactively is really entered into a built-in module called \nmain\n; this\nmodule works just like a module file, but results are echoed as you go. Because of this,\ninteractively created names live in a module, too, and thus follow the normal scope\nrules: they are global to the interactive session. You\u2019ll learn more about modules in the\nnext part of this book.\n\n\nAlso note that any type of assignment within a function classifies a name as local. This\nincludes = statements, module names in import, function names in def, function argument\nnames, and so on. If you assign a name in any way within a def, it will become a\nlocal to that function.\n\n\nConversely, in-place changes to objects do not classify names as locals; only actual name\nassignments do. For instance, if the name L is assigned to a list at the top level of a\nmodule, a statement L = X within a function will classify L as a local, but L.append(X)\nwill not. In the latter case, we are changing the list object that L references, not L itself\u2014\nL is found in the global scope as usual, and Python happily modifies it without requiring\na global (or nonlocal) declaration. As usual, it helps to keep the distinction between\nnames and objects clear: changing an object is not an assignment to a name.\n\n\n\n\nSource:\n \n\n\n  \nLearning Python, Fourth Edition\n by Mark Lutz  - 2009\n\n\n\n\ngood resource : http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html",
            "title": "Scope"
        },
        {
            "location": "/beginner/Scopes/#scopes-python-scope-basics",
            "text": "Now that you\u2019re ready to start writing your own functions, we need to get more formal\nabout what names mean in Python. When you use a name in a program, Python creates,\nchanges, or looks up the name in what is known as a namespace\u2014a place where names\nlive. When we talk about the search for a name\u2019s value in relation to code, the term\nscope refers to a namespace: that is, the location of a name\u2019s assignment in your code\ndetermines the scope of the name\u2019s visibility to your code. \nJust about everything related to names, including scope classification, happens at assignment\ntime in Python. As we\u2019ve seen, names in Python spring into existence when\nthey are first assigned values, and they must be assigned before they are used. Because\nnames are not declared ahead of time, Python uses the location of the assignment of a\nname to associate it with (i.e., bind it to) a particular namespace. In other words, the\nplace where you assign a name in your source code determines the namespace it will\nlive in, and hence its scope of visibility. \nBesides packaging code, functions add an extra namespace layer to your programs\u2014\nby default, all names assigned inside a function are associated with that function\u2019s\nnamespace, and no other. This means that:     Names defined inside a def can only be seen by the code within that def. You cannot\neven refer to such names from outside the function.    Names defined inside a def do not clash with variables outside the def, even if the\nsame names are used elsewhere. A name X assigned outside a given def (i.e., in a\ndifferent def or at the top level of a module file) is a completely different variable\nfrom a name X assigned inside that def.     In all cases, the scope of a variable (where it can be used) is always determined by where\nit is assigned in your source code and has nothing to do with which functions call which.\nIn fact, as we\u2019ll learn in this chapter, variables may be assigned in three different places,\ncorresponding to three different scopes: \n- If a variable is assigned inside a def, it is local to that function. \n- If a variable is assigned in an enclosing def, it is nonlocal to nested functions. \n- If a variable is assigned outside all defs, it is global to the entire file. \nWe call this lexical scoping because variable scopes are determined entirely by the locations\nof the variables in the source code of your program files, not by function calls. \nFor example, in the following module file, the X = 99 assignment creates a global variable\nnamed X (visible everywhere in this file), but the X = 88 assignment creates a\nlocal variable X (visible only within the def statement):    X   =   99  def   func (): \n     X   =   88   Even though both variables are named X, their scopes make them different. The net\neffect is that function scopes help to avoid name clashes in your programs and help to\nmake functions more self-contained program units.",
            "title": "Scopes - Python Scope Basics"
        },
        {
            "location": "/beginner/Scopes/#scope-rules",
            "text": "Before we started writing functions, all the code we wrote was at the top level of a\nmodule (i.e., not nested in a def), so the names we used either lived in the module itself\nor were built-ins predefined by Python (e.g., open). Functions provide nested namespaces\n(scopes) that localize the names they use, such that names inside a function\nwon\u2019t clash with those outside it (in a module or another function). Again, functions\ndefine a local scope, and modules define a global scope. The two scopes are related as\nfollows: \n-  The enclosing module is a global scope.  Each module is a global scope\u2014that\nis, a namespace in which variables created (assigned) at the top level of the module\nfile live. Global variables become attributes of a module object to the outside world\nbut can be used as simple variables within a module file.\n-  The global scope spans a single file only.  Don\u2019t be fooled by the word \u201cglobal\u201d\nhere\u2014names at the top level of a file are only global to code within that single file.\nThere is really no notion of a single, all-encompassing global file-based scope in Python. Instead, names are partitioned into modules, and you must always import\na module explicitly if you want to be able to use the names its file defines. When\nyou hear \u201cglobal\u201d in Python, think \u201cmodule.\u201d \n-  Each call to a function creates a new local scope.  Every time you call a function,\nyou create a new local scope\u2014that is, a namespace in which the names created\ninside that function will usually live. You can think of each def statement (and\nlambda expression) as defining a new local scope, but because Python allows functions\nto call themselves to loop (an advanced technique known as recursion), the\nlocal scope in fact technically corresponds to a function call\u2014in other words, each\ncall creates a new local namespace. Recursion is useful when processing structures\nwhose shapes can\u2019t be predicted ahead of time. \n-  Assigned names are local unless declared global or nonlocal.  By default, all\nthe names assigned inside a function definition are put in the local scope (the\nnamespace associated with the function call). If you need to assign a name that\nlives at the top level of the module enclosing the function, you can do so by declaring\nit in a global statement inside the function. If you need to assign a name\nthat lives in an enclosing def, as of Python 3.0 you can do so by declaring it in a\nnonlocal statement. \n-  All other names are enclosing function locals, globals, or built-ins.  Names\nnot assigned a value in the function definition are assumed to be enclosing scope\nlocals (in an enclosing def), globals (in the enclosing module\u2019s namespace), or builtins\n(in the predefined  builtin  module Python provides).  There are a few subtleties to note here. First, keep in mind that code typed at the\ninteractive command prompt follows these same rules. You may not know it yet, but\ncode run interactively is really entered into a built-in module called  main ; this\nmodule works just like a module file, but results are echoed as you go. Because of this,\ninteractively created names live in a module, too, and thus follow the normal scope\nrules: they are global to the interactive session. You\u2019ll learn more about modules in the\nnext part of this book.  Also note that any type of assignment within a function classifies a name as local. This\nincludes = statements, module names in import, function names in def, function argument\nnames, and so on. If you assign a name in any way within a def, it will become a\nlocal to that function.  Conversely, in-place changes to objects do not classify names as locals; only actual name\nassignments do. For instance, if the name L is assigned to a list at the top level of a\nmodule, a statement L = X within a function will classify L as a local, but L.append(X)\nwill not. In the latter case, we are changing the list object that L references, not L itself\u2014\nL is found in the global scope as usual, and Python happily modifies it without requiring\na global (or nonlocal) declaration. As usual, it helps to keep the distinction between\nnames and objects clear: changing an object is not an assignment to a name.   Source:       Learning Python, Fourth Edition  by Mark Lutz  - 2009   good resource : http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html",
            "title": "Scope Rules"
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/",
            "text": "A Beginner's Guide to Python's Namespaces, Scope Resolution, and the LEGB Rule\n\n\nIntroduction to namespaces and scopes\n\n\nNamespaces\n\n\nRoughly speaking, namespaces are just containers for mapping names to objects. As you might have already heard, everything in Python - literals, lists, dictionaries, functions, classes, etc. - is an object.\nSuch a \u201cname-to-object\u201d mapping allows us to access an object by a name that we\u2019ve assigned to it. E.g., if we make a simple string assignment via a_string = \"Hello string\", we created a reference to the \"Hello string\" object, and henceforth we can access via its variable name a_string.\n\n\nWe can picture a namespace as a Python dictionary structure, where the dictionary keys represent the names and the dictionary values the object itself (and this is also how namespaces are currently implemented in Python), e.g.,\n\n\na_namespace\n \n=\n \n{\n'name_a'\n:\nobject_1\n,\n \n'name_b'\n:\nobject_2\n,\n \n...\n \n}\n\n\n\n\n\n\nNow, the tricky part is that we have multiple independent namespaces in Python, and names can be reused for different namespaces (only the objects are unique, for example:\n\n\na_namespace\n \n=\n \n{\n'name_a'\n:\nobject_1\n,\n \n'name_b'\n:\nobject_2\n,\n \n...\n}\n\n\nb_namespace\n \n=\n \n{\n'name_a'\n:\nobject_3\n,\n \n'name_b'\n:\nobject_4\n,\n \n...\n}\n\n\n\n\n\n\nFor example, everytime we call a for-loop or define a function, it will create its own namespace. Namespaces also have different levels of hierarchy (the so-called \u201cscope\u201d), which we will discuss in more detail in the next section.\n\n\nScope\n\n\nIn the section above, we have learned that namespaces can exist independently from each other and that they are structured in a certain hierarchy, which brings us to the concept of \u201cscope\u201d. The \u201cscope\u201d in Python defines the \u201chierarchy level\u201d in which we search namespaces for certain \u201cname-to-object\u201d mappings.\nFor example, let us consider the following code:  \n\n\ni\n \n=\n \n1\n\n\n\ndef\n \nfoo\n():\n\n    \ni\n \n=\n \n5\n\n    \nprint\n(\ni\n,\n \n'in foo()'\n)\n\n\n\nprint\n(\ni\n,\n \n'global'\n)\n\n\n\nfoo\n()\n\n\n\n'''\n\n\noutput:\n\n\n1 global\n\n\n5 in foo()\n\n\n'''\n\n\n\n\n\n\nHere, we just defined the variable name i twice, once on the foo function.\n- foo_namespace = {'i':object_3, ...}\n- global_namespace = {'i':object_1, 'name_b':object_2, ...}\n\n\nSo, how does Python know which namespace it has to search if we want to print the value of the variable i? This is where Python\u2019s LEGB-rule comes into play, which we will discuss in the next section.\n\n\nTip:\n\n\nIf we want to print out the dictionary mapping of the global and local variables, we can use the the functions global() and local()\n\n\n#print(globals()) # prints global namespace\n\n\n#print(locals()) # prints local namespace\n\n\n\nglob\n \n=\n \n1\n\n\n\ndef\n \nfoo\n():\n\n    \nloc\n \n=\n \n5\n\n    \nprint\n(\n'loc in foo():'\n,\n \n'loc'\n \nin\n \nlocals\n())\n\n\n\nfoo\n()\n\n\nprint\n(\n'loc in global:'\n,\n \n'loc'\n \nin\n \nglobals\n())\n    \n\nprint\n(\n'glob in global:'\n,\n \n'foo'\n \nin\n \nglobals\n())\n\n\n\n'''\n\n\nloc in foo(): True\n\n\nloc in global: False\n\n\nglob in global: True\n\n\n'''\n\n\n\n\n\n\nScope resolution for variable names via the LEGB rule.\n\n\nWe have seen that multiple namespaces can exist independently from each other and that they can contain the same variable names on different hierachy levels. The \u201cscope\u201d defines on which hierarchy level Python searches for a particular \u201cvariable name\u201d for its associated object. Now, the next question is: \u201cIn which order does Python search the different levels of namespaces before it finds the name-to-object\u2019 mapping?\u201d\nTo answer is: It uses the LEGB-rule, which stands for\n\n\nLocal -> Enclosed -> Global -> Built-in,\n\n\nwhere the arrows should denote the direction of the namespace-hierarchy search order.\n\n\n\n\nLocal can be inside a function or class method, for example.\n\n\nEnclosed can be its enclosing function, e.g., if a function is wrapped inside another function.\n\n\nGlobal refers to the uppermost level of the executing script itself, and\n\n\nBuilt-in are special names that Python reserves for itself.\n\n\n\n\nSo, if a particular name:object mapping cannot be found in the local namespaces, the namespaces of the enclosed scope are being searched next. If the search in the enclosed scope is unsuccessful, too, Python moves on to the global namespace, and eventually, it will search the built-in namespace (side note: if a name cannot found in any of the namespaces, a NameError will is raised).\n\n\nNamespaces can also be further nested, for example if we import modules, or if we are defining new classes. In those cases we have to use prefixes to access those nested namespaces. Let me illustrate this concept in the following code block:\n\n\nimport\n \nnumpy\n\n\nimport\n \nmath\n\n\nimport\n \nscipy\n\n\n\nprint\n(\nmath\n.\npi\n,\n \n'from the math module'\n)\n\n\nprint\n(\nnumpy\n.\npi\n,\n \n'from the numpy package'\n)\n\n\nprint\n(\nscipy\n.\npi\n,\n \n'from the scipy package'\n)\n\n\n\n\n'''\n\n\n3.141592653589793 from the math module\n\n\n3.141592653589793 from the numpy package\n\n\n3.141592653589793 from the scipy package\n\n\n'''\n\n\n\n\n\n\n(This is also why we have to be careful if we import modules via \u201cfrom a_module import *\u201d, since it loads the variable names into the global namespace and could potentially overwrite already existing variable names)\n\n\n\n\n1. LG - Local and Global scopes\n\n\nAs a warm-up exercise, let us first forget about the enclosed (E) and built-in (B) scopes in the LEGB rule and only take a look at LG - the local and global scopes.\nWhat does the following code print?\n\n\na_var\n \n=\n \n'global variable'\n\n\n\ndef\n \na_func\n():\n\n    \nprint\n(\na_var\n,\n \n'[ a_var inside a_func() ]'\n)\n\n\n\na_func\n()\n\n\nprint\n(\na_var\n,\n \n'[ a_var outside a_func() ]'\n)\n\n\n\n'''\n\n\nanswer:\n\n\nglobal value [ a_var inside a_func() ]  \n\n\nglobal value [ a_var outside a_func() ]\n\n\n'''\n\n\n\n\n\n\nHere is why:\n\n\nWe call a_func() first, which is supposed to print the value of a_var. According to the LEGB rule, the function will first look in its own local scope (L) if a_var is defined there. Since a_func() does not define its own a_var, it will look one-level above in the global scope (G) in which a_var has been defined previously. \n\n\nExample 1.2\nNow, let us define the variable a_var in the global and the local scope.\nCan you guess what the following code will produce?\n\n\na_var\n \n=\n \n'global value'\n\n\n\ndef\n \na_func\n():\n\n    \na_var\n \n=\n \n'local value'\n\n    \nprint\n(\na_var\n,\n \n'[ a_var inside a_func() ]'\n)\n\n\n\na_func\n()\n\n\nprint\n(\na_var\n,\n \n'[ a_var outside a_func() ]'\n)\n\n\n'''\n\n\nanswer:\n\n\nlocal value [ a_var inside a_func() ]\n\n\nglobal value [ a_var outside a_func() ]\n\n\n'''\n\n\n\n\n\n\nHere is why:\n\n\nWhen we call a_func(), it will first look in its local scope (L) for a_var, since a_var is defined in the local scope of a_func, its assigned value local variable is printed. Note that this doesn\u2019t affect the global variable, which is in a different scope.\n\n\nHowever, it is also possible to modify the global by, e.g., re-assigning a new value to it if we use the global keyword as the following example will illustrate:\n\n\na_var\n \n=\n \n'global value'\n\n\n\ndef\n \na_func\n():\n\n    \nglobal\n \na_var\n\n    \na_var\n \n=\n \n'local value'\n\n    \nprint\n(\na_var\n,\n \n'[ a_var inside a_func() ]'\n)\n\n\n\nprint\n(\na_var\n,\n \n'[ a_var outside a_func() ]'\n)\n\n\na_func\n()\n\n\nprint\n(\na_var\n,\n \n'[ a_var outside a_func() ]'\n)\n\n\n'''\n\n\noutput:\n\n\nglobal value [ a_var outside a_func() ]\n\n\nlocal value [ a_var inside a_func() ]\n\n\nlocal value [ a_var outside a_func() ]\n\n\n'''\n\n\n\n\n\n\nBut we have to be careful about the order: it is easy to raise an UnboundLocalError if we don\u2019t explicitly tell Python that we want to use the global scope and try to modify a variable\u2019s value (remember, the right side of an assignment operation is executed first):\n\n\na_var\n \n=\n \n1\n\n\n\ndef\n \na_func\n():\n\n    \na_var\n \n=\n \na_var\n \n+\n \n1\n\n    \nprint\n(\na_var\n,\n \n'[ a_var inside a_func() ]'\n)\n\n\n\nprint\n(\na_var\n,\n \n'[ a_var outside a_func() ]'\n)\n\n\na_func\n()\n\n\n\n'''\n\n\noutput:\n\n\n---------------------------------------------------------------------------\n\n\nUnboundLocalError                         Traceback (most recent call last)\n\n\n'''\n\n\n\n\n\n\n2. LEG - Local, Enclosed, and Global scope\n\n\nNow, let us introduce the concept of the enclosed (E) scope. Following the order \u201cLocal -> Enclosed -> Global\u201d, can you guess what the following code will print?\n\n\nExample 2.1\n\n\na_var\n \n=\n \n'global value'\n\n\n\ndef\n \nouter\n():\n\n    \na_var\n \n=\n \n'enclosed value'\n\n\n    \ndef\n \ninner\n():\n\n        \na_var\n \n=\n \n'local value'\n\n        \nprint\n(\na_var\n)\n\n\n    \ninner\n()\n\n\n\nouter\n()\n\n\n'''\n\n\noutput:\n\n\nlocal value\n\n\n'''\n\n\n\n\n\n\nHere is why:\n\n\nLet us quickly recapitulate what we just did: We called outer(), which defined the variable a_var locally (next to an existing a_var in the global scope). Next, the outer() function called inner(), which in turn defined a variable with of name a_var as well. The print() function inside inner() searched in the local scope first (L->E) before it went up in the scope hierarchy, and therefore it printed the value that was assigned in the local scope.\n\n\nSimilar to the concept of the global keyword, which we have seen in the section above, we can use the keyword nonlocal inside the inner function to explicitly access a variable from the outer (enclosed) scope in order to modify its value.\nNote that the nonlocal keyword was added in Python 3.x and is not implemented in Python 2.x (yet).\n\n\na_var\n \n=\n \n'global value'\n\n\n\ndef\n \nouter\n():\n\n       \na_var\n \n=\n \n'local value'\n\n       \nprint\n(\n'outer before:'\n,\n \na_var\n)\n\n       \ndef\n \ninner\n():\n\n           \nnonlocal\n \na_var\n\n           \na_var\n \n=\n \n'inner value'\n\n           \nprint\n(\n'in inner():'\n,\n \na_var\n)\n\n       \ninner\n()\n\n       \nprint\n(\n\"outer after:\"\n,\n \na_var\n)\n\n\nouter\n()\n\n\n'''\n\n\noutput:\n\n\nouter before: local value\n\n\nin inner(): inner value\n\n\nouter after: inner value\n\n\n'''\n\n\n\n\n\n\n3. LEGB - Local, Enclosed, Global, Built-in\n\n\nTo wrap up the LEGB rule, let us come to the built-in scope. Here, we will define our \u201cown\u201d length-function, which happens to bear the same name as the in-built len() function. What outcome do you excpect if we\u2019d execute the following code?\n\n\na_var\n \n=\n \n'global variable'\n\n\n\ndef\n \nlen\n(\nin_var\n):\n\n    \nprint\n(\n'called my len() function'\n)\n\n    \nl\n \n=\n \n0\n\n    \nfor\n \ni\n \nin\n \nin_var\n:\n\n        \nl\n \n+=\n \n1\n\n    \nreturn\n \nl\n\n\n\ndef\n \na_func\n(\nin_var\n):\n\n    \nlen_in_var\n \n=\n \nlen\n(\nin_var\n)\n\n    \nprint\n(\n'Input variable is of length'\n,\n \nlen_in_var\n)\n\n\n\na_func\n(\n'Hello, World!'\n)\n\n\n'''\n\n\noutput:\n\n\ncalled my len() function\n\n\nInput variable is of length 13\n\n\n'''\n\n\n\n\n\n\nHere is why:\n\n\nSince the exact same names can be used to map names to different objects - as long as the names are in different name spaces - there is no problem of reusing the name len to define our own length function (this is just for demonstration pruposes, it is NOT recommended). As we go up in Python\u2019s L -> E -> G -> B hierarchy, the function a_func() finds len() already in the global scope (G) first before it attempts to search the built-in (B) namespace.\n\n\nSelf-assessment exercise\n\n\nNow, after we went through a couple of exercises, let us quickly check where we are. So, one more time: What would the following code print out?\n\n\na\n \n=\n \n'global'\n\n\n\ndef\n \nouter\n():\n\n\n    \ndef\n \nlen\n(\nin_var\n):\n\n        \nprint\n(\n'called my len() function: '\n,\n \nend\n=\n\"\"\n)\n\n        \nl\n \n=\n \n0\n\n        \nfor\n \ni\n \nin\n \nin_var\n:\n\n            \nl\n \n+=\n \n1\n\n        \nreturn\n \nl\n\n\n    \na\n \n=\n \n'local'\n\n\n    \ndef\n \ninner\n():\n\n        \nglobal\n \nlen\n\n        \nnonlocal\n \na\n\n        \na\n \n+=\n \n' variable'\n\n    \ninner\n()\n\n    \nprint\n(\n'a is'\n,\n \na\n)\n\n    \nprint\n(\nlen\n(\na\n))\n\n\n\n\nouter\n()\n\n\n\nprint\n(\nlen\n(\na\n))\n\n\nprint\n(\n'a is'\n,\n \na\n)\n\n\n\n\n'''\n\n\noutput:\n\n\na is local variable\n\n\ncalled my len() function: 14\n\n\n6\n\n\na is global\n\n\n'''\n\n\n\n\n\n\nConclusion\n\n\nI hope this short tutorial was helpful to understand the basic concept of Python\u2019s scope resolution order using the LEGB rule. I want to encourage you (as a little self-assessment exercise) to look at the code snippets again tomorrow and check if you can correctly predict all their outcomes.\n\n\nA rule of thumb\n\n\nIn practice, it is usually a bad idea to modify global variables inside the function scope, since it often be the cause of confusion and weird errors that are hard to debug.\nIf you want to modify a global variable via a function, it is recommended to pass it as an argument and reassign the return-value.\nFor example:\n\n\na_var\n \n=\n \n2\n\n\n\ndef\n \na_func\n(\nsome_var\n):\n\n    \nreturn\n \n2\n**\n3\n\n\n\na_var\n \n=\n \na_func\n(\na_var\n)\n\n\nprint\n(\na_var\n)\n\n\n\n'''\n\n\noutput:\n\n\n8\n\n\n'''\n\n\n\n\n\n\n\n\nSource:\n \n\n\n http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html",
            "title": "Scopes, Namespaces and LEGB Rule"
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/#a-beginners-guide-to-pythons-namespaces-scope-resolution-and-the-legb-rule",
            "text": "",
            "title": "A Beginner's Guide to Python's Namespaces, Scope Resolution, and the LEGB Rule"
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/#introduction-to-namespaces-and-scopes",
            "text": "",
            "title": "Introduction to namespaces and scopes"
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/#namespaces",
            "text": "Roughly speaking, namespaces are just containers for mapping names to objects. As you might have already heard, everything in Python - literals, lists, dictionaries, functions, classes, etc. - is an object.\nSuch a \u201cname-to-object\u201d mapping allows us to access an object by a name that we\u2019ve assigned to it. E.g., if we make a simple string assignment via a_string = \"Hello string\", we created a reference to the \"Hello string\" object, and henceforth we can access via its variable name a_string.  We can picture a namespace as a Python dictionary structure, where the dictionary keys represent the names and the dictionary values the object itself (and this is also how namespaces are currently implemented in Python), e.g.,  a_namespace   =   { 'name_a' : object_1 ,   'name_b' : object_2 ,   ...   }   Now, the tricky part is that we have multiple independent namespaces in Python, and names can be reused for different namespaces (only the objects are unique, for example:  a_namespace   =   { 'name_a' : object_1 ,   'name_b' : object_2 ,   ... }  b_namespace   =   { 'name_a' : object_3 ,   'name_b' : object_4 ,   ... }   For example, everytime we call a for-loop or define a function, it will create its own namespace. Namespaces also have different levels of hierarchy (the so-called \u201cscope\u201d), which we will discuss in more detail in the next section.",
            "title": "Namespaces"
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/#scope",
            "text": "In the section above, we have learned that namespaces can exist independently from each other and that they are structured in a certain hierarchy, which brings us to the concept of \u201cscope\u201d. The \u201cscope\u201d in Python defines the \u201chierarchy level\u201d in which we search namespaces for certain \u201cname-to-object\u201d mappings.\nFor example, let us consider the following code:    i   =   1  def   foo (): \n     i   =   5 \n     print ( i ,   'in foo()' )  print ( i ,   'global' )  foo ()  '''  output:  1 global  5 in foo()  '''   Here, we just defined the variable name i twice, once on the foo function.\n- foo_namespace = {'i':object_3, ...}\n- global_namespace = {'i':object_1, 'name_b':object_2, ...}  So, how does Python know which namespace it has to search if we want to print the value of the variable i? This is where Python\u2019s LEGB-rule comes into play, which we will discuss in the next section.",
            "title": "Scope"
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/#tip",
            "text": "If we want to print out the dictionary mapping of the global and local variables, we can use the the functions global() and local()  #print(globals()) # prints global namespace  #print(locals()) # prints local namespace  glob   =   1  def   foo (): \n     loc   =   5 \n     print ( 'loc in foo():' ,   'loc'   in   locals ())  foo ()  print ( 'loc in global:' ,   'loc'   in   globals ())      print ( 'glob in global:' ,   'foo'   in   globals ())  '''  loc in foo(): True  loc in global: False  glob in global: True  '''",
            "title": "Tip:"
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/#scope-resolution-for-variable-names-via-the-legb-rule",
            "text": "We have seen that multiple namespaces can exist independently from each other and that they can contain the same variable names on different hierachy levels. The \u201cscope\u201d defines on which hierarchy level Python searches for a particular \u201cvariable name\u201d for its associated object. Now, the next question is: \u201cIn which order does Python search the different levels of namespaces before it finds the name-to-object\u2019 mapping?\u201d\nTo answer is: It uses the LEGB-rule, which stands for  Local -> Enclosed -> Global -> Built-in,  where the arrows should denote the direction of the namespace-hierarchy search order.   Local can be inside a function or class method, for example.  Enclosed can be its enclosing function, e.g., if a function is wrapped inside another function.  Global refers to the uppermost level of the executing script itself, and  Built-in are special names that Python reserves for itself.   So, if a particular name:object mapping cannot be found in the local namespaces, the namespaces of the enclosed scope are being searched next. If the search in the enclosed scope is unsuccessful, too, Python moves on to the global namespace, and eventually, it will search the built-in namespace (side note: if a name cannot found in any of the namespaces, a NameError will is raised).  Namespaces can also be further nested, for example if we import modules, or if we are defining new classes. In those cases we have to use prefixes to access those nested namespaces. Let me illustrate this concept in the following code block:  import   numpy  import   math  import   scipy  print ( math . pi ,   'from the math module' )  print ( numpy . pi ,   'from the numpy package' )  print ( scipy . pi ,   'from the scipy package' )  '''  3.141592653589793 from the math module  3.141592653589793 from the numpy package  3.141592653589793 from the scipy package  '''   (This is also why we have to be careful if we import modules via \u201cfrom a_module import *\u201d, since it loads the variable names into the global namespace and could potentially overwrite already existing variable names)",
            "title": "Scope resolution for variable names via the LEGB rule."
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/#1-lg-local-and-global-scopes",
            "text": "As a warm-up exercise, let us first forget about the enclosed (E) and built-in (B) scopes in the LEGB rule and only take a look at LG - the local and global scopes.\nWhat does the following code print?  a_var   =   'global variable'  def   a_func (): \n     print ( a_var ,   '[ a_var inside a_func() ]' )  a_func ()  print ( a_var ,   '[ a_var outside a_func() ]' )  '''  answer:  global value [ a_var inside a_func() ]    global value [ a_var outside a_func() ]  '''   Here is why:  We call a_func() first, which is supposed to print the value of a_var. According to the LEGB rule, the function will first look in its own local scope (L) if a_var is defined there. Since a_func() does not define its own a_var, it will look one-level above in the global scope (G) in which a_var has been defined previously.   Example 1.2\nNow, let us define the variable a_var in the global and the local scope.\nCan you guess what the following code will produce?  a_var   =   'global value'  def   a_func (): \n     a_var   =   'local value' \n     print ( a_var ,   '[ a_var inside a_func() ]' )  a_func ()  print ( a_var ,   '[ a_var outside a_func() ]' )  '''  answer:  local value [ a_var inside a_func() ]  global value [ a_var outside a_func() ]  '''   Here is why:  When we call a_func(), it will first look in its local scope (L) for a_var, since a_var is defined in the local scope of a_func, its assigned value local variable is printed. Note that this doesn\u2019t affect the global variable, which is in a different scope.  However, it is also possible to modify the global by, e.g., re-assigning a new value to it if we use the global keyword as the following example will illustrate:  a_var   =   'global value'  def   a_func (): \n     global   a_var \n     a_var   =   'local value' \n     print ( a_var ,   '[ a_var inside a_func() ]' )  print ( a_var ,   '[ a_var outside a_func() ]' )  a_func ()  print ( a_var ,   '[ a_var outside a_func() ]' )  '''  output:  global value [ a_var outside a_func() ]  local value [ a_var inside a_func() ]  local value [ a_var outside a_func() ]  '''   But we have to be careful about the order: it is easy to raise an UnboundLocalError if we don\u2019t explicitly tell Python that we want to use the global scope and try to modify a variable\u2019s value (remember, the right side of an assignment operation is executed first):  a_var   =   1  def   a_func (): \n     a_var   =   a_var   +   1 \n     print ( a_var ,   '[ a_var inside a_func() ]' )  print ( a_var ,   '[ a_var outside a_func() ]' )  a_func ()  '''  output:  ---------------------------------------------------------------------------  UnboundLocalError                         Traceback (most recent call last)  '''",
            "title": "1. LG - Local and Global scopes"
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/#2-leg-local-enclosed-and-global-scope",
            "text": "Now, let us introduce the concept of the enclosed (E) scope. Following the order \u201cLocal -> Enclosed -> Global\u201d, can you guess what the following code will print?  Example 2.1  a_var   =   'global value'  def   outer (): \n     a_var   =   'enclosed value' \n\n     def   inner (): \n         a_var   =   'local value' \n         print ( a_var ) \n\n     inner ()  outer ()  '''  output:  local value  '''   Here is why:  Let us quickly recapitulate what we just did: We called outer(), which defined the variable a_var locally (next to an existing a_var in the global scope). Next, the outer() function called inner(), which in turn defined a variable with of name a_var as well. The print() function inside inner() searched in the local scope first (L->E) before it went up in the scope hierarchy, and therefore it printed the value that was assigned in the local scope.  Similar to the concept of the global keyword, which we have seen in the section above, we can use the keyword nonlocal inside the inner function to explicitly access a variable from the outer (enclosed) scope in order to modify its value.\nNote that the nonlocal keyword was added in Python 3.x and is not implemented in Python 2.x (yet).  a_var   =   'global value'  def   outer (): \n        a_var   =   'local value' \n        print ( 'outer before:' ,   a_var ) \n        def   inner (): \n            nonlocal   a_var \n            a_var   =   'inner value' \n            print ( 'in inner():' ,   a_var ) \n        inner () \n        print ( \"outer after:\" ,   a_var )  outer ()  '''  output:  outer before: local value  in inner(): inner value  outer after: inner value  '''",
            "title": "2. LEG - Local, Enclosed, and Global scope"
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/#3-legb-local-enclosed-global-built-in",
            "text": "To wrap up the LEGB rule, let us come to the built-in scope. Here, we will define our \u201cown\u201d length-function, which happens to bear the same name as the in-built len() function. What outcome do you excpect if we\u2019d execute the following code?  a_var   =   'global variable'  def   len ( in_var ): \n     print ( 'called my len() function' ) \n     l   =   0 \n     for   i   in   in_var : \n         l   +=   1 \n     return   l  def   a_func ( in_var ): \n     len_in_var   =   len ( in_var ) \n     print ( 'Input variable is of length' ,   len_in_var )  a_func ( 'Hello, World!' )  '''  output:  called my len() function  Input variable is of length 13  '''   Here is why:  Since the exact same names can be used to map names to different objects - as long as the names are in different name spaces - there is no problem of reusing the name len to define our own length function (this is just for demonstration pruposes, it is NOT recommended). As we go up in Python\u2019s L -> E -> G -> B hierarchy, the function a_func() finds len() already in the global scope (G) first before it attempts to search the built-in (B) namespace.",
            "title": "3. LEGB - Local, Enclosed, Global, Built-in"
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/#self-assessment-exercise",
            "text": "Now, after we went through a couple of exercises, let us quickly check where we are. So, one more time: What would the following code print out?  a   =   'global'  def   outer (): \n\n     def   len ( in_var ): \n         print ( 'called my len() function: ' ,   end = \"\" ) \n         l   =   0 \n         for   i   in   in_var : \n             l   +=   1 \n         return   l \n\n     a   =   'local' \n\n     def   inner (): \n         global   len \n         nonlocal   a \n         a   +=   ' variable' \n     inner () \n     print ( 'a is' ,   a ) \n     print ( len ( a ))  outer ()  print ( len ( a ))  print ( 'a is' ,   a )  '''  output:  a is local variable  called my len() function: 14  6  a is global  '''",
            "title": "Self-assessment exercise"
        },
        {
            "location": "/beginner/Scopes_Namespaces_LEGB_rule/#conclusion",
            "text": "I hope this short tutorial was helpful to understand the basic concept of Python\u2019s scope resolution order using the LEGB rule. I want to encourage you (as a little self-assessment exercise) to look at the code snippets again tomorrow and check if you can correctly predict all their outcomes.  A rule of thumb  In practice, it is usually a bad idea to modify global variables inside the function scope, since it often be the cause of confusion and weird errors that are hard to debug.\nIf you want to modify a global variable via a function, it is recommended to pass it as an argument and reassign the return-value.\nFor example:  a_var   =   2  def   a_func ( some_var ): \n     return   2 ** 3  a_var   =   a_func ( a_var )  print ( a_var )  '''  output:  8  '''    Source:     http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html",
            "title": "Conclusion"
        },
        {
            "location": "/advanced/Context_Managers/",
            "text": "How Exactly Do Context Managers Work?\n\n\nContext managers (PEP 343) are pretty important in Python. You probably use one every time you open a file:\n\n\nwith\n \nopen\n(\n'cake.txt'\n)\n \nas\n \nc\n:\n\n    \ngobble_gobble\n(\nc\n)\n\n\n\n\n\n\nBut how well do you understand what\u2019s going on behind the scenes?\n\n\nCONTEXT MANAGER CLASSES\n\n\nIt\u2019s actually quite simple. A context manager is a class that implements an \n__enter__\n and an \n__exit__\n method.\n\n\nLet\u2019s imagine you want to you print a line of text to the console surrounded with asterisks. Here\u2019s a context manager to do it:\n\n\nclass\n \nasterisks\n():\n\n    \ndef\n \n__enter__\n(\nself\n):\n\n        \nprint\n(\n'*'\n \n*\n \n32\n)\n\n\n    \ndef\n \n__exit__\n(\nself\n,\n \nexc_type\n,\n \nexc_val\n,\n \nexc_tb\n):\n\n        \nprint\n(\n'*'\n \n*\n \n32\n)\n\n\n\n\n\n\nThe \n__exit__\n method takes three arguments apart from \nself\n. Those arguments contain information about any errors that occurred inside the \nwith\n block.\n\n\nYou can use \nasterisks\n in the same way as any of the built-in context managers:\n\n\n>>>\n \nwith\n \nasterisks\n():\n\n\n>>>\n     \nprint\n(\n\"Context Managers Rock!\"\n)\n\n\n********************************\n\n\nContext\n \nManagers\n \nRock\n!\n\n\n********************************\n\n\n\n\n\n\nACCESSING THE CONTEXT INSIDE THE WITH BLOCK\n\n\nIf you need to get something back and use it inside the with block \u2013 such as a file descriptor \u2013 you simply return it from \n__enter__\n:\n\n\nclass\n \nmyopen\n():\n\n    \ndef\n \n__init__\n(\nself\n,\n \nfilename\n,\n \nfilemode\n):\n\n        \nself\n.\nfilename\n \n=\n \nfilename\n\n        \nself\n.\nfilemode\n \n=\n \nfilemode\n\n\n    \ndef\n \n__enter__\n(\nself\n):\n\n        \nself\n.\nfile\n \n=\n \nopen\n(\nself\n.\nfilename\n,\n \nself\n.\nfilemode\n)\n\n        \nreturn\n \nself\n.\nfile\n\n\n    \ndef\n \n__exit__\n(\nself\n,\n \nexc_type\n,\n \nexc_val\n,\n \nexc_tb\n):\n\n        \nself\n.\nfile\n.\nclose\n()\n\n\n\n\n\n\nmyopen\n works identically to the built-in \nopen\n:\n\n\nwith\n \nmyopen\n(\n\"beer.txt\"\n)\n \nas\n \nb\n:\n\n    \nguzzle_guzzle\n(\nb\n)\n\n\n\n\n\n\nTHE CONTEXTMANAGER DECORATOR\n\n\nThankfully, you don\u2019t have to implement a class every time. The \ncontextlib\n package has a \ncontextmanager\n decorator that you can apply to generators to automatically transform them into context managers:\n\n\nfrom\n \ncontextlib\n \nimport\n \ncontextmanager\n\n\n\n@contextmanager\n\n\ndef\n \nspoiler\n():\n\n    \nprint\n(\n'<spoiler>'\n)\n\n    \nyield\n\n    \nprint\n(\n'</spoiler>'\n)\n\n\n\n\n\n\nThe code before \nyield\n corresponds to \n__enter__\n and the code after \nyield\n corresponds to \n__exit__\n. A context manager generator should have exactly one \nyield\n in it.\n\n\nIt works the same as the class version:\n\n\n>>>\n \nwith\n \nspoiler\n():\n\n\n>>>\n     \nprint\n(\n\"Jon Snow is Luke's father.\"\n)\n\n\n<\nspoiler\n>\n\n\nJon\n \nSnow\n \nis\n \nLuke\n's father.\n\n\n</\nspoiler\n>\n\n\n\n\n\n\nROLL YOUR OWN CONTEXTMANAGER DECORATOR\n\n\nThe implementation in \ncontextlib\n is complicated, but it\u2019s not hard to write something that works similarly with the exception of a few edge cases:\n\n\ndef\n \ncontextmanager\n(\ngen\n):\n\n    \nclass\n \nCMWrapper\n(\nobject\n):\n\n        \ndef\n \n__init__\n(\nself\n,\n \nwrapped\n):\n\n            \nself\n.\ngenerator\n \n=\n \nwrapped\n\n\n        \ndef\n \n__enter__\n(\nself\n):\n\n            \nreturn\n \nnext\n(\nself\n.\ngenerator\n)\n\n\n        \ndef\n \n__exit__\n(\nself\n,\n \nex_type\n,\n \nvalue\n,\n \ntraceback\n):\n\n            \ntry\n:\n\n                \nnext\n(\nself\n.\ngenerator\n)\n\n            \nexcept\n \nStopIteration\n:\n\n                \npass\n\n\n    \ndef\n \ninner\n(\n*\nargs\n,\n \n**\nkwargs\n):\n\n        \nreturn\n \nCMWrapper\n(\ngen\n(\n*\nargs\n,\n \n**\nkwargs\n))\n\n\n    \nreturn\n \ninner\n\n\n\n\n\n\nIt\u2019s not as robust as the real implementation, but it should be understandable. Here are the key points:\n- The inner function instantiates a copy of the nested CMWrapper class with a handle on the generator passed into the decorator.\n\n- \n__enter__\n calls next() on the generator and returns the yielded value so it can be used in the with block.\n\n- \n__exit__\n calls next() again and catches the StopIteration exception that the generator throws when it finishes.  \n\n\nThat\u2019s it for now. If you want to learn more about context managers, I recommend you take a look at the code for \ncontextlib\n.\n\n\n\n\nSource:\n \n\n\n https://www.smallsurething.com/how-exactly-do-context-managers-work/\n\n\n\n\nPython Context Managers and the \"with\" Statement (\nenter\n & \nexit\n)    \nVIDEO",
            "title": "Context Managers"
        },
        {
            "location": "/advanced/Context_Managers/#how-exactly-do-context-managers-work",
            "text": "Context managers (PEP 343) are pretty important in Python. You probably use one every time you open a file:  with   open ( 'cake.txt' )   as   c : \n     gobble_gobble ( c )   But how well do you understand what\u2019s going on behind the scenes?",
            "title": "How Exactly Do Context Managers Work?"
        },
        {
            "location": "/advanced/Context_Managers/#context-manager-classes",
            "text": "It\u2019s actually quite simple. A context manager is a class that implements an  __enter__  and an  __exit__  method.  Let\u2019s imagine you want to you print a line of text to the console surrounded with asterisks. Here\u2019s a context manager to do it:  class   asterisks (): \n     def   __enter__ ( self ): \n         print ( '*'   *   32 ) \n\n     def   __exit__ ( self ,   exc_type ,   exc_val ,   exc_tb ): \n         print ( '*'   *   32 )   The  __exit__  method takes three arguments apart from  self . Those arguments contain information about any errors that occurred inside the  with  block.  You can use  asterisks  in the same way as any of the built-in context managers:  >>>   with   asterisks ():  >>>       print ( \"Context Managers Rock!\" )  ********************************  Context   Managers   Rock !  ********************************",
            "title": "CONTEXT MANAGER CLASSES"
        },
        {
            "location": "/advanced/Context_Managers/#accessing-the-context-inside-the-with-block",
            "text": "If you need to get something back and use it inside the with block \u2013 such as a file descriptor \u2013 you simply return it from  __enter__ :  class   myopen (): \n     def   __init__ ( self ,   filename ,   filemode ): \n         self . filename   =   filename \n         self . filemode   =   filemode \n\n     def   __enter__ ( self ): \n         self . file   =   open ( self . filename ,   self . filemode ) \n         return   self . file \n\n     def   __exit__ ( self ,   exc_type ,   exc_val ,   exc_tb ): \n         self . file . close ()   myopen  works identically to the built-in  open :  with   myopen ( \"beer.txt\" )   as   b : \n     guzzle_guzzle ( b )",
            "title": "ACCESSING THE CONTEXT INSIDE THE WITH BLOCK"
        },
        {
            "location": "/advanced/Context_Managers/#the-contextmanager-decorator",
            "text": "Thankfully, you don\u2019t have to implement a class every time. The  contextlib  package has a  contextmanager  decorator that you can apply to generators to automatically transform them into context managers:  from   contextlib   import   contextmanager  @contextmanager  def   spoiler (): \n     print ( '<spoiler>' ) \n     yield \n     print ( '</spoiler>' )   The code before  yield  corresponds to  __enter__  and the code after  yield  corresponds to  __exit__ . A context manager generator should have exactly one  yield  in it.  It works the same as the class version:  >>>   with   spoiler ():  >>>       print ( \"Jon Snow is Luke's father.\" )  < spoiler >  Jon   Snow   is   Luke 's father.  </ spoiler >",
            "title": "THE CONTEXTMANAGER DECORATOR"
        },
        {
            "location": "/advanced/Context_Managers/#roll-your-own-contextmanager-decorator",
            "text": "The implementation in  contextlib  is complicated, but it\u2019s not hard to write something that works similarly with the exception of a few edge cases:  def   contextmanager ( gen ): \n     class   CMWrapper ( object ): \n         def   __init__ ( self ,   wrapped ): \n             self . generator   =   wrapped \n\n         def   __enter__ ( self ): \n             return   next ( self . generator ) \n\n         def   __exit__ ( self ,   ex_type ,   value ,   traceback ): \n             try : \n                 next ( self . generator ) \n             except   StopIteration : \n                 pass \n\n     def   inner ( * args ,   ** kwargs ): \n         return   CMWrapper ( gen ( * args ,   ** kwargs )) \n\n     return   inner   It\u2019s not as robust as the real implementation, but it should be understandable. Here are the key points:\n- The inner function instantiates a copy of the nested CMWrapper class with a handle on the generator passed into the decorator. \n-  __enter__  calls next() on the generator and returns the yielded value so it can be used in the with block. \n-  __exit__  calls next() again and catches the StopIteration exception that the generator throws when it finishes.    That\u2019s it for now. If you want to learn more about context managers, I recommend you take a look at the code for  contextlib .   Source:     https://www.smallsurething.com/how-exactly-do-context-managers-work/",
            "title": "ROLL YOUR OWN CONTEXTMANAGER DECORATOR"
        },
        {
            "location": "/advanced/Context_Managers/#python-context-managers-and-the-with-statement-enter-exit-video",
            "text": "",
            "title": "Python Context Managers and the \"with\" Statement (enter &amp; exit)    VIDEO"
        },
        {
            "location": "/advanced/Python_Metaclasses/",
            "text": "Quick Tip: What Is a Metaclass in Python\n\n\nThis quick tip gives a brief overview of what we mean by a metaclass in Python and shows some examples of the concept.\n\n\nBefore delving into this article, I should point out an important point \nabout classes in Python\n which makes it easier for us to grasp the concept of metaclasses.\n\n\nIs a Class an Object in Python?!\n\n\nIf you've used a programming language other than Python, the concept you understood about classes is most likely that it is a way used to create new objects. This is also true in Python, but Python even takes it one more step further\u2014classes are also considered objects!\n\n\nSo, if you created the following class in Python:\n\n\nclass\n \nmyClass\n(\nobject\n):\n\n    \npass\n\n\n\n\n\n\nThis simply means that an object with the name myClass has been created in memory. Since this object is able to create new objects, it is considered a class. This means we can apply object operations on classes in Python, as classes are objects themselves.\n\n\nWe can thus do operations on classes like assigning the class to a variable, as follows:\n\n\nclass_object\n \n=\n \nmyClass\n()\n\n\nprint\n \nclass_object\n\n\n\n\n\n\nWhich returns:\n\n\n<\n__main__\n.\nmyClass\n \nobject\n \nat\n \n0x102623610\n>\n\n\n\n\n\n\nYou can even pass the class \nmyClass\n as a parameter to a method, as follows:\n\n\ndef\n \nclass_object\n(\nobject\n):\n\n    \nprint\n \nobject\n\n\n\nclass_object\n(\nmyClass\n)\n\n\n\n\n\n\nWhich returns the following output:\n\n\n<\nclass\n \n'\n__main__\n.\nmyClass\n'>\n\n\n\n\n\n\nIn addition to other operations you can normally apply on objects.\n\n\nMetaclasses\n\n\nMaybe you have come across the \ntype\n keyword in Python? You most likely used it to check the type of some object, as shown in the following examples:\n\n\nprint\n \ntype\n(\n'abder'\n)\n\n\nprint\n \ntype\n(\n100\n)\n\n\nprint\n \ntype\n(\n100.0\n)\n\n\nprint\n \ntype\n(\nint\n)\n\n\n\n\n\n\nIn which case you would get the following output:\n\n\n<\ntype\n \n'str'\n>\n\n\n<\ntype\n \n'int'\n>\n\n\n<\ntype\n \n'float'\n>\n\n\n<\ntype\n \n'type'\n>\n\n\n\n\n\n\nLooking at the output, everything seems pretty clear until you come to the type type. To see what this might mean, let's go back to our class we defined at the beginning of this article:\n\n\nclass\n \nmyClass\n(\nobject\n):\n\n    \npass\n\n\n\n\n\n\nNow, do the following:\n\n\nprint\n \ntype\n(\nmyClass\n)\n\n\n\n\n\n\nWhat would be the output of this statement? It will surprisingly be:\n\n\n<\ntype\n \n'type'\n>\n\n\n\n\n\n\nSo, we can conclude that the type of classes in Python is \ntype\n!\n\n\nWhat is the relation between a \ntype\n and a \nmetaclass\n? Well, a \ntype\n is a \nmetaclass\n, provided that the default \nmetaclass\n is \ntype\n. I know this might be confusing, especially that type can be used to return the class of some object as shown above, but this is due to the backward compatibility in Python. So, if you write:\n\n\nprint\n \ntype\n(\ntype\n)\n\n\n\n\n\n\nYou will get:\n\n\n<\ntype\n \n'type'\n>\n\n\n\n\n\n\nMeaning that a \ntype\n is a \ntype\n!\n\n\nThe term \nmetaclass\n simply means something used to create classes. In other words, it is the class of a class, meaning that the instance of a class in this case is a class. Thus, \ntype\n is considered a \nmetaclass\n since the instance of a \ntype\n is a class.\n\n\nFor instance, when we mentioned the following statement above:\n\n\nclass_object\n \n=\n \nmyClass\n()\n\n\n\n\n\n\nThis simply builds an object/instance of the class \nmyClass\n. In other words, we used a class to create an object. \n\n\nIn the same way, when we did the following:\n\n\nclass\n \nmyClass\n(\nobject\n):\n\n    \npass\n\n\n\n\n\n\nThe \nmetaclass\n was used to create the class \nmyClass\n (which is considered a \ntype\n). So, like the object being an instance of a class, a class is an instance of a \nmetaclass\n.\n\n\nUsing Metaclass to Create a Class\n\n\nIn this section, we are going to see how we can use a \nmetaclass\n to create a class, rather than using the \nclass\n statement as we saw in the classes and objects tutorial. As we saw above, the default \nmetaclass\n is \ntype\n. Thus, we can use the following statement to create a new class:\n\n\nnew_class\n \n=\n \ntype\n(\n'myClass'\n,(),{})\n\n\n\n\n\n\nIf you want to make things simpler, you can assign the same class name myClass to the variable name.\n\n\nThe dictionary \n{ }\n here is used to define the attributes of the class. So, having the following statement:\n\n\nmyClass\n \n=\n \ntype\n(\n'myClass'\n,(),{\n'a'\n:\nTrue\n})\n\n\n\n\n\n\nIs similar to:\n\n\nclass\n \nmyClass\n(\nobject\n):\n\n    \na\n \n=\n \nTrue\n\n\n\n\n\n\nThe \nmetaclass\n Attribute\n\n\nSay that we created the class \nmyClass\n as follows:\n\n\nclass\n \nmyClass\n(\nobject\n):\n\n    \n__metaclass__\n \n=\n \nmyMetaClass\n\n    \npass\n\n\n\n\n\n\nIn this case, class creation will occur using myMetaClass instead of type, as follows:\n\n\nmyClass\n \n=\n \nmyMetaClass\n(\nclassName\n,\n \nbases\n,\n \ndictionary\n)\n\n\n\n\n\n\nCreation and Initialization of a Metaclass\n\n\nIf you want to have control on how you create and initialize a class after its creation, you can simply use the metaclass \nnew\n method and \ninit\n constructor, respectively. So, when myMetaClass above is called, this is what will be happening behind the scenes:\n\n\nmyClass\n \n=\n \nmyMetaClass\n.\n__new__\n(\nmyMetaClass\n,\n \nname\n,\n \nbases\n,\n \ndictionary\n)\n\n\nmyMetaClass\n.\n__init__\n(\nmyClass\n,\n \nname\n,\n \nbases\n,\n \ndictionary\n)\n\n\n\n\n\n\n\n\nSource:\n \n\n\n https://code.tutsplus.com/tutorials/quick-tip-what-is-a-metaclass-in-python--cms-26016\n\n\n\n\n\n\nUnderstanding Python metaclasses from Ionelmc.ro\n\n\nA quick overview\n\n\nA high level explanation is necessary before we get down to the details.\n\n\nA class is an object, and just like any other object, it's an instance of something: a metaclass. The default metaclass is type. Unfortunately, due to backwards compatibility, type is a bit confusing: it can also be used as a function that return the class [13] of an object:\n\n\n>>>\n \nclass\n \nFoobar\n:\n\n\n...\n     \npass\n\n\n...\n\n\n>>>\n \ntype\n(\nFoobar\n)\n\n\n<\nclass\n \n'\ntype\n'>\n\n\n>>>\n \nfoo\n \n=\n \nFoobar\n()\n\n\n>>>\n \ntype\n(\nfoo\n)\n\n\n<\nclass\n \n'\n__main__\n.\nFoobar\n'>\n\n\n\n\n\n\nIf you're familiar with the isinstance builtin then you'll know this:\n\n\n>>>\n \nisinstance\n(\nfoo\n,\n \nFoobar\n)\n\n\nTrue\n\n\n>>>\n \nisinstance\n(\nFoobar\n,\n \ntype\n)\n\n\nTrue\n\n\n\n\n\n\nTo put this in picture:\n\n\n  \n\n\nBut lets go back to making classes ...\n\n\nSimple metaclass use\n\n\nWe can use type directly to make a class, without any class statement:\n\n\n>>>\n \nMyClass\n \n=\n \ntype\n(\n'MyClass'\n,\n \n(),\n \n{})\n\n\n>>>\n \nMyClass\n\n\n<\nclass\n \n'\n__main__\n.\nMyClass\n'>\n\n\n\n\n\n\nThe class statement isn't just syntactic sugar, it does some extra things, like setting an adequate \nqualname\n and \ndoc\n properties or calling \nprepare\n.\n\n\nWe can make a custom metaclass:\n\n\n>>>\n \nclass\n \nMeta\n(\ntype\n):\n\n\n...\n     \npass\n\n\n\n\n\n\nAnd then we can use it :\n\n\n>>>\n \nclass\n \nComplex\n(\nmetaclass\n=\nMeta\n):\n\n\n...\n     \npass\n\n\n>>>\n \ntype\n(\nComplex\n)\n\n\n<\nclass\n \n'\n__main__\n.\nMeta\n'>\n\n\n\n\n\n\nNow we got a rough idea of what we'll be dealing with ...\n\n\nMagic methods\n\n\nOne distinctive feature of Python is magic methods: they allow the programmer to override behavior for various operators and behavior of objects. To override the call operator you'd do this:\n\n\n>>>\n \nclass\n \nFunky\n:\n\n\n...\n     \ndef\n \n__call__\n(\nself\n):\n\n\n...\n         \nprint\n(\n\"Look at me, I work like a function!\"\n)\n\n\n>>>\n \nf\n \n=\n \nFunky\n()\n\n\n>>>\n \nf\n()\n\n\nLook\n \nat\n \nme\n,\n \nI\n \nwork\n \nlike\n \na\n \nfunction\n!\n\n\n\n\n\n\nMetaclasses rely on several magic methods so it's quite useful to know a bit more about them.\n\n\nThe slots\n\n\nWhen you define a magic method in your class the function will end up as a pointer in a struct that describes the class, in addition to the entry in \ndict\n. That struct [7] has a field for each magic method. For some reason these fields are called type slots.\n\n\nNow there's another feature, implemented via the \nslots\n attribute. A class with \nslots\n will create instances that don't have a \ndict\n (they use a little bit less memory). A side-effect of this is that instances cannot have other fields than what was specified in \nslots\n: if you try to set an unexpected field you'll get an exception.\n\n\nFor the scope of this article when slots are mentioned it will mean the type slots, not \nslots\n.\n\n\nObject attribute lookup\n\n\nNow this is something that's easy to get wrong because of the many slight differences to old-style objects in Python 2. \n\n\nAssuming Class is the class and instance is an instance of Class, evaluating instance.foobar roughly equates to this:\n\n\n\n\nCall the type slot for Class.\ngetattribute\n (tp_getattro). The default does this:  \n\n\nDoes Class.\ndict\n have a foobar item that is a data descriptor ?    \n\n\nIf yes, return the result of Class.\ndict\n['foobar'].\nget\n(instance, Class).  \n\n\n\n\n\n\nDoes instance.\ndict\n have a foobar item in it?     \n\n\nIf yes, return instance.\ndict\n['foobar'].  \n\n\n\n\n\n\nDoes Class.\ndict\n have a foobar item that is not a data descriptor ? \n\n\nIf yes, return the result of Class.\ndict\n['foobar'].\nget\n(instance, klass).   \n\n\n\n\n\n\nDoes Class.\ndict\n have a foobar item ? \n\n\nIf yes, return the result of Class.\ndict\n['foobar'].   \n\n\n\n\n\n\n\n\n\n\nIf the attribute still wasn't found, and there's a Class.\ngetattr\n, call Class.\ngetattr\n('foobar').\n\n\n\n\nStill not clear? Perhaps a diagram normal attribute lookup helps:\n\n\n\n\n\nTo avoid creating confusions with the \u201c.\u201d operator doing crazy things I've used \u201c:\u201d in this diagram to signify the location.\n\n\n\n\nClass attribute lookup\n\n\nBecause classes needs to be able support the classmethod and staticmethod properties [6] when you evaluate something like Class.foobar the lookup is slightly different than what would happen when you evaluate instance.foobar.\n\n\nAssuming Class is an instance of Metaclass, evaluating Class.foobar roughly equates to this:\n\n\n\n\nCall the type slot for Metaclass.\ngetattribute\n (tp_getattro). The default does this: \n\n\nDoes Metaclass.\ndict\n have a foobar item that is a data descriptor ?\n\n\nIf yes, return the result of Metaclass.\ndict\n['foobar'].\nget\n(Class, Metaclass).   \n\n\n\n\n\n\nDoes Class.\ndict\n have a foobar item that is a descriptor (of any kind)?\n\n\nIf yes, return the result of Class.\ndict\n['foobar'].\nget\n(None, Class). \n\n\n\n\n\n\nDoes Class.\ndict\n have a foobar item in it?\n\n\nIf yes, return Class.\ndict\n['foobar'].\n\n\n\n\n\n\nDoes Metaclass.\ndict\n have a foobar item that is not a data descriptor ?\n\n\nIf yes, return the result of Metaclass.\ndict\n['foobar'].\nget\n(Class, Metaclass).\n\n\n\n\n\n\nDoes Metaclass.\ndict\n have any foobar item?\n\n\nIf yes, return Metaclass.\ndict\n['foobar'].\n\n\n\n\n\n\n\n\n\n\nIf the attribute still wasn't found, and there's a Metaclass.\ngetattr\n, call Metaclass.\ngetattr\n('foobar').\n\n\n\n\nThe whole shebang would look like this in a diagram:\n\n\n\n\n\nTo avoid creating confusions with the \u201c.\u201d operator doing crazy things I've used \u201c:\u201d in this diagram to signify the location.\n\n\n\n\nMagic method lookup\n\n\nFor magic methods the lookup is done on the class, directly in the big struct with the slots:\n\n\n\n\nDoes the object's class have a slot for that magic method (roughly object->ob_type->tp_\n in C code)? If yes, use it. If it's NULL then the operation is not supported.\n\n\n\n\n\n\nIn C internals parlance:\n  -  object->ob_type is the class of the object. \n\n    - ob_type->tp_\n is the type slot.\n\n\n\n\nThis looks much simpler, however, the type slots are filled with wrappers around your functions, so descriptors work as expected:\n\n\n>>>\n \nclass\n \nMagic\n:\n\n\n...\n     \n@property\n\n\n...\n     \ndef\n \n__repr__\n(\nself\n):\n\n\n...\n         \ndef\n \ninner\n():\n\n\n...\n             \nreturn\n \n\"It works!\"\n\n\n...\n         \nreturn\n \ninner\n\n\n...\n\n\n>>>\n \nrepr\n(\nMagic\n())\n\n\n'It works!'\n\n\n\n\n\n\nThats it. Does that mean there are places that don't follow those rules and lookup the slot differently? Sadly yes, read on ...\n\n\nThe \nnew\n method\n\n\nOne of the most common point of confusion with both classes and metaclasses is the \nnew\n method. It has some very special conventions.\n\n\nThe \nnew\n method is the constructor (it returns the new instance) while \ninit\n is just a initializer (the instance is already created when \ninit\n is called).\n\n\nSuppose have a class like this:\n\n\nclass\n \nFoobar\n:\n\n    \ndef\n \n__new__\n(\ncls\n):\n\n        \nreturn\n \nsuper\n()\n.\n__new__\n(\ncls\n)\n\n\n\n\n\n\nNow if you recall the previous section, you'd expect that   __new__ would be looked up on the metaclass, but alas, it wouldn't be so useful that way  so it's looked up statically.\n\n\nWhen the Foobar class wants this magic method it will be looked up on the same object (the class), not on a upper level like all the other magic methods. This is very important to understand, because both the class and the metaclass can define this method:\n\n\n\n\nFoobar.__new__ is used to create instances of Foobar\n\n\ntype.__new__ is used to create the Foobar class (an instance of type in the example)\n\n\n\n\nThe \nprepare\n method\n\n\nThis method is called before the class body is executed and it must return a dictionary-like object that's used as the local namespace for all the code from the class body. It was added in Python 3.0, see \nPEP-3115\n.\n\n\nIf your __prepare__ returns an object x then this:\n\n\nclass\n \nClass\n(\nmetaclass\n=\nMeta\n):\n\n    \na\n \n=\n \n1\n\n    \nb\n \n=\n \n2\n\n    \nc\n \n=\n \n3\n\n\n\n\n\n\nWill make the following changes to x:\n\n\nx\n[\n'a'\n]\n \n=\n \n1\n\n\nx\n[\n'b'\n]\n \n=\n \n2\n\n\nx\n[\n'c'\n]\n \n=\n \n3\n\n\n\n\n\n\nThis x object needs to look like a dictionary. Note that this x object will end up as an argument to Metaclass.__new\n and if it's not an instance of dict you need to convert it before calling super().__new\n.\n\n\nInterestingly enough this method doesn't have __new__'s special lookup. It appears it doesn't have it's own type slot and it's looked up via the class attribute lookup, if you read back a bit. \n\n\nPutting it all together\n\n\nTo start things off, a diagram of how instances are constructed:\n\n\n\nHow to read this swim lane diagram:  \n\n\n\n\nThe horizontal lanes is the place where you define the functions.\n\n\nSolid lines mean a function call.\n\n\nA line from Metaclass.__call\n to Class.__new\n means Metaclass.__call\n will call Class.__new\n.\n\n\n\n\n\n\nDashed lines means something is returned.\n\n\nClass.\nnew\n returns the instance of Class.\n\n\nMetaclass.\ncall\n returns whatever Class.\nnew\n returned (and if it returned an instance of Class it will also call Class.\ninit\n on it). \n\n\n\n\n\n\nThe number in the red circle signifies the call order.\n\n\n\n\nCreating a class is quite similar:\n\n\n\nFew more notes:\n-   Metaclass.\nprepare\n just returns the namespace object (a dictionary-like object as explained before).\n-   Metaclass.\nnew\n returns the Class object.\n-   MetaMetaclass.\ncall\n returns whatever Metaclass.\nnew\n returned (and if it returned an instance of Metaclass it will also call Metaclass.\ninit\n on it). \n\n\nSo you see, metaclasses allow you to customize almost every part of an object life-cycle.\n\n\nMetaclasses are callables\n\n\nIf you look again at the diagrams, you'll notice that making an instance goes through Metaclass.\ncall\n. This means you can use any callable as the metaclass:\n\n\n>>>\n \nclass\n \nFoo\n(\nmetaclass\n=\nprint\n):\n  \n# pointless, but illustrative\n\n\n...\n     \npass\n\n\n...\n\n\nFoo\n \n()\n \n{\n'__module__'\n:\n \n'__main__'\n,\n \n'__qualname__'\n:\n \n'Foo'\n}\n\n\n>>>\n \nprint\n(\nFoo\n)\n\n\nNone\n\n\n\n\n\n\nIf you use a function as the metaclass then subclasses won't inherit your function metaclass, but the type of whatever that function returned.\n\n\nSubclasses inherit the metaclass\n\n\nOne advantage compared to class decorators is the fact that subclasses inherit the metaclass.\n\n\nThis is a consequence of the fact that Metaclass(...) returns an object which usually has Metaclass as the \nclass\n.\n\n\nRestrictions with multiple metaclasses\n\n\nIn the same tone of classes allowing you to have multiple baseclasses, each one of those baseclasses may have a different metaclass. But with a twist: everything has to be linear - the inheritance tree must have a single leaf.\n\n\nFor example, this is not accepted because there would be two leafs (Meta1 and Meta2):\n\n\n>>>\n \nclass\n \nMeta1\n(\ntype\n):\n\n\n...\n     \npass\n\n\n...\n\n\n>>>\n \nclass\n \nMeta2\n(\ntype\n):\n\n\n...\n     \npass\n\n\n...\n\n\n>>>\n \nclass\n \nBase1\n(\nmetaclass\n=\nMeta1\n):\n\n\n...\n     \npass\n\n\n...\n\n\n>>>\n \nclass\n \nBase2\n(\nmetaclass\n=\nMeta2\n):\n\n\n...\n     \npass\n\n\n...\n\n\n>>>\n \nclass\n \nFoobar\n(\nBase1\n,\n \nBase2\n):\n\n\n...\n     \npass\n\n\n...\n\n\nTraceback\n \n(\nmost\n \nrecent\n \ncall\n \nlast\n):\n\n  \nFile\n \n\"<stdin>\"\n,\n \nline\n \n1\n,\n \nin\n \n<\nmodule\n>\n\n\nTypeError\n:\n \nmetaclass\n \nconflict\n:\n \nthe\n \nmetaclass\n \nof\n \na\n \nderived\n \nclass\n \nmust\n \nbe\n \na\n \n(\nnon\n-\nstrict\n)\n \nsubclass\n \nof\n \nthe\n \nmetaclasses\n \nof\n \nall\n \nits\n \nbases\n\n\n\n\n\n\nThis will work (and will use the leaf as the metaclass):\n\n\n>>>\n \nclass\n \nMeta\n(\ntype\n):\n\n\n...\n     \npass\n\n\n...\n\n\n>>>\n \nclass\n \nSubMeta\n(\nMeta\n):\n\n\n...\n     \npass\n\n\n...\n\n\n>>>\n \nclass\n \nBase1\n(\nmetaclass\n=\nMeta\n):\n\n\n...\n     \npass\n\n\n...\n\n\n>>>\n \nclass\n \nBase2\n(\nmetaclass\n=\nSubMeta\n):\n\n\n...\n     \npass\n\n\n...\n\n\n>>>\n \nclass\n \nFoobar\n(\nBase1\n,\n \nBase2\n):\n\n\n...\n     \npass\n\n\n...\n\n\n>>>\n \ntype\n(\nFoobar\n)\n\n\n<\nclass\n \n'\n__main__\n.\nSubMeta\n'>\n\n\n\n\n\n\nThe method signatures\n\n\nThere are still few important details missing, like the method signatures. Lets look at class and metaclass with all the important stuff implemented.\n\n\nNote the extra **kwargs - those are the extra keywords arguments you can pass in the class statement. \n\n\n>>>\n \nclass\n \nMeta\n(\ntype\n):\n\n\n...\n     \n@classmethod\n\n\n...\n     \ndef\n \n__prepare__\n(\nmcs\n,\n \nname\n,\n \nbases\n,\n \n**\nkwargs\n):\n\n\n...\n         \nprint\n(\n'  Meta.__prepare__(mcs=\n%s\n, name=\n%r\n, bases=\n%s\n, **\n%s\n)'\n \n%\n \n(\n\n\n...\n             \nmcs\n,\n \nname\n,\n \nbases\n,\n \nkwargs\n\n\n...\n         \n))\n\n\n...\n         \nreturn\n \n{}\n\n\n\n\n\n\nAs mentioned before, __prepare\n can return objects that are not dict instances, so you need to make sure your __new\n handles that.\n\n\n...\n     \ndef\n \n__new__\n(\nmcs\n,\n \nname\n,\n \nbases\n,\n \nattrs\n,\n \n**\nkwargs\n):\n\n\n...\n         \nprint\n(\n'  Meta.__new__(mcs=\n%s\n, name=\n%r\n, bases=\n%s\n, attrs=[\n%s\n], **\n%s\n)'\n \n%\n \n(\n\n\n...\n             \nmcs\n,\n \nname\n,\n \nbases\n,\n \n', '\n.\njoin\n(\nattrs\n),\n \nkwargs\n\n\n...\n         \n))\n\n\n...\n         \nreturn\n \nsuper\n()\n.\n__new__\n(\nmcs\n,\n \nname\n,\n \nbases\n,\n \nattrs\n)\n\n\n\n\n\n\nIt's uncommon to see \ninit\n being implemented in a metaclass because it's not that powerful - the class is already constructed when \ninit\n is called. It roughly equates to having a class decorator with the difference that \ninit\n would get run when making subclasses, while class decorators are not called for subclasses.\n\n\n...\n     \ndef\n \n__init__\n(\ncls\n,\n \nname\n,\n \nbases\n,\n \nattrs\n,\n \n**\nkwargs\n):\n\n\n...\n         \nprint\n(\n'  Meta.__init__(cls=\n%s\n, name=\n%r\n, bases=\n%s\n, attrs=[\n%s\n], **\n%s\n)'\n \n%\n \n(\n\n\n...\n             \ncls\n,\n \nname\n,\n \nbases\n,\n \n', '\n.\njoin\n(\nattrs\n),\n \nkwargs\n\n\n...\n         \n))\n\n\n...\n         \nreturn\n \nsuper\n()\n.\n__init__\n(\nname\n,\n \nbases\n,\n \nattrs\n)\n\n\n\n\n\n\nThe __call__ method will be called when you make instances of Class.\n\n\n...\n     \ndef\n \n__call__\n(\ncls\n,\n \n*\nargs\n,\n \n**\nkwargs\n):\n\n\n...\n         \nprint\n(\n'  Meta.__call__(cls=\n%s\n, args=\n%s\n, kwargs=\n%s\n)'\n \n%\n \n(\n\n\n...\n             \ncls\n,\n \nargs\n,\n \nkwargs\n\n\n...\n         \n))\n\n\n...\n         \nreturn\n \nsuper\n()\n.\n__call__\n(\n*\nargs\n,\n \n**\nkwargs\n)\n\n\n...\n\n\n\n\n\n\nUsing Meta, note the extra=1: \n\n\n>>>\n \nclass\n \nClass\n(\nmetaclass\n=\nMeta\n,\n \nextra\n=\n1\n):\n\n\n...\n     \ndef\n \n__new__\n(\ncls\n,\n \nmyarg\n):\n\n\n...\n         \nprint\n(\n'  Class.__new__(cls=\n%s\n, myarg=\n%s\n)'\n \n%\n \n(\n\n\n...\n             \ncls\n,\n \nmyarg\n\n\n...\n         \n))\n\n\n...\n         \nreturn\n \nsuper\n()\n.\n__new__\n(\ncls\n)\n\n\n...\n\n\n...\n     \ndef\n \n__init__\n(\nself\n,\n \nmyarg\n):\n\n\n...\n         \nprint\n(\n'  Class.__init__(self=\n%s\n, myarg=\n%s\n)'\n \n%\n \n(\n\n\n...\n             \nself\n,\n \nmyarg\n\n\n...\n         \n))\n\n\n...\n         \nself\n.\nmyarg\n \n=\n \nmyarg\n\n\n...\n         \nreturn\n \nsuper\n()\n.\n__init__\n()\n\n\n...\n\n\n...\n     \ndef\n \n__str__\n(\nself\n):\n\n\n...\n         \nreturn\n \n\"<instance of Class; myargs=\n%s\n>\"\n \n%\n \n(\n\n\n...\n             \ngetattr\n(\nself\n,\n \n'myarg'\n,\n \n'MISSING'\n),\n\n\n...\n         \n)\n\n  \nMeta\n.\n__prepare__\n(\nmcs\n=<\nclass\n \n'\n__main__\n.\nMeta\n'>, name='\nClass\n', bases=(),\n\n                   \n**\n{\n'extra'\n:\n \n1\n})\n\n  \nMeta\n.\n__new__\n(\nmcs\n=<\nclass\n \n'\n__main__\n.\nMeta\n'>, name='\nClass\n', bases=(),\n\n               \nattrs\n=\n[\n__qualname__\n,\n \n__new__\n,\n \n__init__\n,\n \n__str__\n,\n \n__module__\n],\n\n               \n**\n{\n'extra'\n:\n \n1\n})\n\n  \nMeta\n.\n__init__\n(\ncls\n=<\nclass\n \n'\n__main__\n.\nClass\n'>, name='\nClass\n', bases=(),\n\n                \nattrs\n=\n[\n__qualname__\n,\n \n__new__\n,\n \n__init__\n,\n \n__str__\n,\n \n__module__\n],\n\n                \n**\n{\n'extra'\n:\n \n1\n})\n\n\n\n\n\n\nNote that Meta.__call__ is called when we make instance of Class:\n\n\n>>>\n \nClass\n(\n1\n)\n\n  \nMeta\n.\n__call__\n(\ncls\n=<\nclass\n \n'\n__main__\n.\nClass\n'>, args=(1,), kwargs={})\n\n  \nClass\n.\n__new__\n(\ncls\n=<\nclass\n \n'\n__main__\n.\nClass\n'>, myarg=1)\n\n  \nClass\n.\n__init__\n(\nself\n=<\ninstance\n \nof\n \nClass\n;\n \nmyargs\n=\nMISSING\n>\n,\n \nmyarg\n=\n1\n)\n\n\n<\ninstance\n \nof\n \nClass\n;\n \nmyargs\n=\n1\n>\n\n\n\n\n\n\n\n\nSource:\n \n\n\n https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/",
            "title": "Python Metaclasses"
        },
        {
            "location": "/advanced/Python_Metaclasses/#quick-tip-what-is-a-metaclass-in-python",
            "text": "This quick tip gives a brief overview of what we mean by a metaclass in Python and shows some examples of the concept.  Before delving into this article, I should point out an important point  about classes in Python  which makes it easier for us to grasp the concept of metaclasses.",
            "title": "Quick Tip: What Is a Metaclass in Python"
        },
        {
            "location": "/advanced/Python_Metaclasses/#is-a-class-an-object-in-python",
            "text": "If you've used a programming language other than Python, the concept you understood about classes is most likely that it is a way used to create new objects. This is also true in Python, but Python even takes it one more step further\u2014classes are also considered objects!  So, if you created the following class in Python:  class   myClass ( object ): \n     pass   This simply means that an object with the name myClass has been created in memory. Since this object is able to create new objects, it is considered a class. This means we can apply object operations on classes in Python, as classes are objects themselves.  We can thus do operations on classes like assigning the class to a variable, as follows:  class_object   =   myClass ()  print   class_object   Which returns:  < __main__ . myClass   object   at   0x102623610 >   You can even pass the class  myClass  as a parameter to a method, as follows:  def   class_object ( object ): \n     print   object  class_object ( myClass )   Which returns the following output:  < class   ' __main__ . myClass '>   In addition to other operations you can normally apply on objects.",
            "title": "Is a Class an Object in Python?!"
        },
        {
            "location": "/advanced/Python_Metaclasses/#metaclasses",
            "text": "Maybe you have come across the  type  keyword in Python? You most likely used it to check the type of some object, as shown in the following examples:  print   type ( 'abder' )  print   type ( 100 )  print   type ( 100.0 )  print   type ( int )   In which case you would get the following output:  < type   'str' >  < type   'int' >  < type   'float' >  < type   'type' >   Looking at the output, everything seems pretty clear until you come to the type type. To see what this might mean, let's go back to our class we defined at the beginning of this article:  class   myClass ( object ): \n     pass   Now, do the following:  print   type ( myClass )   What would be the output of this statement? It will surprisingly be:  < type   'type' >   So, we can conclude that the type of classes in Python is  type !  What is the relation between a  type  and a  metaclass ? Well, a  type  is a  metaclass , provided that the default  metaclass  is  type . I know this might be confusing, especially that type can be used to return the class of some object as shown above, but this is due to the backward compatibility in Python. So, if you write:  print   type ( type )   You will get:  < type   'type' >   Meaning that a  type  is a  type !  The term  metaclass  simply means something used to create classes. In other words, it is the class of a class, meaning that the instance of a class in this case is a class. Thus,  type  is considered a  metaclass  since the instance of a  type  is a class.  For instance, when we mentioned the following statement above:  class_object   =   myClass ()   This simply builds an object/instance of the class  myClass . In other words, we used a class to create an object.   In the same way, when we did the following:  class   myClass ( object ): \n     pass   The  metaclass  was used to create the class  myClass  (which is considered a  type ). So, like the object being an instance of a class, a class is an instance of a  metaclass .",
            "title": "Metaclasses"
        },
        {
            "location": "/advanced/Python_Metaclasses/#using-metaclass-to-create-a-class",
            "text": "In this section, we are going to see how we can use a  metaclass  to create a class, rather than using the  class  statement as we saw in the classes and objects tutorial. As we saw above, the default  metaclass  is  type . Thus, we can use the following statement to create a new class:  new_class   =   type ( 'myClass' ,(),{})   If you want to make things simpler, you can assign the same class name myClass to the variable name.  The dictionary  { }  here is used to define the attributes of the class. So, having the following statement:  myClass   =   type ( 'myClass' ,(),{ 'a' : True })   Is similar to:  class   myClass ( object ): \n     a   =   True",
            "title": "Using Metaclass to Create a Class"
        },
        {
            "location": "/advanced/Python_Metaclasses/#the-metaclass-attribute",
            "text": "Say that we created the class  myClass  as follows:  class   myClass ( object ): \n     __metaclass__   =   myMetaClass \n     pass   In this case, class creation will occur using myMetaClass instead of type, as follows:  myClass   =   myMetaClass ( className ,   bases ,   dictionary )",
            "title": "The metaclass Attribute"
        },
        {
            "location": "/advanced/Python_Metaclasses/#creation-and-initialization-of-a-metaclass",
            "text": "If you want to have control on how you create and initialize a class after its creation, you can simply use the metaclass  new  method and  init  constructor, respectively. So, when myMetaClass above is called, this is what will be happening behind the scenes:  myClass   =   myMetaClass . __new__ ( myMetaClass ,   name ,   bases ,   dictionary )  myMetaClass . __init__ ( myClass ,   name ,   bases ,   dictionary )    Source:     https://code.tutsplus.com/tutorials/quick-tip-what-is-a-metaclass-in-python--cms-26016",
            "title": "Creation and Initialization of a Metaclass"
        },
        {
            "location": "/advanced/Python_Metaclasses/#understanding-python-metaclasses-from-ionelmcro",
            "text": "",
            "title": "Understanding Python metaclasses from Ionelmc.ro"
        },
        {
            "location": "/advanced/Python_Metaclasses/#a-quick-overview",
            "text": "A high level explanation is necessary before we get down to the details.  A class is an object, and just like any other object, it's an instance of something: a metaclass. The default metaclass is type. Unfortunately, due to backwards compatibility, type is a bit confusing: it can also be used as a function that return the class [13] of an object:  >>>   class   Foobar :  ...       pass  ...  >>>   type ( Foobar )  < class   ' type '>  >>>   foo   =   Foobar ()  >>>   type ( foo )  < class   ' __main__ . Foobar '>   If you're familiar with the isinstance builtin then you'll know this:  >>>   isinstance ( foo ,   Foobar )  True  >>>   isinstance ( Foobar ,   type )  True   To put this in picture:      But lets go back to making classes ...",
            "title": "A quick overview"
        },
        {
            "location": "/advanced/Python_Metaclasses/#simple-metaclass-use",
            "text": "We can use type directly to make a class, without any class statement:  >>>   MyClass   =   type ( 'MyClass' ,   (),   {})  >>>   MyClass  < class   ' __main__ . MyClass '>   The class statement isn't just syntactic sugar, it does some extra things, like setting an adequate  qualname  and  doc  properties or calling  prepare .  We can make a custom metaclass:  >>>   class   Meta ( type ):  ...       pass   And then we can use it :  >>>   class   Complex ( metaclass = Meta ):  ...       pass  >>>   type ( Complex )  < class   ' __main__ . Meta '>   Now we got a rough idea of what we'll be dealing with ...",
            "title": "Simple metaclass use"
        },
        {
            "location": "/advanced/Python_Metaclasses/#magic-methods",
            "text": "One distinctive feature of Python is magic methods: they allow the programmer to override behavior for various operators and behavior of objects. To override the call operator you'd do this:  >>>   class   Funky :  ...       def   __call__ ( self ):  ...           print ( \"Look at me, I work like a function!\" )  >>>   f   =   Funky ()  >>>   f ()  Look   at   me ,   I   work   like   a   function !   Metaclasses rely on several magic methods so it's quite useful to know a bit more about them.",
            "title": "Magic methods"
        },
        {
            "location": "/advanced/Python_Metaclasses/#the-slots",
            "text": "When you define a magic method in your class the function will end up as a pointer in a struct that describes the class, in addition to the entry in  dict . That struct [7] has a field for each magic method. For some reason these fields are called type slots.  Now there's another feature, implemented via the  slots  attribute. A class with  slots  will create instances that don't have a  dict  (they use a little bit less memory). A side-effect of this is that instances cannot have other fields than what was specified in  slots : if you try to set an unexpected field you'll get an exception.  For the scope of this article when slots are mentioned it will mean the type slots, not  slots .",
            "title": "The slots"
        },
        {
            "location": "/advanced/Python_Metaclasses/#object-attribute-lookup",
            "text": "Now this is something that's easy to get wrong because of the many slight differences to old-style objects in Python 2.   Assuming Class is the class and instance is an instance of Class, evaluating instance.foobar roughly equates to this:   Call the type slot for Class. getattribute  (tp_getattro). The default does this:    Does Class. dict  have a foobar item that is a data descriptor ?      If yes, return the result of Class. dict ['foobar']. get (instance, Class).      Does instance. dict  have a foobar item in it?       If yes, return instance. dict ['foobar'].      Does Class. dict  have a foobar item that is not a data descriptor ?   If yes, return the result of Class. dict ['foobar']. get (instance, klass).       Does Class. dict  have a foobar item ?   If yes, return the result of Class. dict ['foobar'].         If the attribute still wasn't found, and there's a Class. getattr , call Class. getattr ('foobar').   Still not clear? Perhaps a diagram normal attribute lookup helps:   To avoid creating confusions with the \u201c.\u201d operator doing crazy things I've used \u201c:\u201d in this diagram to signify the location.",
            "title": "Object attribute lookup"
        },
        {
            "location": "/advanced/Python_Metaclasses/#class-attribute-lookup",
            "text": "Because classes needs to be able support the classmethod and staticmethod properties [6] when you evaluate something like Class.foobar the lookup is slightly different than what would happen when you evaluate instance.foobar.  Assuming Class is an instance of Metaclass, evaluating Class.foobar roughly equates to this:   Call the type slot for Metaclass. getattribute  (tp_getattro). The default does this:   Does Metaclass. dict  have a foobar item that is a data descriptor ?  If yes, return the result of Metaclass. dict ['foobar']. get (Class, Metaclass).       Does Class. dict  have a foobar item that is a descriptor (of any kind)?  If yes, return the result of Class. dict ['foobar']. get (None, Class).     Does Class. dict  have a foobar item in it?  If yes, return Class. dict ['foobar'].    Does Metaclass. dict  have a foobar item that is not a data descriptor ?  If yes, return the result of Metaclass. dict ['foobar']. get (Class, Metaclass).    Does Metaclass. dict  have any foobar item?  If yes, return Metaclass. dict ['foobar'].      If the attribute still wasn't found, and there's a Metaclass. getattr , call Metaclass. getattr ('foobar').   The whole shebang would look like this in a diagram:   To avoid creating confusions with the \u201c.\u201d operator doing crazy things I've used \u201c:\u201d in this diagram to signify the location.",
            "title": "Class attribute lookup"
        },
        {
            "location": "/advanced/Python_Metaclasses/#magic-method-lookup",
            "text": "For magic methods the lookup is done on the class, directly in the big struct with the slots:   Does the object's class have a slot for that magic method (roughly object->ob_type->tp_  in C code)? If yes, use it. If it's NULL then the operation is not supported.    In C internals parlance:\n  -  object->ob_type is the class of the object.  \n    - ob_type->tp_  is the type slot.   This looks much simpler, however, the type slots are filled with wrappers around your functions, so descriptors work as expected:  >>>   class   Magic :  ...       @property  ...       def   __repr__ ( self ):  ...           def   inner ():  ...               return   \"It works!\"  ...           return   inner  ...  >>>   repr ( Magic ())  'It works!'   Thats it. Does that mean there are places that don't follow those rules and lookup the slot differently? Sadly yes, read on ...",
            "title": "Magic method lookup"
        },
        {
            "location": "/advanced/Python_Metaclasses/#the-new-method",
            "text": "One of the most common point of confusion with both classes and metaclasses is the  new  method. It has some very special conventions.  The  new  method is the constructor (it returns the new instance) while  init  is just a initializer (the instance is already created when  init  is called).  Suppose have a class like this:  class   Foobar : \n     def   __new__ ( cls ): \n         return   super () . __new__ ( cls )   Now if you recall the previous section, you'd expect that   __new__ would be looked up on the metaclass, but alas, it wouldn't be so useful that way  so it's looked up statically.  When the Foobar class wants this magic method it will be looked up on the same object (the class), not on a upper level like all the other magic methods. This is very important to understand, because both the class and the metaclass can define this method:   Foobar.__new__ is used to create instances of Foobar  type.__new__ is used to create the Foobar class (an instance of type in the example)",
            "title": "The new method"
        },
        {
            "location": "/advanced/Python_Metaclasses/#the-prepare-method",
            "text": "This method is called before the class body is executed and it must return a dictionary-like object that's used as the local namespace for all the code from the class body. It was added in Python 3.0, see  PEP-3115 .  If your __prepare__ returns an object x then this:  class   Class ( metaclass = Meta ): \n     a   =   1 \n     b   =   2 \n     c   =   3   Will make the following changes to x:  x [ 'a' ]   =   1  x [ 'b' ]   =   2  x [ 'c' ]   =   3   This x object needs to look like a dictionary. Note that this x object will end up as an argument to Metaclass.__new  and if it's not an instance of dict you need to convert it before calling super().__new .  Interestingly enough this method doesn't have __new__'s special lookup. It appears it doesn't have it's own type slot and it's looked up via the class attribute lookup, if you read back a bit.",
            "title": "The prepare method"
        },
        {
            "location": "/advanced/Python_Metaclasses/#putting-it-all-together",
            "text": "To start things off, a diagram of how instances are constructed:  How to read this swim lane diagram:     The horizontal lanes is the place where you define the functions.  Solid lines mean a function call.  A line from Metaclass.__call  to Class.__new  means Metaclass.__call  will call Class.__new .    Dashed lines means something is returned.  Class. new  returns the instance of Class.  Metaclass. call  returns whatever Class. new  returned (and if it returned an instance of Class it will also call Class. init  on it).     The number in the red circle signifies the call order.   Creating a class is quite similar:  Few more notes:\n-   Metaclass. prepare  just returns the namespace object (a dictionary-like object as explained before).\n-   Metaclass. new  returns the Class object.\n-   MetaMetaclass. call  returns whatever Metaclass. new  returned (and if it returned an instance of Metaclass it will also call Metaclass. init  on it).   So you see, metaclasses allow you to customize almost every part of an object life-cycle.",
            "title": "Putting it all together"
        },
        {
            "location": "/advanced/Python_Metaclasses/#metaclasses-are-callables",
            "text": "If you look again at the diagrams, you'll notice that making an instance goes through Metaclass. call . This means you can use any callable as the metaclass:  >>>   class   Foo ( metaclass = print ):    # pointless, but illustrative  ...       pass  ...  Foo   ()   { '__module__' :   '__main__' ,   '__qualname__' :   'Foo' }  >>>   print ( Foo )  None   If you use a function as the metaclass then subclasses won't inherit your function metaclass, but the type of whatever that function returned.",
            "title": "Metaclasses are callables"
        },
        {
            "location": "/advanced/Python_Metaclasses/#subclasses-inherit-the-metaclass",
            "text": "One advantage compared to class decorators is the fact that subclasses inherit the metaclass.  This is a consequence of the fact that Metaclass(...) returns an object which usually has Metaclass as the  class .",
            "title": "Subclasses inherit the metaclass"
        },
        {
            "location": "/advanced/Python_Metaclasses/#restrictions-with-multiple-metaclasses",
            "text": "In the same tone of classes allowing you to have multiple baseclasses, each one of those baseclasses may have a different metaclass. But with a twist: everything has to be linear - the inheritance tree must have a single leaf.  For example, this is not accepted because there would be two leafs (Meta1 and Meta2):  >>>   class   Meta1 ( type ):  ...       pass  ...  >>>   class   Meta2 ( type ):  ...       pass  ...  >>>   class   Base1 ( metaclass = Meta1 ):  ...       pass  ...  >>>   class   Base2 ( metaclass = Meta2 ):  ...       pass  ...  >>>   class   Foobar ( Base1 ,   Base2 ):  ...       pass  ...  Traceback   ( most   recent   call   last ): \n   File   \"<stdin>\" ,   line   1 ,   in   < module >  TypeError :   metaclass   conflict :   the   metaclass   of   a   derived   class   must   be   a   ( non - strict )   subclass   of   the   metaclasses   of   all   its   bases   This will work (and will use the leaf as the metaclass):  >>>   class   Meta ( type ):  ...       pass  ...  >>>   class   SubMeta ( Meta ):  ...       pass  ...  >>>   class   Base1 ( metaclass = Meta ):  ...       pass  ...  >>>   class   Base2 ( metaclass = SubMeta ):  ...       pass  ...  >>>   class   Foobar ( Base1 ,   Base2 ):  ...       pass  ...  >>>   type ( Foobar )  < class   ' __main__ . SubMeta '>",
            "title": "Restrictions with multiple metaclasses"
        },
        {
            "location": "/advanced/Python_Metaclasses/#the-method-signatures",
            "text": "There are still few important details missing, like the method signatures. Lets look at class and metaclass with all the important stuff implemented.  Note the extra **kwargs - those are the extra keywords arguments you can pass in the class statement.   >>>   class   Meta ( type ):  ...       @classmethod  ...       def   __prepare__ ( mcs ,   name ,   bases ,   ** kwargs ):  ...           print ( '  Meta.__prepare__(mcs= %s , name= %r , bases= %s , ** %s )'   %   (  ...               mcs ,   name ,   bases ,   kwargs  ...           ))  ...           return   {}   As mentioned before, __prepare  can return objects that are not dict instances, so you need to make sure your __new  handles that.  ...       def   __new__ ( mcs ,   name ,   bases ,   attrs ,   ** kwargs ):  ...           print ( '  Meta.__new__(mcs= %s , name= %r , bases= %s , attrs=[ %s ], ** %s )'   %   (  ...               mcs ,   name ,   bases ,   ', ' . join ( attrs ),   kwargs  ...           ))  ...           return   super () . __new__ ( mcs ,   name ,   bases ,   attrs )   It's uncommon to see  init  being implemented in a metaclass because it's not that powerful - the class is already constructed when  init  is called. It roughly equates to having a class decorator with the difference that  init  would get run when making subclasses, while class decorators are not called for subclasses.  ...       def   __init__ ( cls ,   name ,   bases ,   attrs ,   ** kwargs ):  ...           print ( '  Meta.__init__(cls= %s , name= %r , bases= %s , attrs=[ %s ], ** %s )'   %   (  ...               cls ,   name ,   bases ,   ', ' . join ( attrs ),   kwargs  ...           ))  ...           return   super () . __init__ ( name ,   bases ,   attrs )   The __call__ method will be called when you make instances of Class.  ...       def   __call__ ( cls ,   * args ,   ** kwargs ):  ...           print ( '  Meta.__call__(cls= %s , args= %s , kwargs= %s )'   %   (  ...               cls ,   args ,   kwargs  ...           ))  ...           return   super () . __call__ ( * args ,   ** kwargs )  ...   Using Meta, note the extra=1:   >>>   class   Class ( metaclass = Meta ,   extra = 1 ):  ...       def   __new__ ( cls ,   myarg ):  ...           print ( '  Class.__new__(cls= %s , myarg= %s )'   %   (  ...               cls ,   myarg  ...           ))  ...           return   super () . __new__ ( cls )  ...  ...       def   __init__ ( self ,   myarg ):  ...           print ( '  Class.__init__(self= %s , myarg= %s )'   %   (  ...               self ,   myarg  ...           ))  ...           self . myarg   =   myarg  ...           return   super () . __init__ ()  ...  ...       def   __str__ ( self ):  ...           return   \"<instance of Class; myargs= %s >\"   %   (  ...               getattr ( self ,   'myarg' ,   'MISSING' ),  ...           ) \n   Meta . __prepare__ ( mcs =< class   ' __main__ . Meta '>, name=' Class ', bases=(), \n                    ** { 'extra' :   1 }) \n   Meta . __new__ ( mcs =< class   ' __main__ . Meta '>, name=' Class ', bases=(), \n                attrs = [ __qualname__ ,   __new__ ,   __init__ ,   __str__ ,   __module__ ], \n                ** { 'extra' :   1 }) \n   Meta . __init__ ( cls =< class   ' __main__ . Class '>, name=' Class ', bases=(), \n                 attrs = [ __qualname__ ,   __new__ ,   __init__ ,   __str__ ,   __module__ ], \n                 ** { 'extra' :   1 })   Note that Meta.__call__ is called when we make instance of Class:  >>>   Class ( 1 ) \n   Meta . __call__ ( cls =< class   ' __main__ . Class '>, args=(1,), kwargs={}) \n   Class . __new__ ( cls =< class   ' __main__ . Class '>, myarg=1) \n   Class . __init__ ( self =< instance   of   Class ;   myargs = MISSING > ,   myarg = 1 )  < instance   of   Class ;   myargs = 1 >    Source:     https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/",
            "title": "The method signatures"
        },
        {
            "location": "/advanced/Python_Magic_Methods/",
            "text": "All about Python magic methods:\n\n\n\n\n https://rszalski.github.io/magicmethods/",
            "title": "Python Magic Methods"
        },
        {
            "location": "/advanced/Python_Magic_Methods/#all-about-python-magic-methods",
            "text": "https://rszalski.github.io/magicmethods/",
            "title": "All about Python magic methods:"
        },
        {
            "location": "/About/",
            "text": "I'll write later",
            "title": "About"
        },
        {
            "location": "/About/#ill-write-later",
            "text": "",
            "title": "I'll write later"
        }
    ]
}