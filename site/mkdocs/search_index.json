{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to Python Synopsis!\n\n\nPython Study Guide\n\n\nIn this repository I want to share resources, that helped me understand python programing language deeply. \nIt was not easy to find appropriate \nbooks, articles, answers from Stackoverflow, online courses, videos from py conferences\n and etc.   \n\n\nSo, after all I decided to share \ntop resources\n for everyone about each topic, that you need to know about python, if you want to be senior python \nSoftware Engineer\n.   \n\n\nOf course, it needs plenty of time to organize best resources based on the topics and it's hard for me to do it every day,  but I want to do min 1 chapter each week and now I think, that there will be more than \n30-40\n chapters.\n\n\n\n\nBeginner\n\n\nThe Python Programming Language, Implementation and Adventages\n\n\nPython Installation\n\n\nStart Coding With Python\n   \n\n\nDatatype And Variables",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-python-synopsis",
            "text": "",
            "title": "Welcome to Python Synopsis!"
        },
        {
            "location": "/#python-study-guide",
            "text": "In this repository I want to share resources, that helped me understand python programing language deeply. \nIt was not easy to find appropriate  books, articles, answers from Stackoverflow, online courses, videos from py conferences  and etc.     So, after all I decided to share  top resources  for everyone about each topic, that you need to know about python, if you want to be senior python  Software Engineer .     Of course, it needs plenty of time to organize best resources based on the topics and it's hard for me to do it every day,  but I want to do min 1 chapter each week and now I think, that there will be more than  30-40  chapters.   Beginner  The Python Programming Language, Implementation and Adventages  Python Installation  Start Coding With Python      Datatype And Variables",
            "title": "Python Study Guide"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/",
            "text": "The Python Programming Language\n\n\n\n\nThe programming language you will learn is Python. Python is an example of a highlevel\nlanguage; other high-level languages you might have heard of are \nC, C++, Perl,\n\nand \nJava\n.\nThere are also low-level languages, sometimes referred to as \n\u201cmachine languages\u201d\n or\n\n\u201cassembly languages.\u201d\n Loosely speaking, computers can only run programs written in\nlow-level languages. So programs written in a high-level language have to be processed\nbefore they can run. This extra processing takes some time, which is a small disadvantage\nof high-level languages.\n\n\nThe advantages are enormous. First, it is much easier to program in a high-level lan\nguage. Programs written in a high-level language take less time to write, they are shorter\nand easier to read, and they are more likely to be correct. Second, high-level languages\nare portable, meaning that they can run on different kinds of computers with few or no\nmodifications. Low-level programs can run on only one kind of computer and have to\nbe rewritten to run on another.\n\n\nDue to these advantages, almost all programs are written in high-level languages. Lowlevel\nlanguages are used only for a few specialized applications.\n\n\nTwo kinds of programs process high-level languages into low-level languages:\ninterpreters and compilers. An interpreter reads a high-level program and executes it,\nmeaning that it does what the program says. It processes the program a little at a time,\nalternately reading lines and performing computations. Figure 1-1 shows the structure\nof an interpreter.\n\n\n \n\n\nA compiler reads the program and translates it completely before the program starts\nrunning. In this context, the high-level program is called the source code, and the\ntranslated program is called the object code or the executable. Once a program is com\npiled, you can execute it repeatedly without further translation. Figure 1-2 shows the\nstructure of a compiler.\n\n\n\n\nPython is considered an interpreted language because Python programs are executed\nby an interpreter. There are two ways to use the interpreter: \ninteractive\n mode and \nscript mode\n. In interactive mode, you type Python programs and the interpreter displays the\nresult:\n>\n 1 + 1\n2\nThe chevron, \n, is the prompt the interpreter uses to indicate that it is ready. If you\ntype 1 + 1, the interpreter replies 2.\n\n\nAlternatively, you can store code in a file and use the interpreter to execute the contents\nof the file, which is called a script. By convention, Python scripts have names that end\nwith .py.\nTo execute the script, you have to tell the interpreter the name of the file. If you have a\nscript named dinsdale.py and you are working in a UNIX command window, you type\npython dinsdale.py. In other development environments, the details of executing\nscripts are different. You can find instructions for your environment at the Python web\nsite http://python.org.\nWorking in interactive mode is convenient for testing small pieces of code because you\ncan type and execute them immediately. But for anything more than a few lines, you\nshould save your code as a script so you can modify and execute it in the future.\n\n\n\n\nSource:\n \n\n\n  \nThink Python\n by Allen B. Downey  - 2012\n\n\n\n\nPython\u2019s View\n\n\nThe brief description in the prior section is fairly standard for scripting languages, and\nit\u2019s usually all that most Python programmers need to know. You type code into text\nfiles, and you run those files through the interpreter. Under the hood, though, a bit\nmore happens when you tell Python to \u201cgo.\u201d Although knowledge of Python internals\nis not strictly required for Python programming, a basic understanding of the runtime\nstructure of Python can help you grasp the bigger picture of program execution.\nWhen you instruct Python to run your script, there are a few steps that Python carries\nout before your code actually starts crunching away. Specifically, it\u2019s first compiled to\nsomething called \u201cbyte code\u201d and then routed to something called a \u201cvirtual machine.\u201d\n\n\nByte code compilation\n\n\nInternally, and almost completely hidden from you, when you execute a program\nPython first compiles your source code (the statements in your file) into a format known\nas byte code. Compilation is simply a translation step, and byte code is a lower-level,\nplatform-independent representation of your source code. Roughly, Python translates\neach of your source statements into a group of byte code instructions by decomposing\nthem into individual steps. This byte code translation is performed to speed\nexecution\u2014byte code can be run much more quickly than the original source code\nstatements in your text file.\nYou\u2019ll notice that the prior paragraph said that this is almost completely hidden from\nyou. If the Python process has write access on your machine, it will store the byte code\nof your programs in files that end with a .pyc extension (\u201c.pyc\u201d means compiled \u201c.py\u201d\nsource). You will see these files show up on your computer after you\u2019ve run a few\nprograms alongside the corresponding source code files (that is, in the same\ndirectories).\nPython saves byte code like this as a startup speed optimization. The next time you run\nyour program, Python will load the .pyc files and skip the compilation step, as long as\nyou haven\u2019t changed your source code since the byte code was last saved. Python automatically\nchecks the timestamps of source and byte code files to know when it must\nrecompile\u2014if you resave your source code, byte code is automatically re-created the\nnext time your program is run.\nIf Python cannot write the byte code files to your machine, your program still works\u2014\nthe byte code is generated in memory and simply discarded on program exit.* However,\nbecause .pyc files speed startup time, you\u2019ll want to make sure they are written for larger\nprograms. Byte code files are also one way to ship Python programs\u2014Python is happy\nto run a program if all it can find are .pyc files, even if the original .py source files are\nabsent.\n\n\nThe Python Virtual Machine (PVM)\n\n\nOnce your program has been compiled to byte code (or the byte code has been loaded\nfrom existing .pyc files), it is shipped off for execution to something generally known\nas the Python Virtual Machine (PVM, for the more acronym-inclined among you). The\nPVM sounds more impressive than it is; really, it\u2019s not a separate program, and it need\nnot be installed by itself. In fact, the PVM is just a big loop that iterates through your\nbyte code instructions, one by one, to carry out their operations. The PVM is the runtime\nengine of Python; it\u2019s always present as part of the Python system, and it\u2019s the\ncomponent that truly runs your scripts. Technically, it\u2019s just the last step of what is\ncalled the \u201cPython interpreter.\u201d\n\n\n\n\nFigure  illustrates the runtime structure described here. Keep in mind that all of this\ncomplexity is deliberately hidden from Python programmers. Byte code compilation is\nautomatic, and the PVM is just part of the Python system that you have installed on\nyour machine. Again, programmers simply code and run files of statements.\n\n\nPerformance implications\n\n\nReaders with a background in fully compiled languages such as C and C++ might notice\na few differences in the Python model. For one thing, there is usually no build or \u201cmake\u201d\nstep in Python work: code runs immediately after it is written. For another, Python byte\ncode is not binary machine code (e.g., instructions for an Intel chip). Byte code is a\nPython-specific representation.\n\n\nThis is why some Python code may not run as fast as C or C++ code, as described in\nChapter 1\u2014the PVM loop, not the CPU chip, still must interpret the byte code, and\nbyte code instructions require more work than CPU instructions. On the other hand,\nunlike in classic interpreters, there is still an internal compile step\u2014Python does not\nneed to reanalyze and reparse each source statement repeatedly. The net effect is that\npure Python code runs at speeds somewhere between those of a traditional compiled\nlanguage and a traditional interpreted language. See Chapter 1 for more on Python\nperformance tradeoffs.\n\n\n\n\nSource:\n \n\n\n  \nLearning Python, Fourth Edition\n by Mark Lutz  - 2009\n\n\n\n\nPython Implementation Alternatives\n\n\nReally, as this book is being written, there are three primary implementations of the\nPython language\u2014CPython, Jython, and IronPython\u2014along with a handful of secondary\nimplementations such as Stackless Python. In brief, CPython is the standard implementation;\nall the others have very specific purposes and roles. All implement the\nsame Python language but execute programs in different ways.\n\n\nCPython\n\n\nThe original, and standard, implementation of Python is usually called CPython, when\nyou want to contrast it with the other two. Its name comes from the fact that it is coded\nin portable ANSI C language code. This is the Python that you fetch from http://www\n.python.org, get with the ActivePython distribution, and have automatically on most\nLinux and Mac OS X machines. If you\u2019ve found a preinstalled version of Python on\nyour machine, it\u2019s probably CPython, unless your company is using Python in very\nspecialized ways.\nUnless you want to script Java or .NET applications with Python, you probably want\nto use the standard CPython system. Because it is the reference implementation of the\nlanguage, it tends to run the fastest, be the most complete, and be more robust than\nthe alternative systems. Figure 1-3 reflects CPython\u2019s runtime architecture.\n\n\nJython\n\n\nThe Jython system (originally known as JPython) is an alternative implementation of\nthe Python language, targeted for integration with the Java programming language.\nJython consists of Java classes that compile Python source code to Java byte code and\nthen route the resulting byte code to the Java Virtual Machine (JVM). Programmers\nstill code Python statements in .py text files as usual; the Jython system essentially just\nreplaces the rightmost two bubbles in Figure 1-3 with Java-based equivalents.\nJython\u2019s goal is to allow Python code to script Java applications, much as CPython\nallows Python to script C and C++ components. Its integration with Java is remarkably\nseamless. Because Python code is translated to Java byte code, it looks and feels like a\ntrue Java program at runtime. Jython scripts can serve as web applets and servlets, build\nJava-based GUIs, and so on. Moreover, Jython includes integration support that allows\nPython code to import and use Java classes as though they were coded in Python.\nBecause Jython is slower and less robust than CPython, though, it is usually seen as a\ntool of interest primarily to Java developers looking for a scripting language to be a\nfrontend to Java code.\n\n\nIronPython\n\n\nA third implementation of Python, and newer than both CPython and Jython,\nIronPython is designed to allow Python programs to integrate with applications coded\nto work with Microsoft\u2019s .NET Framework for Windows, as well as the Mono open\nsource equivalent for Linux. .NET and its C# programming language runtime system\nare designed to be a language-neutral object communication layer, in the spirit of Microsoft\u2019s\nearlier COM model. IronPython allows Python programs to act as both client\nand server components, accessible from other .NET languages.\nBy implementation, IronPython is very much like Jython (and, in fact, was developed\nby the same creator)\u2014it replaces the last two bubbles in Figure 1-3 with equivalents\nfor execution in the .NET environment. Also, like Jython, IronPython has a special\nfocus\u2014it is primarily of interest to developers integrating Python with .NET components.\nBecause it is being developed by Microsoft, though, IronPython might also be\nable to leverage some important optimization tools for better performance.\nIronPython\u2019s scope is still evolving as I write this; for more details, consult the Python\nonline resources or search the Web.\n\n\n\n\nSource:\n \n\n\n \nLearning Python, Fourth Edition\n by Mark Lutz  - 2009\n\n\n\n\nPython Programming Language Advantages\n\n\nPython is a dynamic, strongly typed, object oriented, multipurpose programming language, designed to be quick (to learn, to use, and to understand), and to enforce a clean and uniform syntax.\n\n\n\n\nPython is dynamically typed: it means that you don't declare a type (e.g. 'integer') for a variable name, and then assign something of that type (and only that type). Instead, you have variable names, and you bind them to entities whose type stays with the entity itself. a = 5 makes the variable name a to refer to the integer 5. Later, a = \"hello\" makes the variable name a to refer to a string containing \"hello\". Static typed languages would have you declare int a and then a = 5, but assigning a = \"hello\" would have been a compile time error. On one hand, this makes everything more unpredictable (you don't know what a refers to). On the other hand, it makes very easy to achieve some results a static typed languages makes very difficult.\n\n\nPython is strongly typed. It means that if a = \"5\" (the string whose value is '5') will remain a string, and never coerced to a number if the context requires so. Every type conversion in python must be done explicitly. This is different from, for example, Perl or Javascript, where you have weak typing, and can write things like \"hello\" + 5 to get \"hello5\".\n\n\nPython is object oriented, with class-based inheritance. Everything is an object (including classes, functions, modules, etc), in the sense that they can be passed around as arguments, have methods and attributes, and so on. \n\n\nPython is multipurpose: it is not specialised to a specific target of users (like R for statistics, or PHP for web programming). It is extended through modules and libraries, that hook very easily into the C programming language.\n\n\nPython enforces correct indentation of the code by making the indentation part of the syntax. There are no control braces in Python. Blocks of code are identified by the level of indentation. Although a big turn off for many programmers not used to this, it is precious as it gives a very uniform style and results in code that is visually pleasant to read.\n\n\nThe code is compiled into byte code and then executed in a virtual machine. This means that precompiled code is portable between platforms.\n\n\n\n\nPython can be used for any programming task, from GUI programming to web programming with everything else in between. It's quite efficient, as much of its activity is done at the C level. Python is just a layer on top of C. There are libraries for everything you can think of: game programming and openGL, GUI interfaces, web frameworks, semantic web, scientific computing...\n\n\n\n\nSource:\n \n\n\n https://stackoverflow.com/questions/1909512/what-is-python-used-for\n\n\n\n\nAdventages again\n\n\n\n\nEasy Syntax\n\nPython's syntax is easy to learn, so both non-programmers and programmers can start programming right away.\n\n\nReadability\n\nPython's syntax is very clear, so it is easy to understand program code. (Python is often referred to as \"executable pseudo-code\" because its syntax mostly follows the conventions used by programmers to outline their ideas without the formal verbosity of code in most programming languages; in other words syntax of Python is almost identical to the simplified \"pseudo-code\" used by many programmers to prototype and describe their solution to other programmers. Thus Python can be used to prototype and test code which is later to be implemented in other programming languages).[citation needed]\n\n\nHigh-Level Language\n\nPython looks more like a readable, human language than like a low-level language. This gives you the ability to program at a faster rate than a low-level language will allow you.\n\n\nObject oriented programming\n\nObject-oriented programming allows you to create data structures that can be re-used, which reduces the amount of repetitive work that you'll need to do. Programming languages usually define objects with namespaces, like class or def, and objects can edit themselves by using keyword, like this or self. Most modern programming languages are object-oriented (such as Java, C++, and C#) or have support for OOP features (such as Perl version 5 and later). Additionally object-oriented techniques can be used in the design of almost any non-trivial software and implemented in almost any programming or scripting language. (For example a number of Linux kernel features are \"objects\" which implement their own encapsulation of behavior and data structive via pointers, specifically pointers to functions, in the C programming language).[citation needed] Python's support for object-oriented programming is one of its greatest benefits to new programmers because they will be encountering the same concepts and terminology in their work environment. If you ever decide to switch languages, or use any other for that fact, you'll have a significant chance that you'll be working with object-oriented programming.[1]\n\n\nIt's Free\n\nPython is both free and open-source. The Python Software Foundation distributes pre-made binaries that are freely available for use on all major operating systems called CPython. You can get CPython's source-code, too. Plus, you can modify the source code and distribute as allowed by CPython's license. [2] (Luckily, CPython has a permissive free software license attitude.)\n\n\nCross-platform\n\nPython runs on all major operating systems like Microsoft Windows, Linux, and Mac OS X.\n\n\nWidely Supported\n\nPython has an active support community with many web sites, mailing lists, and USENET \"netnews\" groups that attract a large number of knowledgeable and helpful contributes.\n\n\nIt's Safe\n\nPython doesn't have pointers like other C-based languages, making it much more reliable. Along with that, errors never pass silently unless they're explicitly silenced. This allows you to see and read why the program crashed and where to correct your error.\n\n\nBatteries Included\n\nPython is famous for being the \"batteries are included\" language.[3] There are over 300 standard library modules which contain modules and classes for a wide variety of programming tasks.[citation needed] For example the standard library contains modules for safely creating temporary files (named or anonymous), mapping files into memory (including use of shared and anonymous memory mappings), spawning and controlling sub-processes, compressing and decompressing files (compatible with gzip or PK-zip) and archives files (such as Unix/Linux \"tar\"), accessing indexed \"DBM\" (database) files, interfacing to various graphical user interfaces (such as the TK toolkit and the popular WxWindows multi-platform windowing system), parsing and maintaining CSV (comma-separated values) and \".cfg\" or \".ini\" configuration files (similar in syntax to the venerable WIN.INI files from MS-DOS and MS-Windows), for sending e-mail, fetching and parsing web pages, etc. It's possible, for example, to create a custom web server in Python using less than a dozen lines of code, and one of the standard libraries, of course.\n\n\nExtensible\n\nIn addition to the standard libraries there are extensive collections of freely available add-on modules, libraries, frameworks, and tool-kits. These generally conform to similar standards and conventions; for example almost all of the database adapters (to talk to almost any client-server RDBMS engine such as MySQL, Postgres, Oracle, etc) conform to the Python DBAPI and thus can mostly be accessed using the same code. So it's usually easy to modify a Python program to support any database engine.\n\n\n\n\n\n\nSource:\n \n\n\n https://en.wikiversity.org/wiki/Python_Concepts/Why_learn_Python\n\n\n\n\nWho Uses Python Today ?\n\n\nHere are links to just a few of the organizations that use python:\n\n- \n https://wiki.python.org/moin/OrganizationsUsingPython\n\n\nPython Success Stories :\n\n- \n https://www.python.org/about/success",
            "title": "The Python Programming Language, Implementation and Adventages"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#the-python-programming-language",
            "text": "The programming language you will learn is Python. Python is an example of a highlevel\nlanguage; other high-level languages you might have heard of are  C, C++, Perl, \nand  Java .\nThere are also low-level languages, sometimes referred to as  \u201cmachine languages\u201d  or \u201cassembly languages.\u201d  Loosely speaking, computers can only run programs written in\nlow-level languages. So programs written in a high-level language have to be processed\nbefore they can run. This extra processing takes some time, which is a small disadvantage\nof high-level languages.  The advantages are enormous. First, it is much easier to program in a high-level lan\nguage. Programs written in a high-level language take less time to write, they are shorter\nand easier to read, and they are more likely to be correct. Second, high-level languages\nare portable, meaning that they can run on different kinds of computers with few or no\nmodifications. Low-level programs can run on only one kind of computer and have to\nbe rewritten to run on another.  Due to these advantages, almost all programs are written in high-level languages. Lowlevel\nlanguages are used only for a few specialized applications.  Two kinds of programs process high-level languages into low-level languages:\ninterpreters and compilers. An interpreter reads a high-level program and executes it,\nmeaning that it does what the program says. It processes the program a little at a time,\nalternately reading lines and performing computations. Figure 1-1 shows the structure\nof an interpreter.     A compiler reads the program and translates it completely before the program starts\nrunning. In this context, the high-level program is called the source code, and the\ntranslated program is called the object code or the executable. Once a program is com\npiled, you can execute it repeatedly without further translation. Figure 1-2 shows the\nstructure of a compiler.   Python is considered an interpreted language because Python programs are executed\nby an interpreter. There are two ways to use the interpreter:  interactive  mode and  script mode . In interactive mode, you type Python programs and the interpreter displays the\nresult:\n>  1 + 1\n2\nThe chevron,  , is the prompt the interpreter uses to indicate that it is ready. If you\ntype 1 + 1, the interpreter replies 2.  Alternatively, you can store code in a file and use the interpreter to execute the contents\nof the file, which is called a script. By convention, Python scripts have names that end\nwith .py.\nTo execute the script, you have to tell the interpreter the name of the file. If you have a\nscript named dinsdale.py and you are working in a UNIX command window, you type\npython dinsdale.py. In other development environments, the details of executing\nscripts are different. You can find instructions for your environment at the Python web\nsite http://python.org.\nWorking in interactive mode is convenient for testing small pieces of code because you\ncan type and execute them immediately. But for anything more than a few lines, you\nshould save your code as a script so you can modify and execute it in the future.   Source:       Think Python  by Allen B. Downey  - 2012",
            "title": "The Python Programming Language"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#pythons-view",
            "text": "The brief description in the prior section is fairly standard for scripting languages, and\nit\u2019s usually all that most Python programmers need to know. You type code into text\nfiles, and you run those files through the interpreter. Under the hood, though, a bit\nmore happens when you tell Python to \u201cgo.\u201d Although knowledge of Python internals\nis not strictly required for Python programming, a basic understanding of the runtime\nstructure of Python can help you grasp the bigger picture of program execution.\nWhen you instruct Python to run your script, there are a few steps that Python carries\nout before your code actually starts crunching away. Specifically, it\u2019s first compiled to\nsomething called \u201cbyte code\u201d and then routed to something called a \u201cvirtual machine.\u201d",
            "title": "Python\u2019s View"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#byte-code-compilation",
            "text": "Internally, and almost completely hidden from you, when you execute a program\nPython first compiles your source code (the statements in your file) into a format known\nas byte code. Compilation is simply a translation step, and byte code is a lower-level,\nplatform-independent representation of your source code. Roughly, Python translates\neach of your source statements into a group of byte code instructions by decomposing\nthem into individual steps. This byte code translation is performed to speed\nexecution\u2014byte code can be run much more quickly than the original source code\nstatements in your text file.\nYou\u2019ll notice that the prior paragraph said that this is almost completely hidden from\nyou. If the Python process has write access on your machine, it will store the byte code\nof your programs in files that end with a .pyc extension (\u201c.pyc\u201d means compiled \u201c.py\u201d\nsource). You will see these files show up on your computer after you\u2019ve run a few\nprograms alongside the corresponding source code files (that is, in the same\ndirectories).\nPython saves byte code like this as a startup speed optimization. The next time you run\nyour program, Python will load the .pyc files and skip the compilation step, as long as\nyou haven\u2019t changed your source code since the byte code was last saved. Python automatically\nchecks the timestamps of source and byte code files to know when it must\nrecompile\u2014if you resave your source code, byte code is automatically re-created the\nnext time your program is run.\nIf Python cannot write the byte code files to your machine, your program still works\u2014\nthe byte code is generated in memory and simply discarded on program exit.* However,\nbecause .pyc files speed startup time, you\u2019ll want to make sure they are written for larger\nprograms. Byte code files are also one way to ship Python programs\u2014Python is happy\nto run a program if all it can find are .pyc files, even if the original .py source files are\nabsent.",
            "title": "Byte code compilation"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#the-python-virtual-machine-pvm",
            "text": "Once your program has been compiled to byte code (or the byte code has been loaded\nfrom existing .pyc files), it is shipped off for execution to something generally known\nas the Python Virtual Machine (PVM, for the more acronym-inclined among you). The\nPVM sounds more impressive than it is; really, it\u2019s not a separate program, and it need\nnot be installed by itself. In fact, the PVM is just a big loop that iterates through your\nbyte code instructions, one by one, to carry out their operations. The PVM is the runtime\nengine of Python; it\u2019s always present as part of the Python system, and it\u2019s the\ncomponent that truly runs your scripts. Technically, it\u2019s just the last step of what is\ncalled the \u201cPython interpreter.\u201d   Figure  illustrates the runtime structure described here. Keep in mind that all of this\ncomplexity is deliberately hidden from Python programmers. Byte code compilation is\nautomatic, and the PVM is just part of the Python system that you have installed on\nyour machine. Again, programmers simply code and run files of statements.",
            "title": "The Python Virtual Machine (PVM)"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#performance-implications",
            "text": "Readers with a background in fully compiled languages such as C and C++ might notice\na few differences in the Python model. For one thing, there is usually no build or \u201cmake\u201d\nstep in Python work: code runs immediately after it is written. For another, Python byte\ncode is not binary machine code (e.g., instructions for an Intel chip). Byte code is a\nPython-specific representation.  This is why some Python code may not run as fast as C or C++ code, as described in\nChapter 1\u2014the PVM loop, not the CPU chip, still must interpret the byte code, and\nbyte code instructions require more work than CPU instructions. On the other hand,\nunlike in classic interpreters, there is still an internal compile step\u2014Python does not\nneed to reanalyze and reparse each source statement repeatedly. The net effect is that\npure Python code runs at speeds somewhere between those of a traditional compiled\nlanguage and a traditional interpreted language. See Chapter 1 for more on Python\nperformance tradeoffs.   Source:       Learning Python, Fourth Edition  by Mark Lutz  - 2009",
            "title": "Performance implications"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#python-implementation-alternatives",
            "text": "Really, as this book is being written, there are three primary implementations of the\nPython language\u2014CPython, Jython, and IronPython\u2014along with a handful of secondary\nimplementations such as Stackless Python. In brief, CPython is the standard implementation;\nall the others have very specific purposes and roles. All implement the\nsame Python language but execute programs in different ways.",
            "title": "Python Implementation Alternatives"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#cpython",
            "text": "The original, and standard, implementation of Python is usually called CPython, when\nyou want to contrast it with the other two. Its name comes from the fact that it is coded\nin portable ANSI C language code. This is the Python that you fetch from http://www\n.python.org, get with the ActivePython distribution, and have automatically on most\nLinux and Mac OS X machines. If you\u2019ve found a preinstalled version of Python on\nyour machine, it\u2019s probably CPython, unless your company is using Python in very\nspecialized ways.\nUnless you want to script Java or .NET applications with Python, you probably want\nto use the standard CPython system. Because it is the reference implementation of the\nlanguage, it tends to run the fastest, be the most complete, and be more robust than\nthe alternative systems. Figure 1-3 reflects CPython\u2019s runtime architecture.",
            "title": "CPython"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#jython",
            "text": "The Jython system (originally known as JPython) is an alternative implementation of\nthe Python language, targeted for integration with the Java programming language.\nJython consists of Java classes that compile Python source code to Java byte code and\nthen route the resulting byte code to the Java Virtual Machine (JVM). Programmers\nstill code Python statements in .py text files as usual; the Jython system essentially just\nreplaces the rightmost two bubbles in Figure 1-3 with Java-based equivalents.\nJython\u2019s goal is to allow Python code to script Java applications, much as CPython\nallows Python to script C and C++ components. Its integration with Java is remarkably\nseamless. Because Python code is translated to Java byte code, it looks and feels like a\ntrue Java program at runtime. Jython scripts can serve as web applets and servlets, build\nJava-based GUIs, and so on. Moreover, Jython includes integration support that allows\nPython code to import and use Java classes as though they were coded in Python.\nBecause Jython is slower and less robust than CPython, though, it is usually seen as a\ntool of interest primarily to Java developers looking for a scripting language to be a\nfrontend to Java code.",
            "title": "Jython"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#ironpython",
            "text": "A third implementation of Python, and newer than both CPython and Jython,\nIronPython is designed to allow Python programs to integrate with applications coded\nto work with Microsoft\u2019s .NET Framework for Windows, as well as the Mono open\nsource equivalent for Linux. .NET and its C# programming language runtime system\nare designed to be a language-neutral object communication layer, in the spirit of Microsoft\u2019s\nearlier COM model. IronPython allows Python programs to act as both client\nand server components, accessible from other .NET languages.\nBy implementation, IronPython is very much like Jython (and, in fact, was developed\nby the same creator)\u2014it replaces the last two bubbles in Figure 1-3 with equivalents\nfor execution in the .NET environment. Also, like Jython, IronPython has a special\nfocus\u2014it is primarily of interest to developers integrating Python with .NET components.\nBecause it is being developed by Microsoft, though, IronPython might also be\nable to leverage some important optimization tools for better performance.\nIronPython\u2019s scope is still evolving as I write this; for more details, consult the Python\nonline resources or search the Web.   Source:      Learning Python, Fourth Edition  by Mark Lutz  - 2009",
            "title": "IronPython"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#python-programming-language-advantages",
            "text": "Python is a dynamic, strongly typed, object oriented, multipurpose programming language, designed to be quick (to learn, to use, and to understand), and to enforce a clean and uniform syntax.   Python is dynamically typed: it means that you don't declare a type (e.g. 'integer') for a variable name, and then assign something of that type (and only that type). Instead, you have variable names, and you bind them to entities whose type stays with the entity itself. a = 5 makes the variable name a to refer to the integer 5. Later, a = \"hello\" makes the variable name a to refer to a string containing \"hello\". Static typed languages would have you declare int a and then a = 5, but assigning a = \"hello\" would have been a compile time error. On one hand, this makes everything more unpredictable (you don't know what a refers to). On the other hand, it makes very easy to achieve some results a static typed languages makes very difficult.  Python is strongly typed. It means that if a = \"5\" (the string whose value is '5') will remain a string, and never coerced to a number if the context requires so. Every type conversion in python must be done explicitly. This is different from, for example, Perl or Javascript, where you have weak typing, and can write things like \"hello\" + 5 to get \"hello5\".  Python is object oriented, with class-based inheritance. Everything is an object (including classes, functions, modules, etc), in the sense that they can be passed around as arguments, have methods and attributes, and so on.   Python is multipurpose: it is not specialised to a specific target of users (like R for statistics, or PHP for web programming). It is extended through modules and libraries, that hook very easily into the C programming language.  Python enforces correct indentation of the code by making the indentation part of the syntax. There are no control braces in Python. Blocks of code are identified by the level of indentation. Although a big turn off for many programmers not used to this, it is precious as it gives a very uniform style and results in code that is visually pleasant to read.  The code is compiled into byte code and then executed in a virtual machine. This means that precompiled code is portable between platforms.   Python can be used for any programming task, from GUI programming to web programming with everything else in between. It's quite efficient, as much of its activity is done at the C level. Python is just a layer on top of C. There are libraries for everything you can think of: game programming and openGL, GUI interfaces, web frameworks, semantic web, scientific computing...   Source:     https://stackoverflow.com/questions/1909512/what-is-python-used-for",
            "title": "Python Programming Language Advantages"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#adventages-again",
            "text": "Easy Syntax \nPython's syntax is easy to learn, so both non-programmers and programmers can start programming right away.  Readability \nPython's syntax is very clear, so it is easy to understand program code. (Python is often referred to as \"executable pseudo-code\" because its syntax mostly follows the conventions used by programmers to outline their ideas without the formal verbosity of code in most programming languages; in other words syntax of Python is almost identical to the simplified \"pseudo-code\" used by many programmers to prototype and describe their solution to other programmers. Thus Python can be used to prototype and test code which is later to be implemented in other programming languages).[citation needed]  High-Level Language \nPython looks more like a readable, human language than like a low-level language. This gives you the ability to program at a faster rate than a low-level language will allow you.  Object oriented programming \nObject-oriented programming allows you to create data structures that can be re-used, which reduces the amount of repetitive work that you'll need to do. Programming languages usually define objects with namespaces, like class or def, and objects can edit themselves by using keyword, like this or self. Most modern programming languages are object-oriented (such as Java, C++, and C#) or have support for OOP features (such as Perl version 5 and later). Additionally object-oriented techniques can be used in the design of almost any non-trivial software and implemented in almost any programming or scripting language. (For example a number of Linux kernel features are \"objects\" which implement their own encapsulation of behavior and data structive via pointers, specifically pointers to functions, in the C programming language).[citation needed] Python's support for object-oriented programming is one of its greatest benefits to new programmers because they will be encountering the same concepts and terminology in their work environment. If you ever decide to switch languages, or use any other for that fact, you'll have a significant chance that you'll be working with object-oriented programming.[1]  It's Free \nPython is both free and open-source. The Python Software Foundation distributes pre-made binaries that are freely available for use on all major operating systems called CPython. You can get CPython's source-code, too. Plus, you can modify the source code and distribute as allowed by CPython's license. [2] (Luckily, CPython has a permissive free software license attitude.)  Cross-platform \nPython runs on all major operating systems like Microsoft Windows, Linux, and Mac OS X.  Widely Supported \nPython has an active support community with many web sites, mailing lists, and USENET \"netnews\" groups that attract a large number of knowledgeable and helpful contributes.  It's Safe \nPython doesn't have pointers like other C-based languages, making it much more reliable. Along with that, errors never pass silently unless they're explicitly silenced. This allows you to see and read why the program crashed and where to correct your error.  Batteries Included \nPython is famous for being the \"batteries are included\" language.[3] There are over 300 standard library modules which contain modules and classes for a wide variety of programming tasks.[citation needed] For example the standard library contains modules for safely creating temporary files (named or anonymous), mapping files into memory (including use of shared and anonymous memory mappings), spawning and controlling sub-processes, compressing and decompressing files (compatible with gzip or PK-zip) and archives files (such as Unix/Linux \"tar\"), accessing indexed \"DBM\" (database) files, interfacing to various graphical user interfaces (such as the TK toolkit and the popular WxWindows multi-platform windowing system), parsing and maintaining CSV (comma-separated values) and \".cfg\" or \".ini\" configuration files (similar in syntax to the venerable WIN.INI files from MS-DOS and MS-Windows), for sending e-mail, fetching and parsing web pages, etc. It's possible, for example, to create a custom web server in Python using less than a dozen lines of code, and one of the standard libraries, of course.  Extensible \nIn addition to the standard libraries there are extensive collections of freely available add-on modules, libraries, frameworks, and tool-kits. These generally conform to similar standards and conventions; for example almost all of the database adapters (to talk to almost any client-server RDBMS engine such as MySQL, Postgres, Oracle, etc) conform to the Python DBAPI and thus can mostly be accessed using the same code. So it's usually easy to modify a Python program to support any database engine.    Source:     https://en.wikiversity.org/wiki/Python_Concepts/Why_learn_Python",
            "title": "Adventages again"
        },
        {
            "location": "/beginner/Python_Programming_Lanuage/#who-uses-python-today",
            "text": "Here are links to just a few of the organizations that use python: \n-   https://wiki.python.org/moin/OrganizationsUsingPython  Python Success Stories : \n-   https://www.python.org/about/success",
            "title": "Who Uses Python Today ?"
        },
        {
            "location": "/beginner/Python_Installation/",
            "text": "Python Download and Installation Instructions\n\n\nInstall Python on Windows\n\n\n\n\nInstall Python on Ubuntu\n\n\n\n\nInstall Python on Mac",
            "title": "Python Installation"
        },
        {
            "location": "/beginner/Python_Installation/#python-download-and-installation-instructions",
            "text": "",
            "title": "Python Download and Installation Instructions"
        },
        {
            "location": "/beginner/Python_Installation/#install-python-on-windows",
            "text": "",
            "title": "Install Python on Windows"
        },
        {
            "location": "/beginner/Python_Installation/#install-python-on-ubuntu",
            "text": "",
            "title": "Install Python on Ubuntu"
        },
        {
            "location": "/beginner/Python_Installation/#install-python-on-mac",
            "text": "",
            "title": "Install Python on Mac"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/",
            "text": "What Is a Program?\n\n\nA program is a sequence of instructions that specifies how to perform a computation.\nThe computation might be something mathematical, such as solving a system of equat\nions or finding the roots of a polynomial, but it can also be a symbolic computation,\nsuch as searching and replacing text in a document or (strangely enough) compiling a\nprogram.\nThe details look different in different languages, but a few basic instructions appear in\njust about every language:\n\n\ninput: \n\n\n\n\nGet data from the keyboard, a file, or some other device.\n\n\n\n\noutput:\n\n\n\n\nDisplay data on the screen or send data to a file or other device.\n\n\n\n\nmath:\n\n\n\n\nPerform basic mathematical operations like addition and\n   multiplication.\n\n\n\n\nconditional execution:\n\n\n\n\nCheck for certain conditions and execute the appropriate code.\n\n\n\n\nrepetition:\n\n\n\n\nPerform some action repeatedly, usually with some variation.\n\n\n\n\nBelieve it or not, that\u2019s pretty much all there is to it. Every program you\u2019ve ever used, no\nmatter how complicated, is made up of instructions that look pretty much like these. So\nyou can think of programming as the process of breaking a large, complex task into\nsmaller and smaller subtasks until the subtasks are simple enough to be performed with\none of these basic instructions.\nThat may be a little vague, but we will come back to this topic when we talk about\nalgorithms.\n\n\n\n\nSource:\n \n\n\n  \nThink Python\n by Allen B. Downey  - 2012\n\n\n\n\nRun Python Scripts\n\n\nIf you can't execute or run a Python script, then programming is pointless. When you run a Python script, the interpreter converts a Python program into something that that the computer can understand. Executing a Python program can be done in two ways: calling the Python interpreter with a shebang line, and using the interactive Python shell.\n\n\nRun a Python Script as a File\n\n\nGenerally programmers write stand alone scripts, that are independent to live environments. Then they save it with a \".py\" extension, which indicates to the operating system and programmer that the file is actually a Python program. After the interpreter is invoked, it reads and interprets the file. The way Python scripts are run on Windows versus Unix based operating systems is very different. We'll show you the difference, and how to run a Python script on Windows and Unix platforms.\n\n\nRun a Python script under Windows with the Command Prompt\n\n\nWindows users must pass the path of the program as an argument to the Python interpreter. Such as follows:\n\n\nC:\n\\P\nython27\n\\p\nython.exe C:\n\\U\nsers\n\\U\nsername\n\\D\nesktop\n\\m\ny_python_script.py\n\n\n\n\n\nNote that you must use the full path of the Python interpreter. If you want to simply type python.exe C:\\Users\\Username\\Desktop\\my_python_script.py you must add python.exe to your PATH environmental variable.\nNote that Windows comes with two Python executables - python.exe and pythonw.exe. If you want a terminal to pop-up when you run your script, use python.exe However if you don't want any terminal pop-up, use pythonw.exe. pythonw.exe is typically used for GUI programs, where you only want to display your program, not the terminal.\n\n\nRun a Python Script Under Mac, Linux, BSD, Unix, etc\n\n\nOn platforms like Mac, BSD or Linux (Unix) you can put a \"shebang\" line as first line of the program which indicates the location of the Python interpreter on the hard drive. It's in the following format:\n\n\n#!/path/to/interpreter\n\n\n\n\n\n\nA common shebang line used for the Python interpreter is as follows:\n\n\n#!/usr/bin/env python\n\n\n\n\n\n\nYou must then make the script executable, using the following command:\n\n\nchmod +x my_python_script.py\n\n\n\n\n\nUnlike Windows, the Python interpreter is typically already in the $PATH environmental variable, so adding it is un-necessary.\n\n\nYou can then run a program by invoking the Python interpreter manually as follows:\n\n\npython firstprogram.py\n\n\n\n\n\nPython Execution with the Shell (Live Interpreter)\n\n\nAssuming that you already have Python installed and running well (if you're getting an error, see this post), open the terminal or console and type 'python' and hit the 'Enter' key. You will then be directed immediately to the Python live interpreter. Your screen will display a message something like:\n\n\nuser@hostname:~ python\nPython \n3\n.3.0 \n(\ndefault, Nov \n23\n \n2012\n, \n10\n:26:01\n)\n \n\n[\nGCC \n4\n.2.1 Compatible Apple Clang \n4\n.1 \n((\ntags/Apple/clang-421.11.66\n))]\n on darwin\nType \nhelp\n, \ncopyright\n, \ncredits\n or \nlicense\n \nfor\n more information.\n\n\n\n\n\n\n\nThe Python programmer should keep in mind one thing: that while working with the live interpreter, everything is read and interpreted in real-time. For example loops iterate immediately, unless they are part of function. So it requires some mental planning. Using the Python shell is typically used to execute code interactively. If you want to run a Python script from the interpreter, you must either import it or call the Python executable.\n\n\n\n\nSource:\n \n\n\n  http://pythoncentral.io/execute-python-script-file-shell/\n\n\n\n\nA Good First Program\n\n\nType the following text into a single file named \nex1.py\n. Python works best with files ending in \n.py\n.\n\n\nprint\n \nHello World!\n\n\nprint\n \nHello Again\n\n\nprint\n \nI like typing this.\n\n\nprint\n \nThis is fun.\n\n\nprint\n \nYay! Printing.\n\n\nprint\n \nI\nd much rather you \nnot\n.\n\n\nprint\n \nI \nsaid\n do not touch this.\n\n\n\n\n\n\nYour Atom text editor should look something like this on all platforms:\n\n\n\n\nDon't worry if your editor doesn't look exactly the same, it should be close though. You may have a slightly different window header, maybe slightly different colors, and the left side of your Atom window won't say \"zedshaw\" but will instead show the directory you used for saving your files. All of those differences are fine.\n\n\nWhen you create this file, keep in mind these points:\n\n\n\n\nI did not type the line numbers on the left. Those are printed in the book so I can talk about specific lines by saying, \"See line 5...\" You do not type line numbers into Python scripts.\n\n\nI have the print at the beginning of the line and it looks exactly the same as what I have in ex1.py. Exactly means exactly, not kind of sort of the same. Every single character has to match for it to work. Color doesn't matter, only the characters you type.\n\n\n\n\nIn Terminal run the file by typing:\n\n\npython ex1.py\n\n\n\n\n\nIf you did it right then you should see the same output as I in the What You Should See section of this exercise. If not, you have done something wrong. No, the computer is not wrong.\n\n\nWhat You Should See\n\n\nOn Mac OS X in the Terminal you should see this:\n\n\nOn Windows in PowerShell you should see this:\n\n\n\nYou may see different names, before the python ex1.py command, but the important part is that you type the command and see the output is the same as mine.\n\n\n\n\n\nIf you have an error it will look like this:\n\n\n$ python ex/ex1.py\n  File \nex/ex1.py\n, line \n3\n\n    print \nI like typing this.\n\n\n                             ^\n\n\nSyntaxError: EOL while scanning string literal\n\n\n\n\n\n\nIt's important that you can read these error messages because you will be making many of these mistakes. Even I make many of these mistakes. Let's look at this line by line.\n\n\n\n\nWe ran our command in the Terminal to run the ex1.py script.\n\n\nPython tells us that the file ex1.py has an error on line 3.\n\n\nIt prints this line of code for us to see it.\n\n\nThen it puts a ^ (caret) character to point at where the problem is. Notice the missing \" (double-quote) character?\n\n\nFinally, it prints out a \"SyntaxError\" and tells us something about what might be the error. Usually these are very cryptic, but if you copy that text into a search engine, you will find someone else who's had that error and you can probably figure out how to fix it.\n\n\n\n\n\n\nSource:\n \n\n\n  \nLEARN PYTHON THE HARD WAY\n by Zed A. Shaw  - 2013\n\n\n\n\nDebugging and Errors\n\n\nWhat Is Debugging?\n\n\nProgramming is error-prone. For whimsical reasons, programming errors are called\n\nbugs\n and the process of tracking them down is called \ndebugging\n.\nThree kinds of errors can occur in a program: syntax errors, runtime errors, and se\nmantic errors. It is useful to distinguish between them in order to track them down more\nquickly.\n\n\nError Types :\n\n\nSyntax Errors\n\n\nPython can only execute a program if the syntax is correct; otherwise, the interpreter\ndisplays an error message. Syntax refers to the structure of a program and the rules\nabout that structure.For example, parentheses have to come in matching pairs, so\n(1 + 2) is legal, but 8) is a \nsyntax error\n.\nIn English readers can tolerate most syntax errors, which is why we can read the poetry\nof e. e. cummings without spewing error messages. Python is not so forgiving. If there\nis a single syntax error anywhere in your program, Python will display an error message\nand quit, and you will not be able to run your program. During the first few weeks of\nyour programming career, you will probably spend a lot of time tracking down syntax\nerrors. As you gain experience, you will make fewer errors and find them faster.\n\n\nRuntime Errors\n\n\nThe second type of error is a runtime error, so called because the error does not appear\nuntil after the program has started running. These errors are also called exceptions\nbecause they usually indicate that something exceptional (and bad) has happened.\nRuntime errors are rare in the simple programs you will see in the first few chapters, so\nit might be a while before you encounter one.\n\n\nSemantic Errors\n\n\nThe third type of error is the semantic error. If there is a semantic error in your program,\nit will run successfully in the sense that the computer will not generate any error mess\nages, but it will not do the right thing. It will do something else. Specifically, it will do\nwhat you told it to do.\nThe problem is that the program you wrote is not the program you wanted to write. The\nmeaning of the program (its semantics) is wrong. Identifying semantic errors can be\ntricky because it requires you to work backward by looking at the output of the program\nand trying to figure out what it is doing.\n\n\n\n\nSource:\n \n\n\n  \nThink Python\n by Allen B. Downey  - 2012\n\n\n\n\nReserved Words\n\n\nThe following list shows the Python keywords. These are reserved words and you cannot use them as constants or variables or any other identifier names. All the Python keywords contain lowercase letters only.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand\n\n\nexec\n\n\nnot\n\n\n\n\n\n\nas\n\n\nfinally\n\n\nor\n\n\n\n\n\n\nassert\n\n\nfor\n\n\npass\n\n\n\n\n\n\nbreak\n\n\nfrom\n\n\nprint\n\n\n\n\n\n\nclass\n\n\nglobal\n\n\nraise\n\n\n\n\n\n\ncontinue\n\n\nif\n\n\nreturn\n\n\n\n\n\n\ndef\n\n\nimport\n\n\ntry\n\n\n\n\n\n\ndel\n\n\nin\n\n\nwhile\n\n\n\n\n\n\nelif\n\n\nis\n\n\nwith\n\n\n\n\n\n\nelse\n\n\nlambda\n\n\nyield\n\n\n\n\n\n\nexcept\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource:\n \n\n\n https://www.tutorialspoint.com",
            "title": "Start Coding With Python"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#what-is-a-program",
            "text": "A program is a sequence of instructions that specifies how to perform a computation.\nThe computation might be something mathematical, such as solving a system of equat\nions or finding the roots of a polynomial, but it can also be a symbolic computation,\nsuch as searching and replacing text in a document or (strangely enough) compiling a\nprogram.\nThe details look different in different languages, but a few basic instructions appear in\njust about every language:  input:    Get data from the keyboard, a file, or some other device.   output:   Display data on the screen or send data to a file or other device.   math:   Perform basic mathematical operations like addition and\n   multiplication.   conditional execution:   Check for certain conditions and execute the appropriate code.   repetition:   Perform some action repeatedly, usually with some variation.   Believe it or not, that\u2019s pretty much all there is to it. Every program you\u2019ve ever used, no\nmatter how complicated, is made up of instructions that look pretty much like these. So\nyou can think of programming as the process of breaking a large, complex task into\nsmaller and smaller subtasks until the subtasks are simple enough to be performed with\none of these basic instructions.\nThat may be a little vague, but we will come back to this topic when we talk about\nalgorithms.   Source:       Think Python  by Allen B. Downey  - 2012",
            "title": "What Is a Program?"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#run-python-scripts",
            "text": "If you can't execute or run a Python script, then programming is pointless. When you run a Python script, the interpreter converts a Python program into something that that the computer can understand. Executing a Python program can be done in two ways: calling the Python interpreter with a shebang line, and using the interactive Python shell.",
            "title": "Run Python Scripts"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#run-a-python-script-as-a-file",
            "text": "Generally programmers write stand alone scripts, that are independent to live environments. Then they save it with a \".py\" extension, which indicates to the operating system and programmer that the file is actually a Python program. After the interpreter is invoked, it reads and interprets the file. The way Python scripts are run on Windows versus Unix based operating systems is very different. We'll show you the difference, and how to run a Python script on Windows and Unix platforms.",
            "title": "Run a Python Script as a File"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#run-a-python-script-under-windows-with-the-command-prompt",
            "text": "Windows users must pass the path of the program as an argument to the Python interpreter. Such as follows:  C: \\P ython27 \\p ython.exe C: \\U sers \\U sername \\D esktop \\m y_python_script.py  Note that you must use the full path of the Python interpreter. If you want to simply type python.exe C:\\Users\\Username\\Desktop\\my_python_script.py you must add python.exe to your PATH environmental variable.\nNote that Windows comes with two Python executables - python.exe and pythonw.exe. If you want a terminal to pop-up when you run your script, use python.exe However if you don't want any terminal pop-up, use pythonw.exe. pythonw.exe is typically used for GUI programs, where you only want to display your program, not the terminal.",
            "title": "Run a Python script under Windows with the Command Prompt"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#run-a-python-script-under-mac-linux-bsd-unix-etc",
            "text": "On platforms like Mac, BSD or Linux (Unix) you can put a \"shebang\" line as first line of the program which indicates the location of the Python interpreter on the hard drive. It's in the following format:  #!/path/to/interpreter   A common shebang line used for the Python interpreter is as follows:  #!/usr/bin/env python   You must then make the script executable, using the following command:  chmod +x my_python_script.py  Unlike Windows, the Python interpreter is typically already in the $PATH environmental variable, so adding it is un-necessary.  You can then run a program by invoking the Python interpreter manually as follows:  python firstprogram.py",
            "title": "Run a Python Script Under Mac, Linux, BSD, Unix, etc"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#python-execution-with-the-shell-live-interpreter",
            "text": "Assuming that you already have Python installed and running well (if you're getting an error, see this post), open the terminal or console and type 'python' and hit the 'Enter' key. You will then be directed immediately to the Python live interpreter. Your screen will display a message something like:  user@hostname:~ python\nPython  3 .3.0  ( default, Nov  23   2012 ,  10 :26:01 )   [ GCC  4 .2.1 Compatible Apple Clang  4 .1  (( tags/Apple/clang-421.11.66 ))]  on darwin\nType  help ,  copyright ,  credits  or  license   for  more information.   The Python programmer should keep in mind one thing: that while working with the live interpreter, everything is read and interpreted in real-time. For example loops iterate immediately, unless they are part of function. So it requires some mental planning. Using the Python shell is typically used to execute code interactively. If you want to run a Python script from the interpreter, you must either import it or call the Python executable.   Source:      http://pythoncentral.io/execute-python-script-file-shell/",
            "title": "Python Execution with the Shell (Live Interpreter)"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#a-good-first-program",
            "text": "Type the following text into a single file named  ex1.py . Python works best with files ending in  .py .  print   Hello World!  print   Hello Again  print   I like typing this.  print   This is fun.  print   Yay! Printing.  print   I d much rather you  not .  print   I  said  do not touch this.   Your Atom text editor should look something like this on all platforms:   Don't worry if your editor doesn't look exactly the same, it should be close though. You may have a slightly different window header, maybe slightly different colors, and the left side of your Atom window won't say \"zedshaw\" but will instead show the directory you used for saving your files. All of those differences are fine.  When you create this file, keep in mind these points:   I did not type the line numbers on the left. Those are printed in the book so I can talk about specific lines by saying, \"See line 5...\" You do not type line numbers into Python scripts.  I have the print at the beginning of the line and it looks exactly the same as what I have in ex1.py. Exactly means exactly, not kind of sort of the same. Every single character has to match for it to work. Color doesn't matter, only the characters you type.   In Terminal run the file by typing:  python ex1.py  If you did it right then you should see the same output as I in the What You Should See section of this exercise. If not, you have done something wrong. No, the computer is not wrong.",
            "title": "A Good First Program"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#what-you-should-see",
            "text": "On Mac OS X in the Terminal you should see this: \nOn Windows in PowerShell you should see this:  You may see different names, before the python ex1.py command, but the important part is that you type the command and see the output is the same as mine.   If you have an error it will look like this:  $ python ex/ex1.py\n  File  ex/ex1.py , line  3 \n    print  I like typing this.                               ^  SyntaxError: EOL while scanning string literal   It's important that you can read these error messages because you will be making many of these mistakes. Even I make many of these mistakes. Let's look at this line by line.   We ran our command in the Terminal to run the ex1.py script.  Python tells us that the file ex1.py has an error on line 3.  It prints this line of code for us to see it.  Then it puts a ^ (caret) character to point at where the problem is. Notice the missing \" (double-quote) character?  Finally, it prints out a \"SyntaxError\" and tells us something about what might be the error. Usually these are very cryptic, but if you copy that text into a search engine, you will find someone else who's had that error and you can probably figure out how to fix it.    Source:       LEARN PYTHON THE HARD WAY  by Zed A. Shaw  - 2013",
            "title": "What You Should See"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#debugging-and-errors",
            "text": "",
            "title": "Debugging and Errors"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#what-is-debugging",
            "text": "Programming is error-prone. For whimsical reasons, programming errors are called bugs  and the process of tracking them down is called  debugging .\nThree kinds of errors can occur in a program: syntax errors, runtime errors, and se\nmantic errors. It is useful to distinguish between them in order to track them down more\nquickly.",
            "title": "What Is Debugging?"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#error-types",
            "text": "",
            "title": "Error Types :"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#syntax-errors",
            "text": "Python can only execute a program if the syntax is correct; otherwise, the interpreter\ndisplays an error message. Syntax refers to the structure of a program and the rules\nabout that structure.For example, parentheses have to come in matching pairs, so\n(1 + 2) is legal, but 8) is a  syntax error .\nIn English readers can tolerate most syntax errors, which is why we can read the poetry\nof e. e. cummings without spewing error messages. Python is not so forgiving. If there\nis a single syntax error anywhere in your program, Python will display an error message\nand quit, and you will not be able to run your program. During the first few weeks of\nyour programming career, you will probably spend a lot of time tracking down syntax\nerrors. As you gain experience, you will make fewer errors and find them faster.",
            "title": "Syntax Errors"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#runtime-errors",
            "text": "The second type of error is a runtime error, so called because the error does not appear\nuntil after the program has started running. These errors are also called exceptions\nbecause they usually indicate that something exceptional (and bad) has happened.\nRuntime errors are rare in the simple programs you will see in the first few chapters, so\nit might be a while before you encounter one.",
            "title": "Runtime Errors"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#semantic-errors",
            "text": "The third type of error is the semantic error. If there is a semantic error in your program,\nit will run successfully in the sense that the computer will not generate any error mess\nages, but it will not do the right thing. It will do something else. Specifically, it will do\nwhat you told it to do.\nThe problem is that the program you wrote is not the program you wanted to write. The\nmeaning of the program (its semantics) is wrong. Identifying semantic errors can be\ntricky because it requires you to work backward by looking at the output of the program\nand trying to figure out what it is doing.   Source:       Think Python  by Allen B. Downey  - 2012",
            "title": "Semantic Errors"
        },
        {
            "location": "/beginner/Start_Coding_With_Python/#reserved-words",
            "text": "The following list shows the Python keywords. These are reserved words and you cannot use them as constants or variables or any other identifier names. All the Python keywords contain lowercase letters only.            and  exec  not    as  finally  or    assert  for  pass    break  from  print    class  global  raise    continue  if  return    def  import  try    del  in  while    elif  is  with    else  lambda  yield    except        Source:     https://www.tutorialspoint.com",
            "title": "Reserved Words"
        },
        {
            "location": "/beginner/Datatype_And_Variables/",
            "text": "Datatype \n Variables\n\n\nVariables are named locations which are used to store references to the object stored in memory. The names we choose for variables and functions are commonly known as Identifiers. In python Identifiers must obey the following rules.\n\n\n\n\nAll identifiers must start with letter or underscore ( _ ) , you\n    can\u2019t use digits. For e.g my_var  is valid identifier while 1digit \n    is not.\n\n\nIdentifiers can contain letters, digits and underscores ( _  ). \n\n\nThey  can be of any length.\n\n\n\n\nIdentifier can\u2019t be a keyword (keywords are reserved words that\n    Python uses for special purpose).Following are Keywords in python 3.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand\n\n\nexec\n\n\nnot\n\n\n\n\n\n\nas\n\n\nfinally\n\n\nor\n\n\n\n\n\n\nassert\n\n\nfor\n\n\npass\n\n\n\n\n\n\nbreak\n\n\nfrom\n\n\nprint\n\n\n\n\n\n\nclass\n\n\nglobal\n\n\nraise\n\n\n\n\n\n\ncontinue\n\n\nif\n\n\nreturn\n\n\n\n\n\n\ndef\n\n\nimport\n\n\ntry\n\n\n\n\n\n\ndel\n\n\nin\n\n\nwhile\n\n\n\n\n\n\nelif\n\n\nis\n\n\nwith\n\n\n\n\n\n\nelse\n\n\nlambda\n\n\nyield\n\n\n\n\n\n\nexcept\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAssigning Values to Variables\n\n\nValues are basic things that programs works with. For e.g 1 , 11 , 3.14 , \"hello\"  are all values. In programming terminology they are also commonly known as literals. Literals can be of different type for e.g 1 , 11  are of type int , 3.14  is float and \"hello\"  is string . Remember in python everything is object even basic data types like int, float, string, we will elaborate more on this in later chapters.\n\n\nIn python you don\u2019t need to declare types of variable ahead of time. Interpreter automatically detects the type of the variable by the data it contains. To assign value to a variable equal sign ( = ) is used. =  is also known as assignment operator.\n\n\nFollowing are some examples of variable declaration:\n\n\nx\n \n=\n \n100\n                       \n# x is integer\n\n\npi\n \n=\n \n3.14\n                     \n# pi is float\n\n\nempname\n \n=\n \npython is great\n   \n# empname is string\n\n\n\na\n \n=\n \nb\n \n=\n \nc\n \n=\n \n100\n \n# this statement assign 100 to c, b and a.\n\n\n\n\n\n\n\n\nNote:\n\nIn the above code x  stores reference to the 100  ( which is an int object ) , x  don\u2019t store 100 itself.\n\n\n\n\nIn Python comments are preceded by a pound sign ( # ). Comments are not programming statements that python interpreter executes while running the program. Comments are used by programmers to remind themselves how the program works. They are also used to write program documentation.\n\n\n#display hello world\n\n\nprint\n(\nhello world\n)\n\n\n\n\n\n\nSimultaneous Assignments\n\n\nPython allow simultaneous assignment syntax like this:\n\n\nvar1\n,\n \nvar2\n,\n \n...\n,\n \nvarn\n \n=\n \nexp1\n,\n \nexp2\n,\n \n...\n,\n \nexpn\n\n\n\n\n\n\nthis statements tells the python to evaluate all the expression on the right and assign them to the corresponding variables on the left. Simultaneous Assignments is helpful to swap values of two variables. For e.g\n\n\n \nx\n \n=\n \n1\n\n\n \ny\n \n=\n \n2\n\n\n\n \ny\n,\n \nx\n \n=\n \nx\n,\n \ny\n \n# assign y value to x and x value to y\n\n\n\n\n\n\nPython Data Types\n\n\nPython has 5 standard data types namely.\na) \nNumbers\n\nb) \nString\n\nc)  \nList\n\nd) \nTuple\n\ne) \nDictionary\n\nf)  Boolean \u2013 In Python True and False  are boolean literals.  But the following values are also considered as false.\n\n\n[] \u2013 empty list , () \u2013 empty tuple , {} \u2013 empty dictionary\n \n\n\nReceiving input from Console\n\n\ninput()  function is used to receive input from the console.\n\n\nSyntax:  input([prompt]) -\n string\n\n\ninput()  function accepts an optional string argument called prompt  and returns a string.\n\n\n \nname\n \n=\n \ninput\n(\nEnter your name: \n)\n\n\n \nEnter\n \nyour\n \nname\n:\n \ntim\n\n\n \nname\n\n\ntim\n\n\n\n\n\n\nNote that input()  returns string even if you enter a number, to convert it to an integer you can use int() or eval() .\n\n\n \nage\n \n=\n \nint\n(\ninput\n(\nEnter your age: \n))\n\n\nEnter\n \nyour\n \nage\n:\n \n22\n\n\n \nage\n\n\n22\n\n\n \ntype\n(\nage\n)\n\n\nclass\n \nint\n\n\n\n\n\n\n\n\nSource:\n \n\n\n http://thepythonguru.com\n\n\n\n\nUnderstanding Python variables and Memory Management\n\n\nHave you ever noticed any difference between variables in Python and C? For example, when you do an assignment like the following in C, it actually creates a block of memory space so that it can hold the value for that variable\n\n\nint\n \na\n \n=\n \n1\n;\n\n\n\n\n\n\nYou can think of it as putting the value assigned in a box with the variable name as shown below.\n\n\n\nAnd for all the variables you create a new box is created with the variable name to hold the value. If you change the value of the variable the box will be updated with the new value. That means doing\n\n\na\n \n=\n \n2\n;\n\n\n\n\n\n\nwill result in\n\n\n\n\nAssigning one variable to another makes a copy of the value and put that value in the new box.\n\n\nint\n \nb\n \n=\n \na\n;\n\n\n\n\n\n\n \n\n\nBut in Python variables work more like tags unlike the boxes you have seen before. When you do an assignment in Python, it tags the value with the variable name.\n\n\na\n \n=\n \n1\n\n\n\n\n\n\n\n\nand if you change the value of the varaible, it just changes the tag to the new value in memory. You dont need to do the housekeeping job of freeing the memory here. Python's Automatic Garbage Collection does it for you. When a value is without names/tags it is automatically removed from memory.\n\n\na\n \n=\n \n2\n\n\n\n\n\n\n\n\nAssigning one variable to another makes a new tag bound to the same value as show below.\n\n\nb\n \n=\n \na\n\n\n\n\n\n\n\nOther languages have 'variables'. Python has 'names'.\n\n\nA bit about Python's memory management\n\n\nAs you have seen before, a value will have only one copy in memory and all the variables having this value will refer to this memory location. For example when you have variables a, b, c having a value 10, it doesn't mean that there will be 3 copy of 10s in memory. There will be only one 10 and all the variables a, b, c will point to this value. Once a variable is updated, say you are doing a += 1 a new value 11 will be allocated in memory and a will be pointing to this.\n\n\nLet's check this behaviour with Python Interpreter. Start the Python Shell and try the following for yourselves.\n\n\n \na\n \n=\n \n10\n\n\n \nb\n \n=\n \n10\n\n\n \nc\n \n=\n \n10\n\n\n \nid\n(\na\n),\n \nid\n(\nb\n),\n \nid\n(\nc\n)\n\n\n(\n140621897573616\n,\n \n140621897573616\n,\n \n140621897573616\n)\n\n\n \na\n \n+=\n \n1\n\n\n \nid\n(\na\n)\n\n\n140621897573592\n\n\n\n\n\n\nid() will return an objects memory address (object's identity). As you have noticed, when you assign the same integer value to the variables, we see the same ids. But this assumption does not hold true all the time. See the following for example\n\n\n \nx\n \n=\n \n500\n\n\n \ny\n \n=\n \n500\n\n\n \nid\n(\nx\n)\n\n\n4338740848\n\n\n \nid\n(\ny\n)\n\n\n4338741040\n\n\n\n\n\n\nWhat happened here? Even after assigning the same integer values to different variable names, we are getting two different ids here. These are actually the effects of CPython optimization we are observing here. CPython implementation keeps an array of integer objects for all integers between -5 and 256. So when we create an integer in that range, they simply back reference to the existing object. You may refer the following \nlinks\n for more information.\n\n\nLet's take a look at strings now.\n\n\n \ns1\n \n=\n \nhello\n\n\n \ns2\n \n=\n \nhello\n\n\n \nid\n(\ns1\n),\n \nid\n(\ns2\n)\n\n\n(\n4454725888\n,\n \n4454725888\n)\n\n\n \ns1\n \n==\n \ns2\n\n\nTrue\n\n\n \ns1\n \nis\n \ns2\n\n\nTrue\n\n\n \ns3\n \n=\n \nhello, world!\n\n\n \ns4\n \n=\n \nhello, world!\n\n\n \nid\n(\ns3\n),\n \nid\n(\ns4\n)\n\n\n(\n4454721608\n,\n \n4454721664\n)\n\n\n \ns3\n \n==\n \ns4\n\n\nTrue\n\n\n \ns3\n \nis\n \ns4\n\n\nFalse\n\n\n\n\n\n\nLooks interesting, isn't it? When the string was a simple and shorter one the variable names where referring to the same object in memory. But when they became bigger, this was not the case. This is called interning, and Python does interning (to some extent) of shorter string literals (as in s1 and s2) which are created at compile time. But in general, Python string literals creates a new string object each time (as in s3 and s4). Interning is runtime dependant and is always a trade-off between memory use and the cost of checking if you are creating the same string. There's a built-in intern() function to forcefully apply interning. Read more about interning from the following links.\n\n\nStack Overflow: Does Python intern Strings?\n\n\nStack Overflow: Python String Interning\n\n\nInternals of Python String Interning\n\n\n\n\nSource:\n \n\n\n http://foobarnbaz.com/2012/07/08/understanding-python-variables/\n\n\n\n\nAssignment statements in Python are more interesting than you might think\n\n\nIn this article, we will take a deep look at three kinds of assignment statements in Python and discuss what\u2019s going on under the hood.\n\n\n \nmy_string\n \n=\n \nHello World\n                \n# right hand side is a simple expression\n\n\n \nanother_string\n \n=\n \nmy_string\n               \n# right hand side is another variable\n\n\n \nanother_string\n \n=\n \nanother_string\n \n+\n \n!\n    \n# right hand side is an operation\n\n\n\n\n\n\nWhat we find may surprise you.\n\n\nWhat happens when the right hand side is a simple expression?\n\n\n \nmy_string\n \n=\n \nHello World\n\n\n\n\n\n\nIn simple terms, this creates a string \u201cHello World\u201d in memory and assigns the name my_string to it. If you are using CPython[1], then we can even check the memory address explicitly by using the built in function id .\n\n\n \nmy_string\n \n=\n \n\u201c\nHello\n \nWorld\n\u201d\n \n\n \nid\n(\nmy_string\n)\n\n\n140400709562064\n\n\n\n\n\n\nThat big number 140400709562064 denotes where the data lives in the memory. It will be very useful for us in this entire discussion.\nWhat happens if we create another string with the same value?\n\n\n \nanother_string\n \n=\n \n\u201c\nHello\n \nWorld\n\u201d\n\n\n\n\n\n\nDoes it reuse the previous \u201cHello World\u201d stored in memory or does it create an independent copy? Let\u2019s check this by querying the id function again.\n\n\n \nid\n(\nanother_string\n)\n\n\n140400709562208\n\n\n\n\n\n\nThis outputs a different id, so this must be an independent copy. We conclude that:\n\n\n\n\nNote:\n\nAssignment statements where the right hand side is a simple expression creates independent copies every time.\n\n\n\n\nWhile for everyday programming, this is the rule we should remember, there are actually some weird exceptions to this rule. Here\u2019s an example.\n\n\n \nmy_string\n \n=\n \n\u201c\nhello\n\u201d\n\n\n \nid\n(\nmy_string\n)\n\n\n140400709562016\n\n\n \nanother_string\n \n=\n \n\u201c\nhello\n\u201d\n\n\n \nid\n(\nanother_string\n)\n\n\n140400709562016\n\n\n\n\n\n\nIn this case, two consecutive assignment statements did not create independent copies. Why?\nIt gets interesting now.\nFor optimizing memory, Python treats a special set of objects differently. The string \u201chello\u201d belongs to this privileged set and has a different behavior. The exact set depends on the implementation like CPython, PyPy, Jython or IronPython. For CPython, the special rule applies to:\n\n\n\n\nStrings without whitespaces and less than 20 characters and\n\n\nIntegers from -5 to +255.\n\n\n\n\nThese objects are always reused or interned. The rationale behind doing this is as follows:\n\n\n\n\nSince programmers use these objects frequently, interning existing\n    objects saves memory.\n\n\nSince immutable objects like tuples and strings cannot be modified,\n    there is no risk in interning the same object.\n\n\n\n\nHowever, Python does not do this for all immutable objects because there is a runtime cost involved for this feature. For interning an object, it must first search for the object in memory, and searching takes time. This is why the special treatment only applies for small integers and strings, because finding them is not that costly.\n\n\nWhat happens when the right hand side is an existing Python variable?\n\nLet\u2019s move on to the second type of assignment statement where the right hand side is an existing Python variable.\n\n\n \nanother_string\n \n=\n \nmy_string\n\n\n\n\n\n\nIn this case, nothing is created in memory. After the assignment, both variables refer to the already existing object. It\u2019s basically like giving the object an additional nickname or alias. Let\u2019s confirm this by using the id function.\n\n\n \nmy_string\n \n=\n \n\u201c\nHello\n \nWorld\n\u201d\n\n\n \nid\n(\nmy_string\n)\n\n\n140400709562160\n\n\n \nanother_string\n \n=\n \nmy_string\n\n\n \nid\n(\nanother_string\n)\n\n\n140400709562160\n\n\n\n\n\n\nThe natural question at this stage is : what if, instead of just giving the existing object an alias, we wanted to create an independent copy?\nFor mutable objects, this is possible. You can either use the copy module of Python (which works on all objects) or you may use copy methods specific to the class. For a list, you have several possibilities for creating copies, all of which have different runtime.\n\n\n \nmy_list\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n \ncopy_of_my_list\n \n=\n \nmy_list\n.\ncopy\n()\n       \n# fastest, works only on latest Python versions\n\n\n \ncopy_of_my_list\n \n=\n \nmy_list\n[:]\n           \n# same runtime as List.copy()\n\n\n \ncopy_of_my_list\n \n=\n \nlist\n(\nmy_list\n)\n        \n# slightly slower\n\n\n \nimport\n \ncopy\n\n\n \ncopy_of_my_list\n \n=\n \ncopy\n.\ncopy\n(\nmy_list\n)\n   \n# slowest\n\n\n\n\n\n\nHow can you copy an immutable object? Well\u2026you can\u2019t! At least not in a straightforward way. If you try to use the copy module or the slicing notation, you will get back the same object and not an independent copy. Here\u2019s proof.\n\n\n# Standard ways of copying lists do not apply for tuples\n\n\n\n \nmy_tuple\n \n=\n \n(\n1\n,\n \n2\n,\n \n3\n)\n\n\n \nid\n(\nmy_tuple\n)\n\n\n140371873244816\n\n\n \nanother_tuple\n \n=\n \nmy_tuple\n[:]\n\n\n \nid\n(\nanother_tuple\n)\n\n\n140371873244816\n\n\n\n# The copy module also doesn\u2019t help\n\n\n\n \nimport\n \ncopy\n \n\n \nanother_tuple\n \n=\n \ncopy\n.\ncopy\n(\nmy_tuple\n)\n\n\n \nid\n(\nanother_tuple\n)\n\n\n140371873244816\n\n\n\n\n\n\nMore importantly, there is no reason for explicitly copying an immutable object anyway. We will see why in a moment when we discuss the third kind of assignment statement.\n\nWhat happpens when the right hand side is an operation?\n\n\nIn this case, what happens depends on the result of the operation. We will discuss two simple cases:\n\n\n\n\nadding an element to an immutable object (like a tuple) and\n\n\nadding an element to a mutable object (like a list).\n\n\n\n\nLet\u2019s start with the case of the tuple.\n\n\n \nanother_tuple\n \n+=\n  \n(\n4\n,)\n\n\n\n\n\n\nWhen you add a new element to a tuple using another_tuple += (4,), this creates a new object in memory. The immutability of tuples is key to understanding this. Since tuples are immutable, any operation that leads to a changed tuple would result in an independent copy.\nThis is the reason why you don\u2019t need to explicitly copy immutable objects : it happens automatically under the hood. Here\u2019s an example.\n\n\n \nmy_tuple\n \n=\n \n(\n1\n,\n \n2\n,\n \n3\n)\n\n\n \nanother_tuple\n \n=\n \nmy_tuple\n     \n# both variables point to the same object\n\n\n \nanother_tuple\n \n+=\n \n(\n4\n,)\n        \n# this statement creates a new independent object\n\n\n \nprint\n(\nanother_tuple\n)\n \n\n(\n1\n,\n \n2\n,\n \n3\n,\n \n4\n)\n\n\n \nprint\n(\nmy_tuple\n)\n              \n# the old one remains unharmed\n\n\n(\n1\n,\n \n2\n,\n \n3\n)\n\n\n\n\n\n\nThe situation is much different for mutable objects and much more confusing. Let\u2019s try the same example, but now for lists.\n\n\n \nmy_list\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n \nanother_list\n \n=\n \nmy_list\n     \n# both variables point to the same object\n\n\n \nanother_list\n \n+=\n \n[\n4\n,]\n       \n# this statement modifies the object in place\n\n\n \nprint\n(\nanother_list\n)\n\n\n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n \nprint\n(\nmy_list\n)\n             \n# the original list is modified\n\n\n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n\n\n\n\nMutable objects can be modified in place. Some operations modify the list in place and some operations don\u2019t. In this case, the statement another_list += [4,] calls another_list.\niadd\n([4,]) and \niadd\n modifies the existing object in place.\nTo make things doubly confusing, we would have completely different results if we used a slightly different notation.\n\n\n \nmy_list\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n \nanother_list\n \n=\n \nmy_list\n              \n# both variables point to the same object\n\n\n \nanother_list\n \n=\n \nanother_list\n \n+\n \n[\n4\n,]\n  \n# this creates an independent copy\n\n\n \nprint\n(\nanother_list\n)\n\n\n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n \nprint\n(\nmy_list\n)\n                      \n# the original list is unharmed\n\n\n[\n1\n,\n \n2\n,\n \n3\n]\n  \n\n\n\n\n\nWoah! What\u2019s going on? What changed?\nIt turns out that when we change the third line, Python now internally calls a different function another_list.\nadd\n([4,]) instead of \niadd\n. This function returns a new copy instead of modifying the list in place.\nTo prevent this confusion, it is always better to create a true copy of the list if you wish to prevent modification to the original.\nLet\u2019s remember the list copy methods from before. They were List.copy(), [:], list() and copy.copy(). This is what we should use.\n\n\n \nmy_list\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n \nanother_list\n \n=\n \nmy_list\n.\ncopy\n()\n   \n# this creates an independent copy\n\n\n \nanother_list\n \n+=\n \n[\n4\n,]\n            \n# this statement modifies the independent copy\n\n\n \nprint\n(\nanother_list\n)\n\n\n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n \nprint\n(\nmy_list\n)\n                  \n# the original list is unharmed\n\n\n[\n1\n,\n \n2\n,\n \n3\n]\n   \n\n\n\n\n\nThere\u2019s one last gotcha that can happen when copying lists.\nSuppose we have a list that has a nested list inside it. We copy this list using List.copy() and then modify the nested list. Unfortunately, this will modify the original list again!\n\n\n \nmy_list\n \n=\n \n[[\n1\n,\n \n2\n,\n \n3\n],\n \n4\n,\n \n5\n]\n\n\n \nanother_list\n \n=\n \nmy_list\n.\ncopy\n()\n\n\n \nanother_list\n[\n0\n]\n \n+=\n \n[\n6\n,]\n\n\n \nprint\n(\nanother_list\n)\n\n\n[[\n1\n,\n \n2\n,\n \n3\n,\n \n6\n],\n \n4\n,\n \n5\n]\n\n\n \nprint\n(\nmy_list\n)\n\n\n[[\n1\n,\n \n2\n,\n \n3\n,\n \n6\n],\n \n4\n,\n \n5\n]\n \n\n\n\n\n\nWhy did that happen? Didn\u2019t we just copy the original list?\nThe truth is : we actually don\u2019t have a completely independent copy in this case. The copy() function generates a shallow copy. To see what it does, let\u2019s look at the ids of all the elements in my_list and the ids of all the elements in the copied list.\n\n\n# for my_list\n\n\n\n \nmy_list\n \n=\n \n[[\n1\n,\n \n2\n,\n \n3\n],\n \n4\n,\n \n5\n]\n\n\n \nid\n(\nmy_list\n)\n\n\n140371873277424\n\n\n \nprint\n([\nid\n(\nx\n)\n \nfor\n \nx\n \nin\n \nmy_list\n])\n\n\n[\n140371873599288\n,\n \n13820176\n,\n \n13820152\n]\n\n\n\n# for another_list obtained by my_list.copy()\n\n\n\n \nid\n(\nanother_list\n)\n\n\n140371873317016\n\n\n \nprint\n([\nid\n(\nx\n)\n \nfor\n \nx\n \nin\n \nanother_list\n])\n\n\n[\n140371873599288\n,\n \n13820176\n,\n \n13820152\n]\n\n\n\n\n\n\nWe see the ids of my_list and another_list are indeed different, indicating another_list is a copy. But the ids of the elements contained in another_list have the same ids as the elements in my_list . So the elements have not been copied!\nThis is the property of shallow copy. It creates a new copy of the object but reuses the attributes and elements of the old copy. Thus, when you modify the elements of the new copy, you are modifying the elements of the old copy too.\nTo solve this problem, we need to copy an object along with all its attributes and elements. This can be achieved by copy.deepcopy.\n\n\n \nmy_list\n \n=\n \n[[\n1\n,\n \n2\n,\n \n3\n],\n \n4\n,\n \n5\n]\n\n\n \nanother_list\n \n=\n \ncopy\n.\ndeepcopy\n(\nmy_list\n)\n\n\n \nanother_list\n[\n0\n]\n \n+=\n \n[\n6\n,]\n\n\n \nanother_list\n\n\n[[\n1\n,\n \n2\n,\n \n3\n,\n \n6\n],\n \n4\n,\n \n5\n]\n\n\n \nmy_list\n\n\n[[\n1\n,\n \n2\n,\n \n3\n],\n \n4\n,\n \n5\n]\n\n\n\n\n\n\nDeep copy is a quite time intensive operation and can take 1o times longer to complete compared to a shallow copy. But in some situations, it is unavoidable.\n\n\nConclusion\n\n\nThis brings me to the end of this discussion. To summarize, we have talked about the different scenarios which can arise in an assignment statement in Python. We found that:\n\n\n\n\nWhen the right hand side is a simple expression, a new copy is\n   created every time. There are some exceptions to this rule, which\n   depend on the implementation\n\n\nWhen the right hand side is an existing Python variable, then an\n   alias is created for the existing copy.\n\n\nWhen the right hand side is an operation, then the outcome depends on\n   the operation. In a simple case involving a tuple, we saw that an\n   independent copy was created. In the same case with lists, we saw\n   that the list was modified in place in one case (when we used\n   \niadd\n) and a new copy was generated in another case (when we used \nadd\n).\n\n\nList item\n\n\nMutable objects can be copied but immutable objects cannot be copied\n   in a straightforward way. There is also no need to copy immutable\n   objects.\n\n\nTo copy a mutable object along with all its attributes and elements,\n   we need to use deep copy.\n\n\n\n\n\n\nSource:\n \n\n\n https://medium.com/broken-window/many-names-one-memory-address-122f78734cb6",
            "title": "Datatype And Variables"
        },
        {
            "location": "/beginner/Datatype_And_Variables/#datatype-variables",
            "text": "Variables are named locations which are used to store references to the object stored in memory. The names we choose for variables and functions are commonly known as Identifiers. In python Identifiers must obey the following rules.   All identifiers must start with letter or underscore ( _ ) , you\n    can\u2019t use digits. For e.g my_var  is valid identifier while 1digit \n    is not.  Identifiers can contain letters, digits and underscores ( _  ).   They  can be of any length.   Identifier can\u2019t be a keyword (keywords are reserved words that\n    Python uses for special purpose).Following are Keywords in python 3.            and  exec  not    as  finally  or    assert  for  pass    break  from  print    class  global  raise    continue  if  return    def  import  try    del  in  while    elif  is  with    else  lambda  yield    except",
            "title": "Datatype &amp; Variables"
        },
        {
            "location": "/beginner/Datatype_And_Variables/#assigning-values-to-variables",
            "text": "Values are basic things that programs works with. For e.g 1 , 11 , 3.14 , \"hello\"  are all values. In programming terminology they are also commonly known as literals. Literals can be of different type for e.g 1 , 11  are of type int , 3.14  is float and \"hello\"  is string . Remember in python everything is object even basic data types like int, float, string, we will elaborate more on this in later chapters.  In python you don\u2019t need to declare types of variable ahead of time. Interpreter automatically detects the type of the variable by the data it contains. To assign value to a variable equal sign ( = ) is used. =  is also known as assignment operator.  Following are some examples of variable declaration:  x   =   100                         # x is integer  pi   =   3.14                       # pi is float  empname   =   python is great     # empname is string  a   =   b   =   c   =   100   # this statement assign 100 to c, b and a.    Note: \nIn the above code x  stores reference to the 100  ( which is an int object ) , x  don\u2019t store 100 itself.   In Python comments are preceded by a pound sign ( # ). Comments are not programming statements that python interpreter executes while running the program. Comments are used by programmers to remind themselves how the program works. They are also used to write program documentation.  #display hello world  print ( hello world )",
            "title": "Assigning Values to Variables"
        },
        {
            "location": "/beginner/Datatype_And_Variables/#simultaneous-assignments",
            "text": "Python allow simultaneous assignment syntax like this:  var1 ,   var2 ,   ... ,   varn   =   exp1 ,   exp2 ,   ... ,   expn   this statements tells the python to evaluate all the expression on the right and assign them to the corresponding variables on the left. Simultaneous Assignments is helpful to swap values of two variables. For e.g    x   =   1    y   =   2    y ,   x   =   x ,   y   # assign y value to x and x value to y",
            "title": "Simultaneous Assignments"
        },
        {
            "location": "/beginner/Datatype_And_Variables/#python-data-types",
            "text": "Python has 5 standard data types namely.\na)  Numbers \nb)  String \nc)   List \nd)  Tuple \ne)  Dictionary \nf)  Boolean \u2013 In Python True and False  are boolean literals.  But the following values are also considered as false.  [] \u2013 empty list , () \u2013 empty tuple , {} \u2013 empty dictionary",
            "title": "Python Data Types"
        },
        {
            "location": "/beginner/Datatype_And_Variables/#receiving-input-from-console",
            "text": "input()  function is used to receive input from the console.  Syntax:  input([prompt]) -  string  input()  function accepts an optional string argument called prompt  and returns a string.    name   =   input ( Enter your name:  )    Enter   your   name :   tim    name  tim   Note that input()  returns string even if you enter a number, to convert it to an integer you can use int() or eval() .    age   =   int ( input ( Enter your age:  ))  Enter   your   age :   22    age  22    type ( age )  class   int    Source:     http://thepythonguru.com",
            "title": "Receiving input from Console"
        },
        {
            "location": "/beginner/Datatype_And_Variables/#understanding-python-variables-and-memory-management",
            "text": "Have you ever noticed any difference between variables in Python and C? For example, when you do an assignment like the following in C, it actually creates a block of memory space so that it can hold the value for that variable  int   a   =   1 ;   You can think of it as putting the value assigned in a box with the variable name as shown below.  And for all the variables you create a new box is created with the variable name to hold the value. If you change the value of the variable the box will be updated with the new value. That means doing  a   =   2 ;   will result in   Assigning one variable to another makes a copy of the value and put that value in the new box.  int   b   =   a ;      But in Python variables work more like tags unlike the boxes you have seen before. When you do an assignment in Python, it tags the value with the variable name.  a   =   1    and if you change the value of the varaible, it just changes the tag to the new value in memory. You dont need to do the housekeeping job of freeing the memory here. Python's Automatic Garbage Collection does it for you. When a value is without names/tags it is automatically removed from memory.  a   =   2    Assigning one variable to another makes a new tag bound to the same value as show below.  b   =   a   \nOther languages have 'variables'. Python has 'names'.",
            "title": "Understanding Python variables and Memory Management"
        },
        {
            "location": "/beginner/Datatype_And_Variables/#a-bit-about-pythons-memory-management",
            "text": "As you have seen before, a value will have only one copy in memory and all the variables having this value will refer to this memory location. For example when you have variables a, b, c having a value 10, it doesn't mean that there will be 3 copy of 10s in memory. There will be only one 10 and all the variables a, b, c will point to this value. Once a variable is updated, say you are doing a += 1 a new value 11 will be allocated in memory and a will be pointing to this.  Let's check this behaviour with Python Interpreter. Start the Python Shell and try the following for yourselves.    a   =   10    b   =   10    c   =   10    id ( a ),   id ( b ),   id ( c )  ( 140621897573616 ,   140621897573616 ,   140621897573616 )    a   +=   1    id ( a )  140621897573592   id() will return an objects memory address (object's identity). As you have noticed, when you assign the same integer value to the variables, we see the same ids. But this assumption does not hold true all the time. See the following for example    x   =   500    y   =   500    id ( x )  4338740848    id ( y )  4338741040   What happened here? Even after assigning the same integer values to different variable names, we are getting two different ids here. These are actually the effects of CPython optimization we are observing here. CPython implementation keeps an array of integer objects for all integers between -5 and 256. So when we create an integer in that range, they simply back reference to the existing object. You may refer the following  links  for more information.  Let's take a look at strings now.    s1   =   hello    s2   =   hello    id ( s1 ),   id ( s2 )  ( 4454725888 ,   4454725888 )    s1   ==   s2  True    s1   is   s2  True    s3   =   hello, world!    s4   =   hello, world!    id ( s3 ),   id ( s4 )  ( 4454721608 ,   4454721664 )    s3   ==   s4  True    s3   is   s4  False   Looks interesting, isn't it? When the string was a simple and shorter one the variable names where referring to the same object in memory. But when they became bigger, this was not the case. This is called interning, and Python does interning (to some extent) of shorter string literals (as in s1 and s2) which are created at compile time. But in general, Python string literals creates a new string object each time (as in s3 and s4). Interning is runtime dependant and is always a trade-off between memory use and the cost of checking if you are creating the same string. There's a built-in intern() function to forcefully apply interning. Read more about interning from the following links.  Stack Overflow: Does Python intern Strings?  Stack Overflow: Python String Interning  Internals of Python String Interning   Source:     http://foobarnbaz.com/2012/07/08/understanding-python-variables/",
            "title": "A bit about Python's memory management"
        },
        {
            "location": "/beginner/Datatype_And_Variables/#assignment-statements-in-python-are-more-interesting-than-you-might-think",
            "text": "In this article, we will take a deep look at three kinds of assignment statements in Python and discuss what\u2019s going on under the hood.    my_string   =   Hello World                  # right hand side is a simple expression    another_string   =   my_string                 # right hand side is another variable    another_string   =   another_string   +   !      # right hand side is an operation   What we find may surprise you.  What happens when the right hand side is a simple expression?    my_string   =   Hello World   In simple terms, this creates a string \u201cHello World\u201d in memory and assigns the name my_string to it. If you are using CPython[1], then we can even check the memory address explicitly by using the built in function id .    my_string   =   \u201c Hello   World \u201d     id ( my_string )  140400709562064   That big number 140400709562064 denotes where the data lives in the memory. It will be very useful for us in this entire discussion.\nWhat happens if we create another string with the same value?    another_string   =   \u201c Hello   World \u201d   Does it reuse the previous \u201cHello World\u201d stored in memory or does it create an independent copy? Let\u2019s check this by querying the id function again.    id ( another_string )  140400709562208   This outputs a different id, so this must be an independent copy. We conclude that:   Note: \nAssignment statements where the right hand side is a simple expression creates independent copies every time.   While for everyday programming, this is the rule we should remember, there are actually some weird exceptions to this rule. Here\u2019s an example.    my_string   =   \u201c hello \u201d    id ( my_string )  140400709562016    another_string   =   \u201c hello \u201d    id ( another_string )  140400709562016   In this case, two consecutive assignment statements did not create independent copies. Why?\nIt gets interesting now.\nFor optimizing memory, Python treats a special set of objects differently. The string \u201chello\u201d belongs to this privileged set and has a different behavior. The exact set depends on the implementation like CPython, PyPy, Jython or IronPython. For CPython, the special rule applies to:   Strings without whitespaces and less than 20 characters and  Integers from -5 to +255.   These objects are always reused or interned. The rationale behind doing this is as follows:   Since programmers use these objects frequently, interning existing\n    objects saves memory.  Since immutable objects like tuples and strings cannot be modified,\n    there is no risk in interning the same object.   However, Python does not do this for all immutable objects because there is a runtime cost involved for this feature. For interning an object, it must first search for the object in memory, and searching takes time. This is why the special treatment only applies for small integers and strings, because finding them is not that costly.  What happens when the right hand side is an existing Python variable? \nLet\u2019s move on to the second type of assignment statement where the right hand side is an existing Python variable.    another_string   =   my_string   In this case, nothing is created in memory. After the assignment, both variables refer to the already existing object. It\u2019s basically like giving the object an additional nickname or alias. Let\u2019s confirm this by using the id function.    my_string   =   \u201c Hello   World \u201d    id ( my_string )  140400709562160    another_string   =   my_string    id ( another_string )  140400709562160   The natural question at this stage is : what if, instead of just giving the existing object an alias, we wanted to create an independent copy?\nFor mutable objects, this is possible. You can either use the copy module of Python (which works on all objects) or you may use copy methods specific to the class. For a list, you have several possibilities for creating copies, all of which have different runtime.    my_list   =   [ 1 ,   2 ,   3 ]    copy_of_my_list   =   my_list . copy ()         # fastest, works only on latest Python versions    copy_of_my_list   =   my_list [:]             # same runtime as List.copy()    copy_of_my_list   =   list ( my_list )          # slightly slower    import   copy    copy_of_my_list   =   copy . copy ( my_list )     # slowest   How can you copy an immutable object? Well\u2026you can\u2019t! At least not in a straightforward way. If you try to use the copy module or the slicing notation, you will get back the same object and not an independent copy. Here\u2019s proof.  # Standard ways of copying lists do not apply for tuples    my_tuple   =   ( 1 ,   2 ,   3 )    id ( my_tuple )  140371873244816    another_tuple   =   my_tuple [:]    id ( another_tuple )  140371873244816  # The copy module also doesn\u2019t help    import   copy     another_tuple   =   copy . copy ( my_tuple )    id ( another_tuple )  140371873244816   More importantly, there is no reason for explicitly copying an immutable object anyway. We will see why in a moment when we discuss the third kind of assignment statement. What happpens when the right hand side is an operation?  In this case, what happens depends on the result of the operation. We will discuss two simple cases:   adding an element to an immutable object (like a tuple) and  adding an element to a mutable object (like a list).   Let\u2019s start with the case of the tuple.    another_tuple   +=    ( 4 ,)   When you add a new element to a tuple using another_tuple += (4,), this creates a new object in memory. The immutability of tuples is key to understanding this. Since tuples are immutable, any operation that leads to a changed tuple would result in an independent copy.\nThis is the reason why you don\u2019t need to explicitly copy immutable objects : it happens automatically under the hood. Here\u2019s an example.    my_tuple   =   ( 1 ,   2 ,   3 )    another_tuple   =   my_tuple       # both variables point to the same object    another_tuple   +=   ( 4 ,)          # this statement creates a new independent object    print ( another_tuple )   ( 1 ,   2 ,   3 ,   4 )    print ( my_tuple )                # the old one remains unharmed  ( 1 ,   2 ,   3 )   The situation is much different for mutable objects and much more confusing. Let\u2019s try the same example, but now for lists.    my_list   =   [ 1 ,   2 ,   3 ]    another_list   =   my_list       # both variables point to the same object    another_list   +=   [ 4 ,]         # this statement modifies the object in place    print ( another_list )  [ 1 ,   2 ,   3 ,   4 ]    print ( my_list )               # the original list is modified  [ 1 ,   2 ,   3 ,   4 ]   Mutable objects can be modified in place. Some operations modify the list in place and some operations don\u2019t. In this case, the statement another_list += [4,] calls another_list. iadd ([4,]) and  iadd  modifies the existing object in place.\nTo make things doubly confusing, we would have completely different results if we used a slightly different notation.    my_list   =   [ 1 ,   2 ,   3 ]    another_list   =   my_list                # both variables point to the same object    another_list   =   another_list   +   [ 4 ,]    # this creates an independent copy    print ( another_list )  [ 1 ,   2 ,   3 ,   4 ]    print ( my_list )                        # the original list is unharmed  [ 1 ,   2 ,   3 ]     Woah! What\u2019s going on? What changed?\nIt turns out that when we change the third line, Python now internally calls a different function another_list. add ([4,]) instead of  iadd . This function returns a new copy instead of modifying the list in place.\nTo prevent this confusion, it is always better to create a true copy of the list if you wish to prevent modification to the original.\nLet\u2019s remember the list copy methods from before. They were List.copy(), [:], list() and copy.copy(). This is what we should use.    my_list   =   [ 1 ,   2 ,   3 ]    another_list   =   my_list . copy ()     # this creates an independent copy    another_list   +=   [ 4 ,]              # this statement modifies the independent copy    print ( another_list )  [ 1 ,   2 ,   3 ,   4 ]    print ( my_list )                    # the original list is unharmed  [ 1 ,   2 ,   3 ]      There\u2019s one last gotcha that can happen when copying lists.\nSuppose we have a list that has a nested list inside it. We copy this list using List.copy() and then modify the nested list. Unfortunately, this will modify the original list again!    my_list   =   [[ 1 ,   2 ,   3 ],   4 ,   5 ]    another_list   =   my_list . copy ()    another_list [ 0 ]   +=   [ 6 ,]    print ( another_list )  [[ 1 ,   2 ,   3 ,   6 ],   4 ,   5 ]    print ( my_list )  [[ 1 ,   2 ,   3 ,   6 ],   4 ,   5 ]    Why did that happen? Didn\u2019t we just copy the original list?\nThe truth is : we actually don\u2019t have a completely independent copy in this case. The copy() function generates a shallow copy. To see what it does, let\u2019s look at the ids of all the elements in my_list and the ids of all the elements in the copied list.  # for my_list    my_list   =   [[ 1 ,   2 ,   3 ],   4 ,   5 ]    id ( my_list )  140371873277424    print ([ id ( x )   for   x   in   my_list ])  [ 140371873599288 ,   13820176 ,   13820152 ]  # for another_list obtained by my_list.copy()    id ( another_list )  140371873317016    print ([ id ( x )   for   x   in   another_list ])  [ 140371873599288 ,   13820176 ,   13820152 ]   We see the ids of my_list and another_list are indeed different, indicating another_list is a copy. But the ids of the elements contained in another_list have the same ids as the elements in my_list . So the elements have not been copied!\nThis is the property of shallow copy. It creates a new copy of the object but reuses the attributes and elements of the old copy. Thus, when you modify the elements of the new copy, you are modifying the elements of the old copy too.\nTo solve this problem, we need to copy an object along with all its attributes and elements. This can be achieved by copy.deepcopy.    my_list   =   [[ 1 ,   2 ,   3 ],   4 ,   5 ]    another_list   =   copy . deepcopy ( my_list )    another_list [ 0 ]   +=   [ 6 ,]    another_list  [[ 1 ,   2 ,   3 ,   6 ],   4 ,   5 ]    my_list  [[ 1 ,   2 ,   3 ],   4 ,   5 ]   Deep copy is a quite time intensive operation and can take 1o times longer to complete compared to a shallow copy. But in some situations, it is unavoidable.",
            "title": "Assignment statements in Python are more interesting than you might think"
        },
        {
            "location": "/beginner/Datatype_And_Variables/#conclusion",
            "text": "This brings me to the end of this discussion. To summarize, we have talked about the different scenarios which can arise in an assignment statement in Python. We found that:   When the right hand side is a simple expression, a new copy is\n   created every time. There are some exceptions to this rule, which\n   depend on the implementation  When the right hand side is an existing Python variable, then an\n   alias is created for the existing copy.  When the right hand side is an operation, then the outcome depends on\n   the operation. In a simple case involving a tuple, we saw that an\n   independent copy was created. In the same case with lists, we saw\n   that the list was modified in place in one case (when we used\n    iadd ) and a new copy was generated in another case (when we used  add ).  List item  Mutable objects can be copied but immutable objects cannot be copied\n   in a straightforward way. There is also no need to copy immutable\n   objects.  To copy a mutable object along with all its attributes and elements,\n   we need to use deep copy.    Source:     https://medium.com/broken-window/many-names-one-memory-address-122f78734cb6",
            "title": "Conclusion"
        },
        {
            "location": "/About/",
            "text": "I'll write later",
            "title": "About"
        },
        {
            "location": "/About/#ill-write-later",
            "text": "",
            "title": "I'll write later"
        }
    ]
}