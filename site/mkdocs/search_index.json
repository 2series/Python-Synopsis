{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-mkdocs",
            "text": "For full documentation visit  mkdocs.org .",
            "title": "Welcome to MkDocs"
        },
        {
            "location": "/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/#commands_1",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/#commands_2",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/beginner/part1/",
            "text": "Welcome to Python Synopsis by Ent!\n\n\n\n\nThe Python Programming Language\n\n\nThe programming language you will learn is Python. Python is an example of a highlevel\nlanguage; other high-level languages you might have heard of are \nC, C++, Perl,\n\nand \nJava\n.\nThere are also low-level languages, sometimes referred to as \n\u201cmachine languages\u201d\n or\n\n\u201cassembly languages.\u201d\n Loosely speaking, computers can only run programs written in\nlow-level languages. So programs written in a high-level language have to be processed\nbefore they can run. This extra processing takes some time, which is a small disadvantage\nof high-level languages.\n\n\nThe advantages are enormous. First, it is much easier to program in a high-level lan\nguage. Programs written in a high-level language take less time to write, they are shorter\nand easier to read, and they are more likely to be correct. Second, high-level languages\nare portable, meaning that they can run on different kinds of computers with few or no\nmodifications. Low-level programs can run on only one kind of computer and have to\nbe rewritten to run on another.\n\n\nDue to these advantages, almost all programs are written in high-level languages. Lowlevel\nlanguages are used only for a few specialized applications.\n\n\nTwo kinds of programs process high-level languages into low-level languages:\ninterpreters and compilers. An interpreter reads a high-level program and executes it,\nmeaning that it does what the program says. It processes the program a little at a time,\nalternately reading lines and performing computations. Figure 1-1 shows the structure\nof an interpreter.\n\n\n \n\n\nA compiler reads the program and translates it completely before the program starts\nrunning. In this context, the high-level program is called the source code, and the\ntranslated program is called the object code or the executable. Once a program is com\npiled, you can execute it repeatedly without further translation. Figure 1-2 shows the\nstructure of a compiler.\n\n\n\n\nPython is considered an interpreted language because Python programs are executed\nby an interpreter. There are two ways to use the interpreter: \ninteractive\n mode and \nscript mode\n. In interactive mode, you type Python programs and the interpreter displays the\nresult:\n>\n 1 + 1\n2\nThe chevron, \n, is the prompt the interpreter uses to indicate that it is ready. If you\ntype 1 + 1, the interpreter replies 2.\n\n\nAlternatively, you can store code in a file and use the interpreter to execute the contents\nof the file, which is called a script. By convention, Python scripts have names that end\nwith .py.\nTo execute the script, you have to tell the interpreter the name of the file. If you have a\nscript named dinsdale.py and you are working in a UNIX command window, you type\npython dinsdale.py. In other development environments, the details of executing\nscripts are different. You can find instructions for your environment at the Python web\nsite http://python.org.\nWorking in interactive mode is convenient for testing small pieces of code because you\ncan type and execute them immediately. But for anything more than a few lines, you\nshould save your code as a script so you can modify and execute it in the future.\n\n\n\n\nSource:\n \n\n\n  \nThink Python\n by Allen B. Downey  - 2012\n\n\n\n\nPython\u2019s View\n\n\nThe brief description in the prior section is fairly standard for scripting languages, and\nit\u2019s usually all that most Python programmers need to know. You type code into text\nfiles, and you run those files through the interpreter. Under the hood, though, a bit\nmore happens when you tell Python to \u201cgo.\u201d Although knowledge of Python internals\nis not strictly required for Python programming, a basic understanding of the runtime\nstructure of Python can help you grasp the bigger picture of program execution.\nWhen you instruct Python to run your script, there are a few steps that Python carries\nout before your code actually starts crunching away. Specifically, it\u2019s first compiled to\nsomething called \u201cbyte code\u201d and then routed to something called a \u201cvirtual machine.\u201d\n\n\nByte code compilation\n\n\nInternally, and almost completely hidden from you, when you execute a program\nPython first compiles your source code (the statements in your file) into a format known\nas byte code. Compilation is simply a translation step, and byte code is a lower-level,\nplatform-independent representation of your source code. Roughly, Python translates\neach of your source statements into a group of byte code instructions by decomposing\nthem into individual steps. This byte code translation is performed to speed\nexecution\u2014byte code can be run much more quickly than the original source code\nstatements in your text file.\nYou\u2019ll notice that the prior paragraph said that this is almost completely hidden from\nyou. If the Python process has write access on your machine, it will store the byte code\nof your programs in files that end with a .pyc extension (\u201c.pyc\u201d means compiled \u201c.py\u201d\nsource). You will see these files show up on your computer after you\u2019ve run a few\nprograms alongside the corresponding source code files (that is, in the same\ndirectories).\nPython saves byte code like this as a startup speed optimization. The next time you run\nyour program, Python will load the .pyc files and skip the compilation step, as long as\nyou haven\u2019t changed your source code since the byte code was last saved. Python automatically\nchecks the timestamps of source and byte code files to know when it must\nrecompile\u2014if you resave your source code, byte code is automatically re-created the\nnext time your program is run.\nIf Python cannot write the byte code files to your machine, your program still works\u2014\nthe byte code is generated in memory and simply discarded on program exit.* However,\nbecause .pyc files speed startup time, you\u2019ll want to make sure they are written for larger\nprograms. Byte code files are also one way to ship Python programs\u2014Python is happy\nto run a program if all it can find are .pyc files, even if the original .py source files are\nabsent.\n\n\nThe Python Virtual Machine (PVM)\n\n\nOnce your program has been compiled to byte code (or the byte code has been loaded\nfrom existing .pyc files), it is shipped off for execution to something generally known\nas the Python Virtual Machine (PVM, for the more acronym-inclined among you). The\nPVM sounds more impressive than it is; really, it\u2019s not a separate program, and it need\nnot be installed by itself. In fact, the PVM is just a big loop that iterates through your\nbyte code instructions, one by one, to carry out their operations. The PVM is the runtime\nengine of Python; it\u2019s always present as part of the Python system, and it\u2019s the\ncomponent that truly runs your scripts. Technically, it\u2019s just the last step of what is\ncalled the \u201cPython interpreter.\u201d\n\n\n\n\nFigure  illustrates the runtime structure described here. Keep in mind that all of this\ncomplexity is deliberately hidden from Python programmers. Byte code compilation is\nautomatic, and the PVM is just part of the Python system that you have installed on\nyour machine. Again, programmers simply code and run files of statements.\n\n\nPerformance implications\n\n\nReaders with a background in fully compiled languages such as C and C++ might notice\na few differences in the Python model. For one thing, there is usually no build or \u201cmake\u201d\nstep in Python work: code runs immediately after it is written. For another, Python byte\ncode is not binary machine code (e.g., instructions for an Intel chip). Byte code is a\nPython-specific representation.\n\n\nThis is why some Python code may not run as fast as C or C++ code, as described in\nChapter 1\u2014the PVM loop, not the CPU chip, still must interpret the byte code, and\nbyte code instructions require more work than CPU instructions. On the other hand,\nunlike in classic interpreters, there is still an internal compile step\u2014Python does not\nneed to reanalyze and reparse each source statement repeatedly. The net effect is that\npure Python code runs at speeds somewhere between those of a traditional compiled\nlanguage and a traditional interpreted language. See Chapter 1 for more on Python\nperformance tradeoffs.\n\n\n\n\nSource:\n \n\n\n  \nLearning Python, Fourth Edition\n by Mark Lutz  - 2009\n\n\n\n\nPython Implementation Alternatives\n\n\nReally, as this book is being written, there are three primary implementations of the\nPython language\u2014CPython, Jython, and IronPython\u2014along with a handful of secondary\nimplementations such as Stackless Python. In brief, CPython is the standard implementation;\nall the others have very specific purposes and roles. All implement the\nsame Python language but execute programs in different ways.\n\n\nCPython\n\n\nThe original, and standard, implementation of Python is usually called CPython, when\nyou want to contrast it with the other two. Its name comes from the fact that it is coded\nin portable ANSI C language code. This is the Python that you fetch from http://www\n.python.org, get with the ActivePython distribution, and have automatically on most\nLinux and Mac OS X machines. If you\u2019ve found a preinstalled version of Python on\nyour machine, it\u2019s probably CPython, unless your company is using Python in very\nspecialized ways.\nUnless you want to script Java or .NET applications with Python, you probably want\nto use the standard CPython system. Because it is the reference implementation of the\nlanguage, it tends to run the fastest, be the most complete, and be more robust than\nthe alternative systems. Figure 1-3 reflects CPython\u2019s runtime architecture.\n\n\nJython\n\n\nThe Jython system (originally known as JPython) is an alternative implementation of\nthe Python language, targeted for integration with the Java programming language.\nJython consists of Java classes that compile Python source code to Java byte code and\nthen route the resulting byte code to the Java Virtual Machine (JVM). Programmers\nstill code Python statements in .py text files as usual; the Jython system essentially just\nreplaces the rightmost two bubbles in Figure 1-3 with Java-based equivalents.\nJython\u2019s goal is to allow Python code to script Java applications, much as CPython\nallows Python to script C and C++ components. Its integration with Java is remarkably\nseamless. Because Python code is translated to Java byte code, it looks and feels like a\ntrue Java program at runtime. Jython scripts can serve as web applets and servlets, build\nJava-based GUIs, and so on. Moreover, Jython includes integration support that allows\nPython code to import and use Java classes as though they were coded in Python.\nBecause Jython is slower and less robust than CPython, though, it is usually seen as a\ntool of interest primarily to Java developers looking for a scripting language to be a\nfrontend to Java code.\n\n\nIronPython\n\n\nA third implementation of Python, and newer than both CPython and Jython,\nIronPython is designed to allow Python programs to integrate with applications coded\nto work with Microsoft\u2019s .NET Framework for Windows, as well as the Mono open\nsource equivalent for Linux. .NET and its C# programming language runtime system\nare designed to be a language-neutral object communication layer, in the spirit of Microsoft\u2019s\nearlier COM model. IronPython allows Python programs to act as both client\nand server components, accessible from other .NET languages.\nBy implementation, IronPython is very much like Jython (and, in fact, was developed\nby the same creator)\u2014it replaces the last two bubbles in Figure 1-3 with equivalents\nfor execution in the .NET environment. Also, like Jython, IronPython has a special\nfocus\u2014it is primarily of interest to developers integrating Python with .NET components.\nBecause it is being developed by Microsoft, though, IronPython might also be\nable to leverage some important optimization tools for better performance.\nIronPython\u2019s scope is still evolving as I write this; for more details, consult the Python\nonline resources or search the Web.\n\n\n\n\nSource:\n \n\n\n \nLearning Python, Fourth Edition\n by Mark Lutz  - 2009\n\n\n\n\nPython Programming Language Advantages\n\n\nPython is a dynamic, strongly typed, object oriented, multipurpose programming language, designed to be quick (to learn, to use, and to understand), and to enforce a clean and uniform syntax.\n\n\n\n\nPython is dynamically typed: it means that you don't declare a type (e.g. 'integer') for a variable name, and then assign something of that type (and only that type). Instead, you have variable names, and you bind them to entities whose type stays with the entity itself. a = 5 makes the variable name a to refer to the integer 5. Later, a = \"hello\" makes the variable name a to refer to a string containing \"hello\". Static typed languages would have you declare int a and then a = 5, but assigning a = \"hello\" would have been a compile time error. On one hand, this makes everything more unpredictable (you don't know what a refers to). On the other hand, it makes very easy to achieve some results a static typed languages makes very difficult.\n\n\nPython is strongly typed. It means that if a = \"5\" (the string whose value is '5') will remain a string, and never coerced to a number if the context requires so. Every type conversion in python must be done explicitly. This is different from, for example, Perl or Javascript, where you have weak typing, and can write things like \"hello\" + 5 to get \"hello5\".\n\n\nPython is object oriented, with class-based inheritance. Everything is an object (including classes, functions, modules, etc), in the sense that they can be passed around as arguments, have methods and attributes, and so on. \n\n\nPython is multipurpose: it is not specialised to a specific target of users (like R for statistics, or PHP for web programming). It is extended through modules and libraries, that hook very easily into the C programming language.\n\n\nPython enforces correct indentation of the code by making the indentation part of the syntax. There are no control braces in Python. Blocks of code are identified by the level of indentation. Although a big turn off for many programmers not used to this, it is precious as it gives a very uniform style and results in code that is visually pleasant to read.\n\n\nThe code is compiled into byte code and then executed in a virtual machine. This means that precompiled code is portable between platforms.\n\n\n\n\nPython can be used for any programming task, from GUI programming to web programming with everything else in between. It's quite efficient, as much of its activity is done at the C level. Python is just a layer on top of C. There are libraries for everything you can think of: game programming and openGL, GUI interfaces, web frameworks, semantic web, scientific computing...\n\n\n\n\nSource:\n \n\n\n https://stackoverflow.com/questions/1909512/what-is-python-used-for\n\n\n\n\nAdventages again\n\n\n\n\nEasy Syntax\n\nPython's syntax is easy to learn, so both non-programmers and programmers can start programming right away.\n\n\nReadability\n\nPython's syntax is very clear, so it is easy to understand program code. (Python is often referred to as \"executable pseudo-code\" because its syntax mostly follows the conventions used by programmers to outline their ideas without the formal verbosity of code in most programming languages; in other words syntax of Python is almost identical to the simplified \"pseudo-code\" used by many programmers to prototype and describe their solution to other programmers. Thus Python can be used to prototype and test code which is later to be implemented in other programming languages).[citation needed]\n\n\nHigh-Level Language\n\nPython looks more like a readable, human language than like a low-level language. This gives you the ability to program at a faster rate than a low-level language will allow you.\n\n\nObject oriented programming\n\nObject-oriented programming allows you to create data structures that can be re-used, which reduces the amount of repetitive work that you'll need to do. Programming languages usually define objects with namespaces, like class or def, and objects can edit themselves by using keyword, like this or self. Most modern programming languages are object-oriented (such as Java, C++, and C#) or have support for OOP features (such as Perl version 5 and later). Additionally object-oriented techniques can be used in the design of almost any non-trivial software and implemented in almost any programming or scripting language. (For example a number of Linux kernel features are \"objects\" which implement their own encapsulation of behavior and data structive via pointers, specifically pointers to functions, in the C programming language).[citation needed] Python's support for object-oriented programming is one of its greatest benefits to new programmers because they will be encountering the same concepts and terminology in their work environment. If you ever decide to switch languages, or use any other for that fact, you'll have a significant chance that you'll be working with object-oriented programming.[1]\n\n\nIt's Free\n\nPython is both free and open-source. The Python Software Foundation distributes pre-made binaries that are freely available for use on all major operating systems called CPython. You can get CPython's source-code, too. Plus, you can modify the source code and distribute as allowed by CPython's license. [2] (Luckily, CPython has a permissive free software license attitude.)\n\n\nCross-platform\n\nPython runs on all major operating systems like Microsoft Windows, Linux, and Mac OS X.\n\n\nWidely Supported\n\nPython has an active support community with many web sites, mailing lists, and USENET \"netnews\" groups that attract a large number of knowledgeable and helpful contributes.\n\n\nIt's Safe\n\nPython doesn't have pointers like other C-based languages, making it much more reliable. Along with that, errors never pass silently unless they're explicitly silenced. This allows you to see and read why the program crashed and where to correct your error.\n\n\nBatteries Included\n\nPython is famous for being the \"batteries are included\" language.[3] There are over 300 standard library modules which contain modules and classes for a wide variety of programming tasks.[citation needed] For example the standard library contains modules for safely creating temporary files (named or anonymous), mapping files into memory (including use of shared and anonymous memory mappings), spawning and controlling sub-processes, compressing and decompressing files (compatible with gzip or PK-zip) and archives files (such as Unix/Linux \"tar\"), accessing indexed \"DBM\" (database) files, interfacing to various graphical user interfaces (such as the TK toolkit and the popular WxWindows multi-platform windowing system), parsing and maintaining CSV (comma-separated values) and \".cfg\" or \".ini\" configuration files (similar in syntax to the venerable WIN.INI files from MS-DOS and MS-Windows), for sending e-mail, fetching and parsing web pages, etc. It's possible, for example, to create a custom web server in Python using less than a dozen lines of code, and one of the standard libraries, of course.\n\n\nExtensible\n\nIn addition to the standard libraries there are extensive collections of freely available add-on modules, libraries, frameworks, and tool-kits. These generally conform to similar standards and conventions; for example almost all of the database adapters (to talk to almost any client-server RDBMS engine such as MySQL, Postgres, Oracle, etc) conform to the Python DBAPI and thus can mostly be accessed using the same code. So it's usually easy to modify a Python program to support any database engine.\n\n\n\n\n\n\nSource:\n \n\n\n https://en.wikiversity.org/wiki/Python_Concepts/Why_learn_Python\n\n\n\n\nWho Uses Python Today ?\n\n\nHere are links to just a few of the organizations that use python:\n\n- \n https://wiki.python.org/moin/OrganizationsUsingPython\n\n\nPython Success Stories :\n\n- \n https://www.python.org/about/success",
            "title": "The Python Programming Language, Implementation and Adventages"
        },
        {
            "location": "/beginner/part1/#welcome-to-python-synopsis-by-ent",
            "text": "",
            "title": "Welcome to Python Synopsis by Ent!"
        },
        {
            "location": "/beginner/part1/#the-python-programming-language",
            "text": "The programming language you will learn is Python. Python is an example of a highlevel\nlanguage; other high-level languages you might have heard of are  C, C++, Perl, \nand  Java .\nThere are also low-level languages, sometimes referred to as  \u201cmachine languages\u201d  or \u201cassembly languages.\u201d  Loosely speaking, computers can only run programs written in\nlow-level languages. So programs written in a high-level language have to be processed\nbefore they can run. This extra processing takes some time, which is a small disadvantage\nof high-level languages.  The advantages are enormous. First, it is much easier to program in a high-level lan\nguage. Programs written in a high-level language take less time to write, they are shorter\nand easier to read, and they are more likely to be correct. Second, high-level languages\nare portable, meaning that they can run on different kinds of computers with few or no\nmodifications. Low-level programs can run on only one kind of computer and have to\nbe rewritten to run on another.  Due to these advantages, almost all programs are written in high-level languages. Lowlevel\nlanguages are used only for a few specialized applications.  Two kinds of programs process high-level languages into low-level languages:\ninterpreters and compilers. An interpreter reads a high-level program and executes it,\nmeaning that it does what the program says. It processes the program a little at a time,\nalternately reading lines and performing computations. Figure 1-1 shows the structure\nof an interpreter.     A compiler reads the program and translates it completely before the program starts\nrunning. In this context, the high-level program is called the source code, and the\ntranslated program is called the object code or the executable. Once a program is com\npiled, you can execute it repeatedly without further translation. Figure 1-2 shows the\nstructure of a compiler.   Python is considered an interpreted language because Python programs are executed\nby an interpreter. There are two ways to use the interpreter:  interactive  mode and  script mode . In interactive mode, you type Python programs and the interpreter displays the\nresult:\n>  1 + 1\n2\nThe chevron,  , is the prompt the interpreter uses to indicate that it is ready. If you\ntype 1 + 1, the interpreter replies 2.  Alternatively, you can store code in a file and use the interpreter to execute the contents\nof the file, which is called a script. By convention, Python scripts have names that end\nwith .py.\nTo execute the script, you have to tell the interpreter the name of the file. If you have a\nscript named dinsdale.py and you are working in a UNIX command window, you type\npython dinsdale.py. In other development environments, the details of executing\nscripts are different. You can find instructions for your environment at the Python web\nsite http://python.org.\nWorking in interactive mode is convenient for testing small pieces of code because you\ncan type and execute them immediately. But for anything more than a few lines, you\nshould save your code as a script so you can modify and execute it in the future.   Source:       Think Python  by Allen B. Downey  - 2012",
            "title": "The Python Programming Language"
        },
        {
            "location": "/beginner/part1/#pythons-view",
            "text": "The brief description in the prior section is fairly standard for scripting languages, and\nit\u2019s usually all that most Python programmers need to know. You type code into text\nfiles, and you run those files through the interpreter. Under the hood, though, a bit\nmore happens when you tell Python to \u201cgo.\u201d Although knowledge of Python internals\nis not strictly required for Python programming, a basic understanding of the runtime\nstructure of Python can help you grasp the bigger picture of program execution.\nWhen you instruct Python to run your script, there are a few steps that Python carries\nout before your code actually starts crunching away. Specifically, it\u2019s first compiled to\nsomething called \u201cbyte code\u201d and then routed to something called a \u201cvirtual machine.\u201d",
            "title": "Python\u2019s View"
        },
        {
            "location": "/beginner/part1/#byte-code-compilation",
            "text": "Internally, and almost completely hidden from you, when you execute a program\nPython first compiles your source code (the statements in your file) into a format known\nas byte code. Compilation is simply a translation step, and byte code is a lower-level,\nplatform-independent representation of your source code. Roughly, Python translates\neach of your source statements into a group of byte code instructions by decomposing\nthem into individual steps. This byte code translation is performed to speed\nexecution\u2014byte code can be run much more quickly than the original source code\nstatements in your text file.\nYou\u2019ll notice that the prior paragraph said that this is almost completely hidden from\nyou. If the Python process has write access on your machine, it will store the byte code\nof your programs in files that end with a .pyc extension (\u201c.pyc\u201d means compiled \u201c.py\u201d\nsource). You will see these files show up on your computer after you\u2019ve run a few\nprograms alongside the corresponding source code files (that is, in the same\ndirectories).\nPython saves byte code like this as a startup speed optimization. The next time you run\nyour program, Python will load the .pyc files and skip the compilation step, as long as\nyou haven\u2019t changed your source code since the byte code was last saved. Python automatically\nchecks the timestamps of source and byte code files to know when it must\nrecompile\u2014if you resave your source code, byte code is automatically re-created the\nnext time your program is run.\nIf Python cannot write the byte code files to your machine, your program still works\u2014\nthe byte code is generated in memory and simply discarded on program exit.* However,\nbecause .pyc files speed startup time, you\u2019ll want to make sure they are written for larger\nprograms. Byte code files are also one way to ship Python programs\u2014Python is happy\nto run a program if all it can find are .pyc files, even if the original .py source files are\nabsent.",
            "title": "Byte code compilation"
        },
        {
            "location": "/beginner/part1/#the-python-virtual-machine-pvm",
            "text": "Once your program has been compiled to byte code (or the byte code has been loaded\nfrom existing .pyc files), it is shipped off for execution to something generally known\nas the Python Virtual Machine (PVM, for the more acronym-inclined among you). The\nPVM sounds more impressive than it is; really, it\u2019s not a separate program, and it need\nnot be installed by itself. In fact, the PVM is just a big loop that iterates through your\nbyte code instructions, one by one, to carry out their operations. The PVM is the runtime\nengine of Python; it\u2019s always present as part of the Python system, and it\u2019s the\ncomponent that truly runs your scripts. Technically, it\u2019s just the last step of what is\ncalled the \u201cPython interpreter.\u201d   Figure  illustrates the runtime structure described here. Keep in mind that all of this\ncomplexity is deliberately hidden from Python programmers. Byte code compilation is\nautomatic, and the PVM is just part of the Python system that you have installed on\nyour machine. Again, programmers simply code and run files of statements.",
            "title": "The Python Virtual Machine (PVM)"
        },
        {
            "location": "/beginner/part1/#performance-implications",
            "text": "Readers with a background in fully compiled languages such as C and C++ might notice\na few differences in the Python model. For one thing, there is usually no build or \u201cmake\u201d\nstep in Python work: code runs immediately after it is written. For another, Python byte\ncode is not binary machine code (e.g., instructions for an Intel chip). Byte code is a\nPython-specific representation.  This is why some Python code may not run as fast as C or C++ code, as described in\nChapter 1\u2014the PVM loop, not the CPU chip, still must interpret the byte code, and\nbyte code instructions require more work than CPU instructions. On the other hand,\nunlike in classic interpreters, there is still an internal compile step\u2014Python does not\nneed to reanalyze and reparse each source statement repeatedly. The net effect is that\npure Python code runs at speeds somewhere between those of a traditional compiled\nlanguage and a traditional interpreted language. See Chapter 1 for more on Python\nperformance tradeoffs.   Source:       Learning Python, Fourth Edition  by Mark Lutz  - 2009",
            "title": "Performance implications"
        },
        {
            "location": "/beginner/part1/#python-implementation-alternatives",
            "text": "Really, as this book is being written, there are three primary implementations of the\nPython language\u2014CPython, Jython, and IronPython\u2014along with a handful of secondary\nimplementations such as Stackless Python. In brief, CPython is the standard implementation;\nall the others have very specific purposes and roles. All implement the\nsame Python language but execute programs in different ways.",
            "title": "Python Implementation Alternatives"
        },
        {
            "location": "/beginner/part1/#cpython",
            "text": "The original, and standard, implementation of Python is usually called CPython, when\nyou want to contrast it with the other two. Its name comes from the fact that it is coded\nin portable ANSI C language code. This is the Python that you fetch from http://www\n.python.org, get with the ActivePython distribution, and have automatically on most\nLinux and Mac OS X machines. If you\u2019ve found a preinstalled version of Python on\nyour machine, it\u2019s probably CPython, unless your company is using Python in very\nspecialized ways.\nUnless you want to script Java or .NET applications with Python, you probably want\nto use the standard CPython system. Because it is the reference implementation of the\nlanguage, it tends to run the fastest, be the most complete, and be more robust than\nthe alternative systems. Figure 1-3 reflects CPython\u2019s runtime architecture.",
            "title": "CPython"
        },
        {
            "location": "/beginner/part1/#jython",
            "text": "The Jython system (originally known as JPython) is an alternative implementation of\nthe Python language, targeted for integration with the Java programming language.\nJython consists of Java classes that compile Python source code to Java byte code and\nthen route the resulting byte code to the Java Virtual Machine (JVM). Programmers\nstill code Python statements in .py text files as usual; the Jython system essentially just\nreplaces the rightmost two bubbles in Figure 1-3 with Java-based equivalents.\nJython\u2019s goal is to allow Python code to script Java applications, much as CPython\nallows Python to script C and C++ components. Its integration with Java is remarkably\nseamless. Because Python code is translated to Java byte code, it looks and feels like a\ntrue Java program at runtime. Jython scripts can serve as web applets and servlets, build\nJava-based GUIs, and so on. Moreover, Jython includes integration support that allows\nPython code to import and use Java classes as though they were coded in Python.\nBecause Jython is slower and less robust than CPython, though, it is usually seen as a\ntool of interest primarily to Java developers looking for a scripting language to be a\nfrontend to Java code.",
            "title": "Jython"
        },
        {
            "location": "/beginner/part1/#ironpython",
            "text": "A third implementation of Python, and newer than both CPython and Jython,\nIronPython is designed to allow Python programs to integrate with applications coded\nto work with Microsoft\u2019s .NET Framework for Windows, as well as the Mono open\nsource equivalent for Linux. .NET and its C# programming language runtime system\nare designed to be a language-neutral object communication layer, in the spirit of Microsoft\u2019s\nearlier COM model. IronPython allows Python programs to act as both client\nand server components, accessible from other .NET languages.\nBy implementation, IronPython is very much like Jython (and, in fact, was developed\nby the same creator)\u2014it replaces the last two bubbles in Figure 1-3 with equivalents\nfor execution in the .NET environment. Also, like Jython, IronPython has a special\nfocus\u2014it is primarily of interest to developers integrating Python with .NET components.\nBecause it is being developed by Microsoft, though, IronPython might also be\nable to leverage some important optimization tools for better performance.\nIronPython\u2019s scope is still evolving as I write this; for more details, consult the Python\nonline resources or search the Web.   Source:      Learning Python, Fourth Edition  by Mark Lutz  - 2009",
            "title": "IronPython"
        },
        {
            "location": "/beginner/part1/#python-programming-language-advantages",
            "text": "Python is a dynamic, strongly typed, object oriented, multipurpose programming language, designed to be quick (to learn, to use, and to understand), and to enforce a clean and uniform syntax.   Python is dynamically typed: it means that you don't declare a type (e.g. 'integer') for a variable name, and then assign something of that type (and only that type). Instead, you have variable names, and you bind them to entities whose type stays with the entity itself. a = 5 makes the variable name a to refer to the integer 5. Later, a = \"hello\" makes the variable name a to refer to a string containing \"hello\". Static typed languages would have you declare int a and then a = 5, but assigning a = \"hello\" would have been a compile time error. On one hand, this makes everything more unpredictable (you don't know what a refers to). On the other hand, it makes very easy to achieve some results a static typed languages makes very difficult.  Python is strongly typed. It means that if a = \"5\" (the string whose value is '5') will remain a string, and never coerced to a number if the context requires so. Every type conversion in python must be done explicitly. This is different from, for example, Perl or Javascript, where you have weak typing, and can write things like \"hello\" + 5 to get \"hello5\".  Python is object oriented, with class-based inheritance. Everything is an object (including classes, functions, modules, etc), in the sense that they can be passed around as arguments, have methods and attributes, and so on.   Python is multipurpose: it is not specialised to a specific target of users (like R for statistics, or PHP for web programming). It is extended through modules and libraries, that hook very easily into the C programming language.  Python enforces correct indentation of the code by making the indentation part of the syntax. There are no control braces in Python. Blocks of code are identified by the level of indentation. Although a big turn off for many programmers not used to this, it is precious as it gives a very uniform style and results in code that is visually pleasant to read.  The code is compiled into byte code and then executed in a virtual machine. This means that precompiled code is portable between platforms.   Python can be used for any programming task, from GUI programming to web programming with everything else in between. It's quite efficient, as much of its activity is done at the C level. Python is just a layer on top of C. There are libraries for everything you can think of: game programming and openGL, GUI interfaces, web frameworks, semantic web, scientific computing...   Source:     https://stackoverflow.com/questions/1909512/what-is-python-used-for",
            "title": "Python Programming Language Advantages"
        },
        {
            "location": "/beginner/part1/#adventages-again",
            "text": "Easy Syntax \nPython's syntax is easy to learn, so both non-programmers and programmers can start programming right away.  Readability \nPython's syntax is very clear, so it is easy to understand program code. (Python is often referred to as \"executable pseudo-code\" because its syntax mostly follows the conventions used by programmers to outline their ideas without the formal verbosity of code in most programming languages; in other words syntax of Python is almost identical to the simplified \"pseudo-code\" used by many programmers to prototype and describe their solution to other programmers. Thus Python can be used to prototype and test code which is later to be implemented in other programming languages).[citation needed]  High-Level Language \nPython looks more like a readable, human language than like a low-level language. This gives you the ability to program at a faster rate than a low-level language will allow you.  Object oriented programming \nObject-oriented programming allows you to create data structures that can be re-used, which reduces the amount of repetitive work that you'll need to do. Programming languages usually define objects with namespaces, like class or def, and objects can edit themselves by using keyword, like this or self. Most modern programming languages are object-oriented (such as Java, C++, and C#) or have support for OOP features (such as Perl version 5 and later). Additionally object-oriented techniques can be used in the design of almost any non-trivial software and implemented in almost any programming or scripting language. (For example a number of Linux kernel features are \"objects\" which implement their own encapsulation of behavior and data structive via pointers, specifically pointers to functions, in the C programming language).[citation needed] Python's support for object-oriented programming is one of its greatest benefits to new programmers because they will be encountering the same concepts and terminology in their work environment. If you ever decide to switch languages, or use any other for that fact, you'll have a significant chance that you'll be working with object-oriented programming.[1]  It's Free \nPython is both free and open-source. The Python Software Foundation distributes pre-made binaries that are freely available for use on all major operating systems called CPython. You can get CPython's source-code, too. Plus, you can modify the source code and distribute as allowed by CPython's license. [2] (Luckily, CPython has a permissive free software license attitude.)  Cross-platform \nPython runs on all major operating systems like Microsoft Windows, Linux, and Mac OS X.  Widely Supported \nPython has an active support community with many web sites, mailing lists, and USENET \"netnews\" groups that attract a large number of knowledgeable and helpful contributes.  It's Safe \nPython doesn't have pointers like other C-based languages, making it much more reliable. Along with that, errors never pass silently unless they're explicitly silenced. This allows you to see and read why the program crashed and where to correct your error.  Batteries Included \nPython is famous for being the \"batteries are included\" language.[3] There are over 300 standard library modules which contain modules and classes for a wide variety of programming tasks.[citation needed] For example the standard library contains modules for safely creating temporary files (named or anonymous), mapping files into memory (including use of shared and anonymous memory mappings), spawning and controlling sub-processes, compressing and decompressing files (compatible with gzip or PK-zip) and archives files (such as Unix/Linux \"tar\"), accessing indexed \"DBM\" (database) files, interfacing to various graphical user interfaces (such as the TK toolkit and the popular WxWindows multi-platform windowing system), parsing and maintaining CSV (comma-separated values) and \".cfg\" or \".ini\" configuration files (similar in syntax to the venerable WIN.INI files from MS-DOS and MS-Windows), for sending e-mail, fetching and parsing web pages, etc. It's possible, for example, to create a custom web server in Python using less than a dozen lines of code, and one of the standard libraries, of course.  Extensible \nIn addition to the standard libraries there are extensive collections of freely available add-on modules, libraries, frameworks, and tool-kits. These generally conform to similar standards and conventions; for example almost all of the database adapters (to talk to almost any client-server RDBMS engine such as MySQL, Postgres, Oracle, etc) conform to the Python DBAPI and thus can mostly be accessed using the same code. So it's usually easy to modify a Python program to support any database engine.    Source:     https://en.wikiversity.org/wiki/Python_Concepts/Why_learn_Python",
            "title": "Adventages again"
        },
        {
            "location": "/beginner/part1/#who-uses-python-today",
            "text": "Here are links to just a few of the organizations that use python: \n-   https://wiki.python.org/moin/OrganizationsUsingPython  Python Success Stories : \n-   https://www.python.org/about/success",
            "title": "Who Uses Python Today ?"
        },
        {
            "location": "/About/",
            "text": "Sit qua me lacrimis beatum pontum natorum\n\n\nQuos Minoide sepulcrales pomi\n\n\nLorem markdownum magnae prosternite omnes alveus vimine \ntranscribere\n timuere\n\npenetrale\n; ambrosia marinas abruptaque corpora telum. Non admotum foret;\ndomo, nova veniam pondere; incipit.\n\n\n\n\nTu hic\n\n\nCruores nec sororis heros amor fronti inplevere\n\n\nConcitat dolens\n\n\nCandentia genitore fiant\n\n\nLinguam viderat coniuge rebar abire\n\n\n\n\nToto una miser spondet mutataeque obsedit hederae \nmurmure Penthea gerebat\n\nsolebat tradidit! Perque sua caput genis terram vidit: di arces vidit inopes\ncaelo defendere harundo causa. Rota possit herbis bello peregit auctor rursus\nhabebimus nubibus maxima. Et et dicere, cultor, tamen arva \nPericlymeni\ncaelum\n saepe sunt emicat vidit.\n\n\nRepperit est quoque visus at tamen in\n\n\nEsse patior virga sit feruntur arva palustres prohibebar\n\nvultusque\n audiri turbantur visum, gelidos?\nLuctus et fabricata esse temptant molliri admonitorque dare currunt,\n\ndedit\n? Amoris mihi properabat petit,\nsalve supremo haec rumoribus fine. Esse et futuri oculos duos Pandion?\n\n\n\n\nQuis Vidi: ferox sub incenduntque Lycopen estque pennae iactat! Hanc corpus\nneve Hecate Herculeis vacuum! Res illa fortunata iuvencae summa!\n\n\n\n\nVenilia oscula; ora felicior metus hospita. Visendae\n\nmolitur\n. Iuvat non umerique\nnostraque accipitris Somnia retentis ceciderunt adero mutatus? Est deum occiduo\nodoro adnuit et omnibus ponunt, natalibus tecta, amanti. Ipse in perdere\nCyllenide \nopibus Aiaci\n calculus est \nexegi\n, in ergo altis monitis ore\nquattuor enim.\n\n\nNostra terris Veneri et et exiguus omnia\n\n\nTimore et genitor virum Apolline relicta e in nemus erant, ulla hunc pro,\nquaeque caducifer supra et. Amicas tigno toris: incustoditae mora est,\nrequiritur nostra. Pronusque caret tegumenque Iovis, Tartara hos viri ignis,\naconiton praebuit Pithecusas sumo. Omne illo; contigit de quod \nest cara\nsuo\n, Ceres spatio et vetus haeserat, de.\n\n\nvolume_rootkit_tag += pcb_bar(packet_wildcard, document);\nif (token_dos / repeater * opacity_bar /\n        ddrProgressiveStreaming.clipboardTimeInternal(dllCameraCable)) {\n    peripheral_index += 1;\n}\nnewbie += favorites_integrated - operatingDacProcess + 4 +\n        hypermedia_link_output + fiosGnuCut;\ndata(tweetFormatData.sync_software(packetDirectDrive, duplex.openglDrive(\n        cable, compression_clean, 3), chip_trojan(1, type,\n        minisite_printer)), -1, dvi_leaf * maximizeDriveCaps);\n\n\n\nAchivam undas filum parte sustulit, tellure aderam Mavortis carens! Pro in si\nilla amor neget iurasse morsus. Temeraria potuit. Nec stipite, terris sed invito\nest nimia nam, in sis tum naufragus \nipse vota\n gramina auferat dixit: dies.\nSit ulciscitur navis, navita duplex voveas, tui potest \nversa\n, aequora ut\nnumine fidelius pudet.",
            "title": "About"
        },
        {
            "location": "/About/#sit-qua-me-lacrimis-beatum-pontum-natorum",
            "text": "",
            "title": "Sit qua me lacrimis beatum pontum natorum"
        },
        {
            "location": "/About/#quos-minoide-sepulcrales-pomi",
            "text": "Lorem markdownum magnae prosternite omnes alveus vimine  transcribere  timuere penetrale ; ambrosia marinas abruptaque corpora telum. Non admotum foret;\ndomo, nova veniam pondere; incipit.   Tu hic  Cruores nec sororis heros amor fronti inplevere  Concitat dolens  Candentia genitore fiant  Linguam viderat coniuge rebar abire   Toto una miser spondet mutataeque obsedit hederae  murmure Penthea gerebat \nsolebat tradidit! Perque sua caput genis terram vidit: di arces vidit inopes\ncaelo defendere harundo causa. Rota possit herbis bello peregit auctor rursus\nhabebimus nubibus maxima. Et et dicere, cultor, tamen arva  Periclymeni\ncaelum  saepe sunt emicat vidit.",
            "title": "Quos Minoide sepulcrales pomi"
        },
        {
            "location": "/About/#repperit-est-quoque-visus-at-tamen-in",
            "text": "Esse patior virga sit feruntur arva palustres prohibebar vultusque  audiri turbantur visum, gelidos?\nLuctus et fabricata esse temptant molliri admonitorque dare currunt, dedit ? Amoris mihi properabat petit,\nsalve supremo haec rumoribus fine. Esse et futuri oculos duos Pandion?   Quis Vidi: ferox sub incenduntque Lycopen estque pennae iactat! Hanc corpus\nneve Hecate Herculeis vacuum! Res illa fortunata iuvencae summa!   Venilia oscula; ora felicior metus hospita. Visendae molitur . Iuvat non umerique\nnostraque accipitris Somnia retentis ceciderunt adero mutatus? Est deum occiduo\nodoro adnuit et omnibus ponunt, natalibus tecta, amanti. Ipse in perdere\nCyllenide  opibus Aiaci  calculus est  exegi , in ergo altis monitis ore\nquattuor enim.",
            "title": "Repperit est quoque visus at tamen in"
        },
        {
            "location": "/About/#nostra-terris-veneri-et-et-exiguus-omnia",
            "text": "Timore et genitor virum Apolline relicta e in nemus erant, ulla hunc pro,\nquaeque caducifer supra et. Amicas tigno toris: incustoditae mora est,\nrequiritur nostra. Pronusque caret tegumenque Iovis, Tartara hos viri ignis,\naconiton praebuit Pithecusas sumo. Omne illo; contigit de quod  est cara\nsuo , Ceres spatio et vetus haeserat, de.  volume_rootkit_tag += pcb_bar(packet_wildcard, document);\nif (token_dos / repeater * opacity_bar /\n        ddrProgressiveStreaming.clipboardTimeInternal(dllCameraCable)) {\n    peripheral_index += 1;\n}\nnewbie += favorites_integrated - operatingDacProcess + 4 +\n        hypermedia_link_output + fiosGnuCut;\ndata(tweetFormatData.sync_software(packetDirectDrive, duplex.openglDrive(\n        cable, compression_clean, 3), chip_trojan(1, type,\n        minisite_printer)), -1, dvi_leaf * maximizeDriveCaps);  Achivam undas filum parte sustulit, tellure aderam Mavortis carens! Pro in si\nilla amor neget iurasse morsus. Temeraria potuit. Nec stipite, terris sed invito\nest nimia nam, in sis tum naufragus  ipse vota  gramina auferat dixit: dies.\nSit ulciscitur navis, navita duplex voveas, tui potest  versa , aequora ut\nnumine fidelius pudet.",
            "title": "Nostra terris Veneri et et exiguus omnia"
        }
    ]
}